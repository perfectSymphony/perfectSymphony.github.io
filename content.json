{"meta":{"title":"perfectSymphony の 博客","subtitle":"","description":"","author":"John Doe","url":"https://perfectsymphony.github.io","root":"/"},"pages":[{"title":"about","date":"2021-01-24T12:44:14.000Z","updated":"2021-01-24T16:40:17.146Z","comments":true,"path":"about/index.html","permalink":"https://perfectsymphony.github.io/about/index.html","excerpt":"","text":"努力开发中。。。。。"},{"title":"changelog","date":"2021-01-24T16:31:40.000Z","updated":"2021-01-24T16:42:35.292Z","comments":true,"path":"changelog/index.html","permalink":"https://perfectsymphony.github.io/changelog/index.html","excerpt":"","text":"努力开发中。。。。。"},{"title":"tags","date":"2021-01-24T16:28:02.000Z","updated":"2021-01-24T16:28:02.479Z","comments":true,"path":"tags/index.html","permalink":"https://perfectsymphony.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BFF架构设计","slug":"BFF架构设计","date":"2021-01-14T04:01:06.000Z","updated":"2021-01-24T12:51:48.353Z","comments":true,"path":"2021/01/14/BFF架构设计/","link":"","permalink":"https://perfectsymphony.github.io/2021/01/14/BFF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。 最近在公司的微服务架构中遇到了一些多终端访问接口的问题，不同的终端拥有不同的接口服务，有不同的操作数据的能力，针对这种业务场景做出了调研，我们是否可以在不同的访问层进行业务逻辑处理，获取不同的数据内容呢？ 早在微服务出现的初期就已经存在类似的业务需求出现，而且衍生出了一套成熟的解决方案，那就是BFF，可以针对不用业务场景来提供对应的服务接口，每一种业务场景之间完全独立。 演进过程在传统的应用程序中，我们一般只将接口提供给一种类型的终端使用。 单端调用基础服务 传统的应用程序内提供的接口是有业务针对性的，这种类型的接口如果独立出来再提供给别的系统再次使用是一件比较麻烦的事情，设计初期的高耦合就决定了这一点。 多端直接调用基础服务 如果我们的接口同时提供给web、移动端使用，移动端仅用来采集数据以及数据的展示，而web端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。 多端共用一个BFF 针对多端共用服务接口的场景，我们将基础的数据服务与BFF进行了分离，数据服务仅提供数据的增删改查，并不过多涉及业务的判断处理，所有业务判断处理都交给BFF来把控，遇到的一些业务逻辑异常也同样由BFF格式化处理后展示给访问端点。 这种设计方式同样存在一定的问题，虽然基础服务与BFF进行了分离，我们只需要在BFF层面进行业务判断处理，但是多个端共用一个BFF，也会导致代码编写复杂度增高、代码可阅读性降低、多端业务耦合。 每个端提供一个BFF 如果我们为每一个端点都提供一个BFF，每个端点的BFF处理自身的业务逻辑，需要数据时从基础服务内获取，然后在接口返回之前进行组装数据用于实例化返回对象。 这样基础服务如果有新功能添加，BFF几乎不会受到影响，而我们如果后期把App端点进行拆分成Android、IOS时我们只需要将app-bff进行拆分为android-bff、ios-bff，基础服务同样也不会受到影响 这样每当新增一个访问端点时，我们需要修改的地方也只有网关的转发以及添加一个BFF即可，基础服务内提供的服务接口我们完全可以复用，因为基础服务提供的接口都是没有业务针对性的！！！ 总结在微服务架构设计中，BFF起到了一个业务聚合的关键作用，可以 通过openfeign、restTemplate调用基础服务来获取数据，将获取到的数据进行组装返回结果对象，BFF解决了业务场景问题，也同样带来了一些问题，如下所示： 响应时间延迟（服务如果是内网之间访问，延迟时间较低）编写起来较为浪费时间（因为在基础服务上添加的一层转发，所以会多写一部分代码）业务异常处理（统一格式化业务异常的返回内容）分布式事务（微服务的通病） 提问： 采用BFF架构与多端公用、单一的API有什么优点了？ 它能够满足因不同客户端特殊的交互引起的对新接口的要求，所以一开始就会针对相应的设备设计好对应的接口。如果使用单一、通用的API，我们一开始并没有考虑到特殊需求，那么有新的请求需要出现时，可能会出现以下问题：(1)如果添加新的接口，这样容易造成接口的不稳定；(2)如果考虑在原有的接口上进行修改，可能需要会产生一些的耦合，破坏单一职责。 考虑这样一个简单例子，因为移动APP的屏幕限制，在某一个列表页我们只需要展示一些关键的信息，但是由于调用的是服务端提供统一的API，服务端在设计的时候只考虑到了web端，返回所有的字段信息，但这些对于移动端而言都是无用的。在优化性能时处理这样的问题时，服务器端就需要新增接口或者通过引入相关耦合来解决这样的问题。而使用BFF在很大程度能避免这样的问题。使用BFF的另一个优点就是当由于某一客户端需要调用调用多个不同的服务端接口来实现某一功能时，可以直接在对应的BFF层编写相应的API，而不会影响到基层的公共服务，且客户端不用直接向多个后台发起调用，可以优化性能。 贴一张用来总结的大图： 从这个技术体系图中看到，作为应用服务层的API服务就是BFF，他们会从基础业务服务如客户服务、订单服务、产品服务等微服务中获取数据，进行一定的聚合和裁剪返回个某个具体业务线的前端应用，前端应用可能是SPA也可能是H5应用。BFF层的API服务，我们在实践中大部分都使用了ASP.NET Core进行开发，同时也在尝试使用Go进行开发，也让前端有兴趣的同事引入进来用Go进行BFF的开发。但是，在基础服务层面即前面所说的业务中台层，还是由后端同事使用ASP.NET Core开发，确保质量。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://perfectsymphony.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"Uncaught TypeError: Cannot assign to read only property exports of object","slug":"Uncaught-TypeError-Cannot-assign-to-read-only-property-exports-of-object","date":"2021-01-12T03:03:06.000Z","updated":"2021-01-12T03:39:22.000Z","comments":true,"path":"2021/01/12/Uncaught-TypeError-Cannot-assign-to-read-only-property-exports-of-object/","link":"","permalink":"https://perfectsymphony.github.io/2021/01/12/Uncaught-TypeError-Cannot-assign-to-read-only-property-exports-of-object/","excerpt":"","text":"vue项目打包后生成的dist文件部署到GitHub page上之后，访问时，报Uncaught TypeError: Cannot assign to read only property &#39;exports&#39; of object &#39;#&lt;Object&gt;&#39; 原因：webpack 2中不允许混用import和module.exports 解决办法：一、每个页面模块目录通过一个 index.js 主入口来导出（module.exports）对应的vue文件，然后 router.js 中通过 require 方法去引入资源。 这一做法是没毛病的，因为这是组织（webpack 2）允许的。 二、如果好好的require不用，非要用 import 那么请不要和 module.exports 混合服用，因为这是组织不允许的，此时便会报标题的错。（Uncaught TypeError: Cannot assign to read only property ‘exports’ of object ‘#‘） 三、如果你还是要用 import 方法来引入资源的话，你可以放弃 module.exports ，直接引入vue文件路径，因为 import 和 export default 是组织运行的。 四、使用babel 的 plugins babel-plugin-dynamic-import-node。它只做一件事就是将所有的import()转化为require()，这样就可以用这个插件将所有异步组件都用同步的方式引入，并结合 BABEL_ENV 这个babel环境变量，让它只作用于开发环境下，在开发环境中将所有import()转化为require()，这种方案解决了之前重复打包的问题，同时对代码的侵入性也很小，你平时写路由的时候只需要按照官方文档路由懒加载的方式就可以了，其它的都交给babel来处理，当你不想用这个方案的时候，也只要将它从babel的 plugins中移除就可以了。 12345678910module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27; ], &#x27;env&#x27;: &#123; &#x27;development&#x27;: &#123; &#x27;plugins&#x27;: [&#x27;dynamic-import-node&#x27;] &#125; &#125;&#125; 结论：1、exports 导出的东西需要 require 引入！ 2、export 导出的东西需要 import 引入！ 3、在webpack 2中不允许混用 import 和 module.exports 总结：其实正确地去理解这个报错的话，就一定要去整明白 require 和 import 的区别！ node编程中最重要的思想就是模块化，import和require都是被模块化所使用。1、遵循规范require / exports 是CommonJS的一部分import / export 是ES6的新规范，如果要兼容浏览器的话必须转化成es5的语法2、调用时间require 是运行时调用，所以require理论上可以运用在代码的任何地方import 是编译时调用，所以必须放在文件开头3、本质require 是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量import 是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require","categories":[],"tags":[{"name":"问题记录","slug":"问题记录","permalink":"https://perfectsymphony.github.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"算法总结","slug":"算法总结","date":"2021-01-04T09:46:27.000Z","updated":"2021-01-04T09:49:23.000Z","comments":true,"path":"2021/01/04/算法总结/","link":"","permalink":"https://perfectsymphony.github.io/2021/01/04/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"1234567891011121314151. 用任意一种语言实现一个函数，判断一个给定整数数组中是否存在某两个元素之和恰好等于一个给定值 k， 存在则返回 true，否则返回 false。该函数的输入参数有两个，第一个参数为整数数组 nums，第二个参数为整数 k，返回值为布尔值。 可以参考以下签名，写出实现。【请不要使用排序！要求时间复杂度为 O(n)，n 为数组长度】// JavaScriptvar checkTwoSum = function(nums, k) &#123; var temp = []; for(var i = 0; i &lt; nums.length; i++)&#123; var dif = k-nums[i]; if(temp[dif] != undefined)&#123; return true; &#125; return false &#125;&#125; 2. 手动实现一种时间复杂度为 O(n log n) 的排序算法，可用任意语言实现，也可以只写出伪代码。123456789101112131415161718192021222324252627282930313233/** * 二分法 * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */ var intersection = function(nums1, nums2) &#123; let res = new Set(); nums2 = nums2.sort((a,b) =&gt; a - b); let binarySearch = (arr,val) =&gt; &#123; let left = 0; let right = arr.length - 1; while(left &lt;= right)&#123; let mid = (left + right) &gt;&gt; 1; if(arr[mid] === val)&#123; return true; &#125;else if(arr[mid] &gt; val)&#123; right = mid - 1; &#125;else&#123; left = mid + 1; &#125; &#125; return false; &#125; for(let i = 0;i &lt; nums1.length;i++)&#123; if(binarySearch(nums2,nums1[i]))&#123; res.add(nums1[i]); &#125; &#125; return [...res];&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://perfectsymphony.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"关于面向对象","slug":"关于面向对象","date":"2021-01-04T09:08:28.000Z","updated":"2021-01-04T09:19:15.000Z","comments":true,"path":"2021/01/04/关于面向对象/","link":"","permalink":"https://perfectsymphony.github.io/2021/01/04/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"ES5实现面向对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ES5 面向对象继承 组合使用原型链和构造函数// 父类构造函数function Person(name, age, friends)&#123; this.name = name; this.age = age; this.friends = friends; // this.say = function()&#123; // console.log(this.name+&#x27;的朋友&#x27;+this.friends+&#x27;今年&#x27;+this.age+&#x27;岁了&#x27;) // &#125;&#125;// 父类方法Person.prototype.say = function()&#123; console.log(this.name+&#x27;的朋友&#x27;+this.friends+&#x27;今年&#x27;+this.age+&#x27;岁了&#x27;, &#x27;person&#x27;) &#125;// 子类构造函数function Student(name, age, friends, school)&#123; // 继承父类所有实例属性(获得父类构造函数中的属性) Person.call(this, name, age, friends) this.school = school // 添加新的子类属性&#125;// 继承父类的原型方法 (获得父类原型链上的属性和方法)// ES3 // Student.prototype = new Person()// ES5 Object.create()// 从本质上讲，createObject()对传入其中的对象执行了一次浅复制。// function createObject(proto) &#123;// function F() &#123; &#125;// F.prototype = proto;// return new F();// &#125;// Student.prototype = Object.create(Person.prototype)// // 设置 constructor 属性指向 Student// Student.prototype.constructor = Student// 新增子类方法Student.prototype.saySchool = function()&#123; console.log(this.name+&#x27;的朋友&#x27;+this.friends+&#x27;今年&#x27;+this.age+&#x27;岁了&#x27;, &#x27;在&#x27;+this.school+&#x27;读一年级&#x27;, &#x27;student&#x27;)&#125;var person = new Person(&#x27;小明&#x27;, 24, &#x27;小黑&#x27;);var student = new Student(&#x27;小黄&#x27;, 21, &#x27;小华&#x27;, &#x27;清华小学&#x27;)person.say();student.saySchool(); ES6实现面向对象1234567891011121314151617181920212223242526// ES6 实现方法class Person1 &#123; constructor(name, age, friends)&#123; this.name = name; this.age = age; this.friends = friends; &#125; say()&#123; console.log(this.name+&#x27;的朋友&#x27;+this.friends+&#x27;今年&#x27;+this.age+&#x27;岁了&#x27;, &#x27;person ES6&#x27;) &#125;&#125;class Student1 extends Person1 &#123; constructor(name, age, friends, school)&#123; super(name, age, friends, &#x27;Student&#x27;) this.school = school &#125; saySchool()&#123; console.log(this.name+&#x27;的朋友&#x27;+this.friends+&#x27;今年&#x27;+this.age+&#x27;岁了&#x27;, &#x27;在&#x27;+this.school+&#x27;读一年级&#x27;, &#x27;student ES6&#x27;) &#125;&#125;var person1 = new Person1(&#x27;小明&#x27;, 24, &#x27;小黑&#x27;);var student1 = new Student1(&#x27;小黄&#x27;, 21, &#x27;小华&#x27;, &#x27;清华小学&#x27;)person1.say();student1.saySchool();","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"flex之flex为1的含义","slug":"flex之flex为1的含义","date":"2020-12-30T14:06:30.000Z","updated":"2020-12-30T14:24:21.000Z","comments":true,"path":"2020/12/30/flex之flex为1的含义/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/30/flex%E4%B9%8Bflex%E4%B8%BA1%E7%9A%84%E5%90%AB%E4%B9%89/","excerpt":"","text":"一. flex是由三个属性组成:1. flex-grow: 存在剩余空间, 为正, 分配属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。在「flex」属性中该值如果被省略则默认为1. 取值：number：用数值来定义扩展比率。不允许负值 适用于：flex子项 说明：设置或检索弹性盒的扩展比率。根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间。 eg: 2. flex-shrink: 不存在剩余空间, 为负, 计算收缩比例属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 取值：number：用数值来定义收缩比率。不允许负值 适用于：flex子项 说明：设置或检索弹性盒的收缩比率。根据弹性盒子元素所设置的收缩因子作为比率来收缩空间。 3. flex-basis: 分配剩余空间前, 定义宽度属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。在「flex」属性中该值如果被省略则默认为「0%」在「flex」属性中该值如果被指定为「auto」，则伸缩基准值的计算值是自身的 &lt;’ width ‘&gt; 设置，如果自身的宽度没有定义，则长度取决于内容。 取值：length：用长度值来定义宽度。不允许负值percent：用百分比来定义宽度。不允许负值auto：无特定宽度值，取决于其它属性值content：基于内容自动计算宽度 适用于：flex子项 说明：设置或检索弹性盒伸缩基准值。如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间对应的脚本特性为flexBasis。 二. flex:说明：复合属性。设置或检索弹性盒模型对象的子元素如何分配空间。如果缩写「flex: 1」, 则其计算值为「1 1 0%」如果缩写「flex: auto」, 则其计算值为「1 1 auto」如果「flex: none」, 则其计算值为「0 0 auto」如果「flex: 0 auto」或者「flex: initial」, 则其计算值为「0 1 auto」，即「flex」初始值 flex属性默认是0 1 autoflex-grow为0，则存在剩余空间也不放大flex-shrink为1，则空间不足该项目缩小flex-basis为auto，则该项目本来的大小 eg1: 页面设计中用到了flex:1, 具体什么意思呢, 说说我自己的理解. 解析: flex-grow:1; 有剩余空间, 分配 flex-shrink:1; 没有剩余空间, 收缩 flex-basis:0%; 没有基础宽度","categories":[],"tags":[{"name":"flex","slug":"flex","permalink":"https://perfectsymphony.github.io/tags/flex/"}]},{"title":"Vue子组件调用父组件的三种方法","slug":"Vue子组件调用父组件的三种方法","date":"2020-12-30T07:09:00.000Z","updated":"2020-12-30T07:13:11.000Z","comments":true,"path":"2020/12/30/Vue子组件调用父组件的三种方法/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/30/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法父组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from &#x27;~/components/dam/child&#x27;; export default &#123; components: &#123; child &#125;, methods: &#123; fatherMethod() &#123; console.log(&#x27;测试&#x27;); &#125; &#125; &#125;;&lt;/script&gt; 子组件 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;childMethod()&quot;&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; childMethod() &#123; this.$parent.fatherMethod(); &#125; &#125; &#125;;&lt;/script&gt; 第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了父组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;child @fatherMethod=&quot;fatherMethod&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from &#x27;~/components/dam/child&#x27;; export default &#123; components: &#123; child &#125;, methods: &#123; fatherMethod() &#123; console.log(&#x27;测试&#x27;); &#125; &#125; &#125;;&lt;/script&gt; 子组件 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;childMethod()&quot;&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; childMethod() &#123; this.$emit(&#x27;fatherMethod&#x27;); &#125; &#125; &#125;;&lt;/script&gt; 第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法父组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;child :fatherMethod=&quot;fatherMethod&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from &#x27;~/components/dam/child&#x27;; export default &#123; components: &#123; child &#125;, methods: &#123; fatherMethod() &#123; console.log(&#x27;测试&#x27;); &#125; &#125; &#125;;&lt;/script&gt; 子组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;childMethod()&quot;&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; fatherMethod: &#123; type: Function, default: null &#125; &#125;, methods: &#123; childMethod() &#123; if (this.fatherMethod) &#123; this.fatherMethod(); &#125; &#125; &#125; &#125;;&lt;/script&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"CSS命名规范——BEM思想","slug":"CSS命名规范——BEM思想","date":"2020-12-29T08:39:09.000Z","updated":"2020-12-29T08:53:49.000Z","comments":true,"path":"2020/12/29/CSS命名规范——BEM思想/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/29/CSS%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E2%80%94%E2%80%94BEM%E6%80%9D%E6%83%B3/","excerpt":"","text":"人们问我最多的问题之一是在CSS类名中“–”和“__”是什么意思？它们的出现是源于BEM和Nicolas Gallagher… BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。 重要的是要注意，我使用的基于BEM的命名方式是经过Nicolas Gallagher修改过的。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。 命名约定的模式如下： 123.block&#123;&#125;.block__element&#123;&#125;.block--modifier&#123;&#125; block 代表了更高级别的抽象或组件。 block__element 代表.block的后代，用于形成一个完整的.block的整体。 block–modifier代表.block的不同状态或不同版本。 之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定，如： 123.site-search&#123;&#125; /* 块 */.site-search__field&#123;&#125; /* 元素 */.site-search--full&#123;&#125; /* 修饰符 */ BEM的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素,还有一些是组件的其他形态或者是修饰符。我们用一个类比/模型来思考一下下面的这些元素是怎么关联的： 12345.person&#123;&#125;.person__hand&#123;&#125;.person--female&#123;&#125;.person--female__hand&#123;&#125;.person__hand--left&#123;&#125; 顶级块是‘person’，它拥有一些元素，如‘hand’。一个人也会有其他形态，比如女性，这种形态进而也会拥有它自己的元素。下面我们把他们写成‘常规’CSS: 12345.person&#123;&#125;.hand&#123;&#125;.female&#123;&#125;.female-hand&#123;&#125;.left-hand&#123;&#125; 这些‘常规’CSS都是有意义的，但是它们之间却有些脱节。就拿.female来说，是指女性人类还是某种雌性的动物？还有.hand，是在说一只钟表的指针（译注：英文中hand有指针的意思）？还是一只正在玩纸牌的手？使用BEM我们可以获得更多的描述和更加清晰的结构，单单通过我们代码中的命名就能知道元素之间的关联。BEM真是强大。 再来看一个之前用‘常规’方式命名的.site-search的例子： 12345&lt;form class=&quot;site-search full&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;field&quot;&gt; &lt;input type=&quot;Submit&quot; value =&quot;Search&quot; class=&quot;button&quot;&gt;&lt;/form&gt; 这些CSS类名真是太不精确了，并不能告诉我们足够的信息。尽管我们可以用它们来完成工作，但它们确实非常含糊不清。用BEM记号法就会是下面这个样子： 12345&lt;form class=&quot;site-search site-search--full&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;site-search__field&quot;&gt; &lt;input type=&quot;Submit&quot; value =&quot;Search&quot; class=&quot;site-search__button&quot;&gt;&lt;/form&gt; 我们能清晰地看到有个叫.site-search的块，他内部是一个叫.site-search__field的元素。并且.site-search还有另外一种形态叫.site-search–full。 我们再来举个例子…… 如果你熟悉OOCSS（面向对象CSS），那么你对media对象一定也不陌生。用BEM的方式，media对象就会是下面这个样子： 1234.media&#123;&#125;.media__img&#123;&#125;.media__img--rev&#123;&#125;.media__body&#123;&#125; 从这种CSS的写法上我们就已经知道.media__img 和.media__body一定是位于.media内部的，而且.media__img–rev是.media__img的另一种形态。仅仅通过CSS选择器的名字我们就能获取到以上全部信息。 BEM的另外一个好处是针对下面这种情况： 1234567&lt;div class=&quot;media&quot;&gt; &lt;img src=&quot;logo.png&quot; alt=&quot;Foo Corp logo&quot; class=&quot;img-rev&quot;&gt; &lt;div class=&quot;body&quot;&gt; &lt;h3 class=&quot;alpha&quot;&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=&quot;lede&quot;&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 光从上面的代码来看，我们根本不明白.media和.alpha两个class彼此之间是如何相互关联的？同样我们也无从知晓.body和.lede之间，或者.img-rev 和.media之间各是什么关系？从这段HTML（除非你对那个media对象非常了解）中我们也不知道这个组件是由什么组成的和它还有什么其他的形态。如果我们用BEM方式重写这段代码： 1234567&lt;div class=&quot;media&quot;&gt; &lt;img src=&quot;logo.png&quot; alt=&quot;Foo Corp logo&quot; class=&quot;media__img--rev&quot;&gt; &lt;div class=&quot;media__body&quot;&gt; &lt;h3 class=&quot;alpha&quot;&gt;Welcome to Foo Corp&lt;/h3&gt; &lt;p class=&quot;lede&quot;&gt;Foo Corp is the best, seriously!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 我们立马就能明白.media是一个块，.media__img–rev是一个加了修饰符的.media__img的变体，它是属于.media的元素。而.media__body是一个尚未被改变过的也是属于.media的元素。所有以上这些信息都通过它们的class名称就能明白，由此看来BEM确实非常实用。 丑极了！通常人们会认为BEM这种写法难看。我敢说，如果你仅仅是因为这种代码看上去不怎么好看而羞于使用它，那么你将错失最重要的东西。除非使用BEM让代码增加了不必要的维护困难，或者这么做确实让代码更难读了，那么你在使用它之前就要三思而行了。但是，如果只是“看起来有点怪”而事实上是一种有效的手段，那么我们在开发之前当然应该充分考虑它。 是，BEM看上去确实怪怪的，但是它的好处远远超过它外观上的那点瑕疵。 BEM可能看上去有点滑稽，而且有可能导致我们输入更长的文本（大部分编辑器都有自动补全功能，而且gzip压缩将会让我们消除对文件体积的担忧），但是它依旧强大。 用还是不用BEM?我在我的所有项目中都使用了BEM记号法，因为它的有效性已经被它自己一次又一次地证明。我也极力地建议别人使用BEM，因为它让所有东西之间的联系变得更加紧密，让团队甚至是你个人都能够更加容易地维护代码。 然而，当你真正使用BEM的时候，重要的是，请记住你没必要真的在每个地方都用上它。比如： 1.caps&#123; text-transform:uppercase; &#125; 这条CSS不属于任何一个BEM范畴，它仅仅只是一条单独的样式。 另一个没有使用BEM的例子是： 1.site-logo&#123;&#125; 这是一个logo，我们可以把它写成BEM格式，像下面这样： 12.header&#123;&#125;.header__logo&#123;&#125; 但我们没必要这么做。使用BEM的诀窍是，你要知道什么时候哪些东西是应该写成BEM格式的。因为某些东西确实是位于一个块的内部，但这并不意味它就是BEM中所说的元素。这个例子中，网站logo完全是恰巧在.header的内部，它也有可能在侧边栏或是页脚里面。一个元素的范围可能开始于任何上下文，因此你要确定只在你需要用到BEM的地方你才使用它。再看一个例子： 123&lt;div class=&quot;content&quot;&gt; &lt;h1 class=&quot;content__headline&quot;&gt;Lorem ipsum dolor...&lt;/h1&gt;&lt;/div&gt; 在这个例子里，我们也许仅仅只需要另一个class，可以叫它.headline；它的样式取决于它是如何被层叠的，因为它在.content的内部；或者它只是恰巧在.content的内部。如果它是后者（即恰巧在.content的内部，而不总是在）我们就不需要使用BEM。 然而，一切都有可能潜在地用到BEM。我们再来看一下.site-logo的例子，想象一下我们想要给网站增加一点圣诞节的气氛，所以我们想有一个圣诞版的logo。于是我们有了下面的代码： 12.site-logo&#123;&#125;.site-logo--xmas&#123;&#125; 我们可以通过使用–修饰符来快速地为我们的代码构建另一个版本。 BEM最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。随着接触的多了，有了经验积累，你慢慢就会知道怎么用，这些问题也不再是问题。 结束语所以，BEM（或BEM的变体）是一个非常有用，强大，简单的命名约定，以至于让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确而且更加严密。 尽管BEM看上去多少有点奇怪，但是无论什么项目，它对前端开发者都是一个巨有价值的工具。 如需转载烦请注明出处： 英文原文：http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/ 中文译文：http://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"深入理解css之line-height","slug":"深入理解css之line-height","date":"2020-12-29T07:46:18.000Z","updated":"2020-12-29T13:15:49.000Z","comments":true,"path":"2020/12/29/深入理解css之line-height/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css%E4%B9%8Bline-height/","excerpt":"","text":"前言行高，顾名思义是一行文字的高度，而从规范上来说则是两行文字基线之间的距离。行高是作用在每一个行框盒子(line-box)上的，而行框盒子则是由内联盒子组成，因此，行高与内联元素可以说是非常紧密，行高直接决定了内联元素的高度（注意：这里的内联元素不包括替换元素）；对于块级元素和替换元素，行高是无法决定最终高度的，只能决定行框盒子的最小高度。 x、x-height以及ex字母x在css里面扮演着一个很重要的角色，因为字母x的下边缘就是基线所在的位置。而x-height指的就是字母x的高度，ex是一个尺寸单位，其大小是相对字母x的来计算的，即1ex就表示1个字母x的高度。如下图所示： 我们在平时的开发中很少用到ex，因为ex是个相对单位。对于相对的东西，我们总是感觉很难控制，但这并不表明ex就一点用处都没有。我们可以利用ex就是一个x-height的特性来实现图标与文字的垂直居中，这样如论字体大小如何变化，都不会影响垂直居中的效果。代码如下： 1234567.icon-arrow &#123; display: inline-block; width: 20px; height: 1ex; background: url(down.png) no-repeat center; background-size: contain;&#125; 1234&lt;div&gt; &lt;span&gt;我是一段文本&lt;/span&gt; &lt;i class=&quot;icon-arrow&quot;&gt;&lt;/i&gt;&lt;/div&gt; 效果如下： line-height的属性值 normal 数字 长度 百分比normalnormal为line-height的默认值，但并不是一个固定的值，而是会受font-family的影响，对于“微软雅黑”，其值为1.32；而对于“宋体”，其值为1.141。由于不同操作系统，不同浏览器所使用的字体不一样，所以最终line-height的具体值会不一样，因此这个属性作用不大。 数字我们可以设置line-height: 1.5。其意思是说line-height的最终大小为 1.5* font-size，一般建议使用该值来设置line-height。 长度长度用的最多的就是px与em，em跟数字一样，都是相对于font-size来计算的。 百分比百分比也是相对于font-size来计算的。 相信细心的小伙伴已经发现了，数字，em以及百分比都是相对于font-size来计算的，既然这样，为什么还要多此一举设置另外两个属性呢。原因就在于它们的继承方式是不一样的。对于数字，父元素设置了1.5，则子元素也是会继承1.5。但如果父元素设置的是1.5em，假设父元素font-size是20px，则父元素line-height是30px，同时子元素的line-height也是30px，也就是说子元素继承的是父元素计算后的line-height值。因此，这也是为什么上面推荐使用数字而不是em或百分比的原因了。 行距与半行距很多开发人员开还原设计图的时候，往往没有考虑到行距的影响，因此开发出来的页面很多时候都与设计图不符合，总会差那么几个像素。那么什么是行距呢，我们可以想象一下在文字排版的时候，如果行与行之间的间距为0，则文字是会紧紧贴在一起的，因此，行距就是用来协助排版的。行距的计算为：line-height - em-box，em-box指的是1em的大小，因此行距可以表示为：line-height - font-size，假设line-height为1.5，font-size为20，则行距为：1.5*20 - 20 = 10，则最终行距为10，而这个行距会平均作用于文字的上边和下边。但em-box我们是无法感知这个盒子在哪的，而内容区域我们则可以理解为我们选中文字后的背景色所在区域，而当字体是宋体的时候，内容区域和em-box是等高的，因此我们可以利用此揪出ex-box的藏身之处。如下图所示： 正是因为行距的存在，我们给元素设置margin值时，要减去相应的半行距值，这样才能比较精确地还原设计图。 line-height的应用大部分时候，我们设置line-height，都是为了垂直居中对齐。但这里的居中，只能说是近似居中，从上面的图可以看出：行距是上下均分的，但是内容区域不是，一般来说，文字都是偏下的。我们平时设置字体一般都是12-20像素，这么小的像素值，给出line-height值后，由于上下相差不大，因此感觉上是垂直居中的。line-height除了可以作为单行文本的居中对齐外，多行文本也是可以的，代码如下： 12345678910111213.box &#123; width: 400px; line-height: 400px; padding: 0 10px; border: 1px solid #ccc;&#125;.text &#123; display: inline-block; line-height: 1.3; font-size: 14px; vertical-align: middle;&#125; 123&lt;p class=&quot;box&quot;&gt; &lt;span class=&quot;text&quot;&gt;这是一段很长很长的文字，这是一段很长很长的文字，这是一段很长很长的文字，这是一段很长很长的文字，这是一段很长很长的文字&lt;/span&gt;&lt;/p&gt; 效果如下： 前面的文章有说过，每一个行框盒子前面都有一个看不见的，规范称之为“strut”的东西。我们给.box设置了line-height为400px，则这个“strut”的line-height也会继承为400px。然后我们给.text设置inline-block，这样我们就可以重置.box设置的line-height，又因为ineline-block保持了内联特性，因此我们可以设置vertical-align以及产生“strut”，从而实现近似垂直居中对齐。 总结 介绍了字母x在css中的地位以及ex的应用 line-height各种不同的属性值以及数字、em和百分比的不同之处 行距在line-height的作用 line-height实现单行垂直居中和多行垂直居中","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"深入理解css之vertical-align","slug":"深入理解css之vertical-align","date":"2020-12-29T07:24:28.000Z","updated":"2020-12-29T08:32:58.000Z","comments":true,"path":"2020/12/29/深入理解css之vertical-align/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css%E4%B9%8Bvertical-align/","excerpt":"","text":"前言vertical-align用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。也就是说，对于块级元素，vertical-align是不起作用的。 vertical-align的各类属性值vertical-align的属性值可以归为以下4类： 线类，如 baseline、top、middle、bottom； 文本类，如 text-top、text-bottom； 上标下标类，如 sub、super； 数值百分比类，如 10px、1em、5%； 线类baseline，baseline为vertical-align的默认值，其意思是指基线对齐，所谓基线，指的是字母x的下边缘，具体可看深入理解css之line-height有讲解到，不懂的小伙伴建议先看看这篇文章。我们来看个例子，代码如下： 12345.box &#123; width: 100px; line-height: 100px; border: 1px solid #ccc;&#125; 123&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;text&quot;&gt;文本&lt;/span&gt;&lt;/div&gt; 效果如下： 由于baseline是默认值，所以可以不用写。.box的line-height为100px，这其实是给“strut”设置的（不懂strut概念的可以看看深入理解css盒子模型，简单点说就是每一个行框盒子都有一个看不见的节点，该节点继承了line-height），因此.text对齐于该节点的基线（可以想象成这个看不见的节点有一个字母x，而.text就是跟这个字母x的下边缘对齐） 关于baseline，有一个需要注意的地方就是inline-block元素，如果一个inline-block元素，里面没有内联元素，或者overflow不是visible，则该元素的基线是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。例子如下： 123456.text &#123; display: inline-block; width: 100px; height: 100px; border: 1px solid #ccc;&#125; 1234&lt;div class=&quot;container&quot;&gt; &lt;span class=&quot;text&quot;&gt;文本&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;&lt;/span&gt;&lt;/div&gt; 效果如下： top，对于内联元素，指的是元素的顶部和当前行框盒子的顶部对齐；对于table-cell元素，指的是元素的顶padding边缘和表格行的顶部对齐。例子如下： 123456789.box &#123; width: 100px; line-height: 100px; border: 1px solid #ccc;&#125;.top &#123; line-height: normal; vertical-align: top;&#125; 123&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;top&quot;&gt;文本&lt;/span&gt;&lt;/div&gt; 效果如下： bottom，跟top类似，将顶部换成底部即可。 middle，这个属性值用得比较多。对于内联元素指的是元素的垂直中心点与行框盒子基线往上1/2x-height处对齐，简单点说就是字母x的中心位置对齐；对于table-cell元素，指的是单元格填充盒子相对于外面的表格行居中对齐。基本上所有字体中，字母x的位置都是偏下一点的，font-size越大偏移越明显，因此，字母x中心的位置不是行框盒子的中心，也就是说vertical-align只能实现近似垂直居中对齐。 文本类text-top，指的是盒子的顶部和父级内容区域的顶部对齐。 text-bottom，指的是盒子的底部和父级内容区域的底部对齐。 例子如下： 1234567891011121314151617181920.box &#123; width: 300px; line-height: 100px; border: 1px solid #ccc; font-size: 20px;&#125;.f12 &#123; font-size: 12px;&#125;.f16 &#123; font-size: 16px;&#125;.f20 &#123; font-size: 20px;&#125;.text-top &#123; line-height: normal; vertical-align: text-top; width: 100px;&#125; 123456&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;f12&quot;&gt;12px&lt;/span&gt; &lt;span class=&quot;f16&quot;&gt;16px&lt;/span&gt; &lt;span class=&quot;f20&quot;&gt;20px&lt;/span&gt; &lt;img class=&quot;text-top&quot; src=&quot;./card.jpg&quot;/&gt;&lt;/div&gt; 效果如下： 所谓内容区域，可以看成是鼠标选中文字后高亮的背景色区域，上面的例子中，由于父元素设置的是20px，所以图片的vertical-align设置text-top的时候，就可以看成是跟子元素为20px元素的内容区域顶部对齐。 上标下标类上标和下标对应着两个标签super和sub，super在上面，sub在下面，这两个属性值在数学公式和化学表达式中用得比较多，平时我们开发几乎用不到，也没啥好讲的。 数值百分比类vertical-align是支持数值的，并且兼容性也非常好，但大部分开发人员却不知道vertical-align支持数值。对于数值，正值表示由基线往上偏移，负值表示由基线往下偏移。而百分比则是基于line-height来计算的，百分比用得比较少，因为line-height一般都是开发人员给出的，这时候数值就可以精确定位元素，不需要再使用百分比再去计算一遍。使用数值的代码如下： 12345678910.box &#123; width: 300px; line-height: 100px; border: 1px solid #ccc; font-size: 20px;&#125;.num &#123; line-height: normal; vertical-align: 20px;&#125; 123&lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;num&quot;&gt;文本&lt;/span&gt;&lt;/div&gt; 效果如下： vertical-align起作用的前提vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。在css中，有些css属性是会改变元素的display值的，例如float和position: absolute，一旦设置了这两个属性之一，元素的display值就是变为block，因此，vertical-align也就失去了作用。下面这段代码这样写就是错的： 1234span &#123; float: left; vertical-align: middle; /* 错误，该行代码无效 */&#125; 另外，更多人遇到的是以下这种无效的情况： 1234567.box &#123; height: 200px;&#125;.box &gt; img &#123; height: 100px; vertical-align: middle;&#125; 123&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;1.jpg&quot; /&gt;&lt;/div&gt; 其实，不是vertical-align无效，而是前面所说的“strut”的影响，由于.box没有设置line-height，所以“strut”的line-height就非常小，比图片的高度小很多，vertical-align: middle没法发挥作用。这时给.box一个比较高的line-height，就会看到vertical-align起作用了： 1234.box &#123; height: 200px; line-height: 200px;&#125; vertical-align与line-height的关系前面讲了，vertical-align的百分比值是根据line-height来计算的。但实质上，只要是内联元素，这两个元素都会同时在起作用。如下例子： 123456.box &#123; line-height: 32px;&#125;.box &gt; span &#123; font-size: 24px;&#125; 123&lt;div class=&quot;box&quot;&gt; &lt;span&gt;文本&lt;/span&gt;&lt;/div&gt; 从代码上看，好像.box的高度会是32px，但实质上.box的高度会比32px还要高。原因是”strut”继承了line-height: 32px，span也继承了line-height: 32px，但两者的font-size不一样，这就导致了”strut”的font-size比较小，而span的font-size比较大，也就是说它们的基线不在同一位置上，”strut”偏上一点，而span默认又是基线对齐，为此，span总体会往上移以便跟”strut”基线对齐，.box元素就是这样被撑高了。而解决方案可以有以下几种： span元素不使用基线对齐，可以改为top对齐 span元素块状化 line-height设置为0 font-size设置为0 总结 讲解了vertical-align的各类属性值及其效果 vertical-align起作用的前提是内联元素 vertical-align与line-height都是同时作用在内联元素上的","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"jsonp原理","slug":"jsonp原理","date":"2020-12-16T12:50:25.000Z","updated":"2020-12-23T07:48:29.000Z","comments":true,"path":"2020/12/16/jsonp原理/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/16/jsonp%E5%8E%9F%E7%90%86/","excerpt":"","text":"在学习jsonp之前首先要明白以下几点：首先确定为什么要用jsonp，因为要跨域请求数据，那为什么会发生跨域呢， 因为浏览器的同源策略，那什么是同源策略呢浏览器从A网站向B网站请求资源，必须同时满足三点才可以，协议，域名，端口相同，任何一点不同都会产生跨域，产生跨域后，浏览器就会阻止数据返回。 人们为了满足在不同的域名间传递数据，发明了jsonp技术： 在学习jsonp之前，大家可以思考一下，一张网页中哪些标签是可以跨域请求资源的，我们知道，在页面上有三种资源是可以与页面本身不同源的。它们是：js脚本，css样式文件，图片： 1） 2） 3） 以上三种资源是可以发生跨域后，而资源可以返回的； 而jsonp就是利用了&lt;script&gt;标签可以链接到不同源的js脚本来到达跨域目的。当链接的资源到达浏览器时，浏览器会根据他们的类型来采取不同的处理方式，比如，如果是css文件，则会进行对页面 repaint，如果是img 则会将图片渲染出来，如果是script 脚本，则会进行执行，比如我们在页面引入了jquery库，为什么就可以使用 $ 了呢？就是因为 jquery 库被浏览器执行之后，会给全局对象window增加一个属性： $ ，所以我们才能使用 $ 来进行各种处理。 重点：浏览器会根据他们的类型采用不同的处理方式，js文件则会执行。 通常一般我们利用ajax请求某些接口返回的数据，基本都是json格式，而jsonp请求返回的数据，是什么呢，咱们来看一条完整的jsop请求和其返回的数据： 前端工程师通过callback向后端传递了一个abc字符串，后端呢将数据包裹在 abc（）中返回， 签名提到过了，浏览器会根据不同的文件类型进行不同的处理，咱们利用的是javascript，所以返回的数据会被解析为，js文件，而上面的数据如果被解析为js文件，就会被执行； 这就是 jsonp 的基本原理，利用script标签的特性，将数据使用json格式用一个函数包裹起来，然后在进行访问的页面中定义一个相同函数名的函数，因为 script 标签src引用的js脚本到达浏览器时会执行，而我们已经定义了一个同名的函数，所以json格式的数据，就作为参数传递给了我们定义的同名函数了。这样就完成了跨域数据交换。jsonp的含义是：json with padding，而在json数据外包裹它的那个函数。附上封装的jsop的代码： 以上便是利用jquery的风格封装得到jsonp函数， 在和第三方接口调用或者和后端工程师交互式，一定要实现沟通好，向后端传递参数名时，用的什么参数，jquery默认用的是callback， 举个例子： 百度的jsonp用的是 百度用的是cb传递的； 现在咱们看一看上面封装的代码： 有一句非常关键，就是在window上通过变量挂载了一个Cname的属性，而这个属性是个变量， 变量值为一个很长的字符串，而cname这个属性是一个函数，这个函数就是，jsonp返回函数调用后，调用的函数。","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://perfectsymphony.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"揭秘简单请求和复杂请求","slug":"揭秘简单请求和复杂请求","date":"2020-12-15T06:41:00.000Z","updated":"2020-12-15T09:48:54.000Z","comments":true,"path":"2020/12/15/揭秘简单请求和复杂请求/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/15/%E6%8F%AD%E7%A7%98%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/","excerpt":"","text":"开发网站时经常会用到跨域资源共享（简称cors，后面使用简称）来解决跨域问题，但是在使用cors的时候，http请求会被划分为两类，简单请求和复杂请求，而这两种请求的区别主要在于是否会触发cors预检请求。 首先我们要明白cors的原理（引自MDN）： 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据） 从上面的文字中我们得到如下信息： 1、跨域资源共享标准新增了一组 HTTP 首部字段，服务器通过这些字段来控制浏览器有权访问哪些资源。 2、为了安全起见请求方式分为两类，一类不会预先发送options请求，一些会预先发送options请求。 3、 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求会触发options请求。 4、服务器验证OPTIONS完成后才会允许发送实际的http请求。 不会触发http预检请求的便是简单请求，能够触发http预检请求的便是复杂请求。 那么有哪些简单请求呢？以下是来自MDN官方引用： 1、使用下列方法之一： GET、 POST、 HEAD。 2、不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type 3、Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 4、请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问 5、请求中没有使用 ReadableStream 对象 那什么是复杂请求呢，除了简单请求都是复杂请求。 简单请求的发送从代码上来看和普通的XHR没太大区别，但是HTTP头当中要求总是包含一个域（Origin）的信息。该域包含协议名、地址以及一个可选的端口。不过这一项实际上由浏览器代为发送，并不是开发者代码可以触及到的。 简单请求的部分响应头及解释如下： Access-Control-Allow-Origin（必含）- 不可省略，否则请求按失败处理。该项控制数据的可见范围，如果希望数据对任何人都可见，可以填写”*”。Access-Control-Allow-Credentials（可选） – 该项标志着请求当中是否包含cookies信息，只有一个可选值：true（必为小写）。如果不包含cookies，请略去该项，而不是填写false。这一项与XmlHttpRequest2对象当中的withCredentials属性应保持一致，即withCredentials为true时该项也为true；withCredentials为false时，省略该项不写。反之则导致请求失败。Access-Control-Expose-Headers（可选） – 该项确定XmlHttpRequest2对象当中getResponseHeader()方法所能获得的额外信息。通常情况下，getResponseHeader()方法只能获得如下的信息：Cache-ControlContent-LanguageContent-TypeExpiresLast-ModifiedPragma当你需要访问额外的信息时，就需要在这一项当中填写并以逗号进行分隔 如果仅仅是简单请求，那么即便不用CORS也没有什么大不了，但CORS的复杂请求就令CORS显得更加有用了。简单来说，任何不满足上述简单请求要求的请求，都属于复杂请求。比如说你需要发送PUT、DELETE等HTTP动作，或者发送Content-Type: application/json的内容。 复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种”预请求”，此时作为服务端，也需要返回”预回应”作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。 预请求以OPTIONS形式发送，当中同样包含域，并且还包含了两项CORS特有的内容 Access-Control-Request-Method – 该项内容是实际请求的种类，可以是GET、POST之类的简单请求，也可以是PUT、DELETE等等。Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。 显而易见，这个预请求实际上就是在为之后的实际请求发送一个权限请求，在预回应返回的内容当中，服务端应当对这两项进行回复，以让浏览器确定请求是否能够成功完成。 复杂请求的部分响应头及解释如下： Access-Control-Allow-Origin（必含） – 和简单请求一样的，必须包含一个域。Access-Control-Allow-Methods（必含） – 这是对预请求当中Access-Control-Request-Method的回复，这一回复将是一个以逗号分隔的列表。尽管客户端或许只请求某一方法，但服务端仍然可以返回所有允许的方法，以便客户端将其缓存。Access-Control-Allow-Headers（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。这里在实际使用中有遇到，所有支持的头部一时可能不能完全写出来，而又不想在这一层做过多的判断，没关系，事实上通过request的header可以直接取到Access-Control-Request-Headers，直接把对应的value设置到Access-Control-Allow-Headers即可。Access-Control-Allow-Credentials（可选） – 和简单请求当中作用相同Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。 理论聊完之后，咱们来看一下实践，首先启动两个服务，一个端口为3000,的静态资源服务器，用于请求接口，另一台端口为5000的接口服务器，如图所示： 后端接口服务器代码如下： 12345678910111213141516171819202122const express = require(&quot;express&quot;);const app = express();const bodyParser = require(&#x27;body-parser&#x27;);app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(bodyParser.json());// 实现CORSapp.use(function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;OPTIONS,GET,POST,PUT,DELETE&#x27;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin,X-Requested-With,Content-Type,Accept,Authorization&quot;); res.header(&quot;cache-control&quot;, &quot;no-cache&quot;); res.header(&quot;content-type&quot;, &quot;application/json; charset=utf-8&quot;); res.header(&quot;ETag&quot;, &#x27;&#x27;); next();&#125;);app.post(&quot;/p&quot;,(req,res)=&gt;&#123; res.send(req.body)&#125;)app.listen(5000,()=&gt;&#123; console.log(&quot;5000&quot;)&#125;) 前端请求资源脚本代码如下： 123axios.post(&quot;http://localhost:5000/p&quot;,&#123;name:&quot;zs&quot;,age:&quot;18&quot;&#125;).then((data)=&gt;&#123; console.log(data.data);&#125;) 我们用axios这个http请求库发送了一个post请求，axios发送post请求默认会把数据转化为json格式，并且会默认设置请求头：Content-Type：application/json，很显然这是一个复杂请求，这样的话，会触发options请求。 我们分别启动两个服务，并打开浏览器，访问页面，加载请求接口脚本，观察network如图： 我们看到，代码中命名只发送了一次异步请求为什么显示两次呢？详细截图如下： 我们看到确实发送了两次请求一次为OPTIONS一次为POST，而我们代码中并没有处理对OPTIONS请求的响应处理，所以上面服务端代码是不合理的，综合考虑，OPTIONS请求并会对实际http请求差生影响，所以我们统一的对OPTIONS请求返回204，服务端负责支持CORS的中间件修正代码如下： 123456789101112131415app.use(function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;OPTIONS,GET,POST,PUT,DELETE&#x27;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin,X-Requested-With,Content-Type,Accept,Authorization&quot;); res.header(&quot;cache-control&quot;, &quot;no-cache&quot;); res.header(&quot;content-type&quot;, &quot;application/json; charset=utf-8&quot;); res.header(&quot;ETag&quot;, &#x27;&#x27;); //header头信息设置结束后，结束程序往下执行，返回 if(req.method.toLocaleLowerCase() === &#x27;options&#x27;)&#123; res.status(204); return res.json(&#123;&#125;); //直接返回空数据，结束此次请求 &#125;else&#123; next(); &#125;&#125;); 我们在中间件中判断请求方式，如果请求方式为OPTIONS返回状态码204,并返回空信息。 限于篇幅文章到此就该结束了，当然了还有好多文档没有测试希望大家看完文章亲手测试一下。 如果我们将请求脚本改成如下代码： 12345axios.post(&quot;http://localhost:5000/p&quot;,&quot;name=zs&amp;age=18&quot;,&#123;headers:&#123; &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;,&#125;&#125;).then((data)=&gt;&#123; console.log(data.data);&#125;) 或者又改成如下代码： 123456axios.post(&quot;http://localhost:5000/p&quot;,&quot;name=zs&amp;age=18&quot;,&#123;headers:&#123; &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;, &quot;clm&quot;:&quot;234&quot;&#125;&#125;).then((data)=&gt;&#123; console.log(data.data);&#125;) 以上两次请求的netmork会是什么样的呢？","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://perfectsymphony.github.io/tags/http/"}]},{"title":"git stash的用法总结","slug":"stash的用法总结","date":"2020-12-13T16:46:08.000Z","updated":"2020-12-18T03:55:17.000Z","comments":true,"path":"2020/12/14/stash的用法总结/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/14/stash%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"储藏（Stashing）经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。 “‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。 储藏你的工作假如你正在一个分支上做开发任务，现在你想切换到另外一个分支上去做一些工作，比如修改bug、继续之前的工作等等。但是，你现在还不想提交你正在进行的工作，所以你可以储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 git stash： 12345$ git stashSaved working directory and index state \\ &quot;WIP on master: 049d078 added the index file&quot;HEAD is now at 049d078 added the index file(To restore them type &quot;git stash apply&quot;) 这样你的工作目录就干净了 123$ git status# On branch masternothing to commit, working directory clean 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 git stash list： 1234$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log 在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。你可以重新应用你刚刚实施的储藏，所采用的命令就是之前在原始的 stash 命令的帮助输出里提示的：git stash apply。如果你想应用更早的储藏，你可以通过名字指定它，像这样：git stash apply stash@&#123;2&#125;。如果你不指明，Git 默认使用最近的储藏并尝试应用它： 12345678$ git stash apply# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)## modified: index.html# modified: lib/simplegit.rb 你可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。 对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。想那样的话，你必须在运行 git stash apply 命令时带上一个 --index 的选项来告诉命令重新应用被暂存的变更。如果你是这么做的，你应该已经回到你原来的位置： 123456789101112$ git stash apply --index# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: index.html## Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)## modified: lib/simplegit.rb apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 git stash drop，加上你希望移除的储藏的名字： 123456$ git stash liststash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log$ git stash drop stash@&#123;0&#125;Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43) 你也可以运行git stash pop来重新应用储藏，同时立刻将其从堆栈中移走。 取消储藏(Un-applying a Stash)在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果： 1$ git stash show -p stash@&#123;0&#125; | git apply -R 同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏： 1$ git stash show -p | git apply -R 你可能会想要新建一个別名，在你的 Git 里增加一个 stash-unapply 命令，这样更有效率。例如： 1234$ git config --global alias.stash-unapply &#x27;!git stash show -p | git apply -R&#x27;$ git stash apply$ #... work work work$ git stash-unapply 从储藏中创建分支如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。 1234567891011121314$ git stash branch testchangesSwitched to a new branch &quot;testchanges&quot;# On branch testchanges# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: index.html## Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)## modified: lib/simplegit.rb#Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359) 这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。 git stash 暂存部分文件1git stash 什么参数不加，会分别对暂存区(没有add的)和工作区(add之后的)的状态进行保存。 1git stash save &quot;message&quot; save可以添加保存时的备注。示例:git stash save “完成user接口” 1git stash -k 或–keep-index只备份没有add的文件。示例git stash save --keep-index &quot;部分文件&quot; git stash使用技巧常规 git stash 的一个限制是它会一下暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来备份部分文件： add 那些你不想备份的文件（例如： git add file1.js, file2.js） 调用 git stash –keep-index。只会备份那些没有被add的文件。 调用 git reset 取消已经add的文件的备份，继续自己的工作。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://perfectsymphony.github.io/tags/Git/"}]},{"title":"JavaScript的深拷贝与浅拷贝","slug":"JavaScript的深拷贝与浅拷贝","date":"2020-12-06T16:54:12.000Z","updated":"2020-12-06T17:14:14.000Z","comments":true,"path":"2020/12/07/JavaScript的深拷贝与浅拷贝/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/07/JavaScript%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"一、预备知识1.1、JS数据类型基本数据类型：Boolean、String、Number、null、undefined引用数据类型：Object、Array、Function、RegExp、Date等 1.2、数据类型的复制基本数据类型的复制，是按值传递的 12345var a = 1;var b = a;b = 2;console.log(a); // 1console.lob(b); // 2 引用数据类型的复制，是按引用传值 12345678var obj1 = &#123; a: 1; b: 2;&#125;;var obj2 = obj1;obj2.a=3;console.log(obj1.a); //3console.log(obj2.a); // 3 1.3、深拷贝与浅拷贝深拷贝和浅拷贝都只针对引用数据类型，浅拷贝会对对象逐个成员依次拷贝，但只复制内存地址，而不复制对象本身，新旧对象成员还是共享同一内存；深拷贝会另外创建一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 区别：浅拷贝只复制对象的第一层属性，而深拷贝会对对象的属性进行递归复制。 二、JS浅拷贝2.1、赋值与浅拷贝当把一个对象赋值给一个新的变量时，赋的对象是该对象在栈中的地址，而不是堆中的数据。也就是新旧两个对象指的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，两个对象联动的会一起改变。 123456789var obj1 = &#123; &#x27;name&#x27; : &#x27;zhangsan&#x27;, &#x27;language&#x27; : [1,[2,3],[4,5]],&#125;;var obj2 = obj1;obj2.name = &quot;lisi&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];console.log(&#x27;obj1&#x27;,obj1)console.log(&#x27;obj2&#x27;,obj2) 浅拷贝是按位拷贝对象，它会创建一个新对象，对原有对象的成员进行依次拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。因此如果新对象中的某个对象成员改变了地址，就会影响到原有的对象。 1234567891011121314151617//手写浅拷贝function shallowCopy(obj1) &#123; let obj2 = Array.isArray(obj1) ? [] : &#123;&#125; for (let i in obj1) &#123; obj2[i] = obj1[i] &#125; return obj2&#125;var obj1 = &#123; &#x27;name&#x27; : &#x27;zhangsan&#x27;, &#x27;language&#x27; : [1,[2,3],[4,5]],&#125;;var obj2 = shallowCopy(obj1);obj2.name = &quot;lisi&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];console.log(&#x27;obj1&#x27;,obj1)console.log(&#x27;obj2&#x27;,obj2) 2.2、浅拷贝的实现（1）Object.assign() Object.assign()方法可以把源对象自身的任意多个的可枚举属性拷贝给目标对象，然后返回目标对象，但是Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。此方法对于Array和Object均可适用。 123456789var obj1 = &#123; &#x27;name&#x27; : &#x27;zhangsan&#x27;, &#x27;language&#x27; : [1,[2,3],[4,5]],&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj2.name = &quot;lisi&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];console.log(&#x27;obj1&#x27;,obj1)console.log(&#x27;obj2&#x27;,obj2) （2）Array.prototype.concat()和Array.prototype.slice() Array.prototype.concat()和Array.prototype.slice()均为Array原型上的方法，只适用于Array。 123456789101112131415161718var arr1 = [1,3,&#123; user: &#x27;aaa&#x27;&#125;]var arr2 = arr1.concat();arr2[0] = &#x27;一&#x27;;arr2[2].user = &#x27;AAA&#x27;;console.log(&#x27;arr1&#x27;,arr1)console.log(&#x27;arr2&#x27;,arr2) var arr1 = [1,3,&#123; user: &#x27;aaa&#x27;&#125;]var arr2 = arr1.slice();arr2[0] = &#x27;一&#x27;;arr2[2].user = &#x27;AAA&#x27;;console.log(&#x27;arr1&#x27;,arr1)console.log(&#x27;arr2&#x27;,arr2) 补充说明：Array的slice和contact方法都不会修改原数组，而是会返回一个对原数组进行浅拷贝的新数组。这两种方法同Object.assign()一样，都是对第一层属性依次拷贝，如果第一层的属性是基本数据类型，就拷贝值；如果是引用数据类型，就拷贝内存地址。 三、JS深拷贝对对象的属性中所有引用类型的值，遍历到是基本类型的值为止。 3.1、深拷贝实现方式(1)JSON.parse(JSON.stringify())原理：用JSON.stringify()将对象转成字符串，再用JSON.parse()把字符串解析成对象。 123456789var obj1 = &#123; &#x27;name&#x27; : &#x27;zhangsan&#x27;, &#x27;language&#x27; : [1,[2,3],[4,5]],&#125;;var obj2 = JSON.parse(JSON.stringify(obj1));obj2.name = &quot;lisi&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];console.log(&#x27;obj1&#x27;,obj1)console.log(&#x27;obj2&#x27;,obj2) 缺点：这种方法可以实现数组和对象和基本数据类型的深拷贝，但不能处理函数。因为JSON.stringify()方法是将一个javascript值转换我一个JSON字符串，不能接受函数。其他影响如下： 如果对象中有时间对象，那么用该方法拷贝之后的对象中，时间是字符串形式而不是时间对象 如果对象中有RegExp、Error对象，那么序列化的结果是空 如果对象中有函数或者undefined，那么序列化的结果会把函数或undefined丢失 如果对象中有NAN、infinity、-infinity，那么序列化的结果会变成null JSON.stringfy（）只能序列化对象的可枚举自有属性，如果对象中有是构造函数生成的，那么拷贝后会丢弃对象的constructor 如果对象中存在循环引用也无法正确实现深拷贝 （2）手写深拷贝函数 通过递归实现深拷贝 1234567891011121314151617181920212223242526function deepCopy(obj)&#123; var result= Array.isArray(obj) ? [] : &#123;&#125; if (obj &amp;&amp; typeof(obj) === &#x27;object&#x27;) &#123; for (let i in obj) &#123; if (obj.hasOwnProperty(i))&#123; // 思考：这句是否有必要？ if (obj[i] &amp;&amp; typeof(obj[i]) === &#x27;object&#x27;) &#123; result[i] = deepCopy(obj[i]) &#125; else &#123; result[i] = obj[i] &#125; &#125; &#125; &#125; return result&#125;var obj1 = &#123; a: 1, b: &#123; c: 2 &#125;&#125;;var obj2 = deepCopy(obj1);obj2.a = &#x27;一&#x27;;obj2.b.c = &#x27;二&#x27;console.log(&#x27;obj1&#x27;, obj1)console.log(&#x27;obj2&#x27;, obj2) obj.hasOwnProperty(prop)用来判断obj这个对象中是否含有prop这个属性，返回布尔值，有则true，没有则false 以上有个缺陷：当遇到两个互相引用的对象时，会出现死循环的情况，从而导致爆栈。为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否互相引用。 深拷贝函数改进（防止循环递归爆栈） 12345678910111213141516171819202122232425262728293031323334353637function deepCopy(obj, parent = null) &#123; let result = Array.isArray(obj) ? [] : &#123;&#125; let _parent = parent // 该字段有父级则需要追溯该字段的父级 while(_parent) &#123; // 如果该字段引用了它的父级，则为循环引用 if (_parent.originalParent === obj) &#123; // 循环引用返回同级的新对象 return _parent.currentParent &#125; _parent = _parent.parent &#125; if (obj &amp;&amp; typeof(obj) === &#x27;object&#x27;) &#123; for (let i in obj) &#123; // 如果字段的值也是一个对象 if (obj[i] &amp;&amp; typeof(obj[i]) === &#x27;object&#x27;) &#123; // 递归执行深拷，将同级的待拷贝对象传递给parent，方便追溯循环引用 result[i] = deepCopy(obj[i], &#123; originalParent: obj, currentParent: result, parent: parent &#125;) &#125; else &#123; result[i] = obj[i] &#125; &#125; &#125; return result&#125;var obj1 = &#123; x: 1, y: 2&#125;;obj1.z = obj1var obj2 = deepCopy(obj1)console.log(&#x27;obj1&#x27;, obj1)console.log(&#x27;obj2&#x27;, obj2) 以上代码可以复制到浏览器去试试吧 深拷贝函数最终版（支持基本数据类型、Array、Object、原型链、RegExp、Date类型） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function deepCopy(obj, parent = null) &#123; let result let _parent = parent while(_parent) &#123; if (_parent.originalParent === obj) &#123; return _parent.currentParent &#125; _parent = _parent.parent &#125; if (obj &amp;&amp; typeof(obj) === &#x27;object&#x27;) &#123; if (obj instanceof RegExp) &#123; result = new RegExp(obj.source, obj.flags) &#125; else if (obj instanceof Date) &#123; result = new Date(obj.getTime()) &#125; else &#123; if (obj instanceof Array) &#123; result = [] &#125; else &#123; let proto = Object.getPrototypeOf(obj) result = Object.create(proto) &#125; for (let i in obj) &#123; if(obj[i] &amp;&amp; typeof(obj[i]) === &#x27;object&#x27;) &#123; result[i] = deepCopy(obj[i], &#123; originalParent: obj, currentParent: result, parent: parent &#125;) &#125; else &#123; result[i] = obj[i] &#125; &#125; &#125; &#125; else &#123; return obj &#125; return result&#125;var obj1 = &#123; x: 1 &#125; //试调用function construct()&#123; this.a = 1, this.b = &#123; x:2, y:3, z:[4,5,[6]] &#125;, this.c = [7,8,[9,10]], this.d = new Date(), this.e = /abc/ig, this.f = function(a,b)&#123; return a+b &#125;, this.g = null, this.h = undefined, this.i = &quot;hello&quot;, this.j = Symbol(&quot;foo&quot;)&#125;construct.prototype.str = &quot;I&#x27;m prototype&quot;var obj1 = new construct()obj1.k = obj1obj2 = deepCopy(obj1) obj2.b.x = 999obj2.c[0] = 666 console.log(&#x27;obj1&#x27;, obj1)console.log(&#x27;obj2&#x27;, obj2) （3）函数库也可以使用一些函数库，比如函数库lodash，也有提供_.cloneDeep用来做深拷贝； 123456789var _ = require(&#x27;lodash&#x27;);var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"前端样式导入的方式有哪些？","slug":"前端样式导入的方式有哪些？","date":"2020-12-06T16:36:09.000Z","updated":"2020-12-06T16:44:39.000Z","comments":true,"path":"2020/12/07/前端样式导入的方式有哪些？/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/07/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/","excerpt":"","text":"样式导入方式 link import 使用方式 link的使用 1&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt; import的使用 123&lt;style type=&quot;text/css&quot;&gt; @import &quot;index.css&quot;; &lt;/style&gt; 不同点 link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件 123&lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu.svg&quot;&gt;&lt;link rel=&quot;search&quot; type=&quot;application/opensearchdescription+xml&quot; href=&quot;/content-search.xml&quot; title=&quot;百度搜索&quot; /&gt; 兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的 在样式表文件可以使用import导入其它的样式表文件，而link不可以 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 加分项 import的写法比较多 12345@import &#x27;style.css&#x27; //Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别@import &quot;style.css&quot; //Windows IE4/ NS4, Macintosh IE4/NS4不识别@import url(style.css) //Windows NS4, Macintosh NS4不识别@import url(&#x27;style.css&#x27;) //Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别@import url(&quot;style.css&quot;) //Windows NS4, Macintosh NS4不识别 推荐使用 @import url(index.css);","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"判断一个对象是否为空对象","slug":"判断一个对象是否为空对象","date":"2020-12-06T16:23:07.000Z","updated":"2020-12-06T16:31:39.000Z","comments":true,"path":"2020/12/07/判断一个对象是否为空对象/","link":"","permalink":"https://perfectsymphony.github.io/2020/12/07/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"1234567891011121314let obj = &#123;&#125;let obj1 = &#123; name: &quot;jack&quot;&#125;let obj2 = &#123; [Symbol(&quot;name&quot;)]: &quot;jack&quot;,&#125;let obj3 = Object.defineProperty(&#123;&#125;, &quot;name&quot;, &#123; value: &quot;john&quot;, enumerable: false // 不可枚举&#125;) 方法一： 利用 for…in 循环12345678910function isEmpty(obj) &#123; for (let i in Object.keys(obj)) &#123; return false // 进入循环即不为空 &#125; return true&#125;console.log(isEmpty(obj)) // trueconsole.log(isEmpty(obj1)) // falseconsole.log(isEmpty(obj2)) // trueconsole.log(isEmpty(obj3)) // true 方法二：利用JSON.stringify()转化为字符串123456let isEmpty = (obj) =&gt; (JSON.stringify(obj) === &#x27;&#123;&#125;&#x27;) ? true : falseconsole.log(isEmpty(obj)) // trueconsole.log(isEmpty(obj1)) // falseconsole.log(isEmpty(obj2)) // trueconsole.log(isEmpty(obj3)) // true 方法三: 使用Object.keys()将取出对象中的键名，再判断长度123456let isEmpty = (obj) =&gt; (Object.keys(obj).length === 0) ? true : false console.log(isEmpty(obj)) // trueconsole.log(isEmpty(obj1)) // falseconsole.log(isEmpty(obj2)) // trueconsole.log(isEmpty(obj3)) // true 由此可见，以上三种方法不能判断对象中的不可枚举属性。 如果对象中含有不可枚举属性，我们又需要找出这些属性，就可以使用 Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() 这两个API。 Object.getOwnPropertyNames() 返回对象中的所有属性（不包括symbol） Object.getOwnPropertySymbols() 只返回对象中的symbol属性 所以我们可以结合它们： 12345678function isEmpty(obj) &#123; return !Object.getOwnPropertyNames(obj).length &amp;&amp; !Object.getOwnPropertySymbols(obj).length&#125;console.log(isEmpty(obj)) // trueconsole.log(isEmpty(obj1)) // falseconsole.log(isEmpty(obj2)) // falseconsole.log(isEmpty(obj3)) // false","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"js判断变量是不是数组的方法","slug":"js判断变量是不是数组的方法","date":"2020-11-23T16:17:31.000Z","updated":"2020-11-23T16:38:49.000Z","comments":true,"path":"2020/11/24/js判断变量是不是数组的方法/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/24/js%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"方案一： instanceof1变量 instanceof 类型 返回的是布尔值 true false&lt;br&gt;例: var a = [] a instanceof Array 方案二： 原型prototype + toString + call() 123首先: Object.prototype.toString.call(variable)来判断，返回值是字符串其次: Object.prototype.toString.call(variable).indexOf(&#x27;Array&#x27;) 如果变量对象是纯数组，返回的数字不是-1最后: Object.prototype.toString.call(variable).indexOf(&#x27;Array&#x27;) !== -1 比对数值是否等于-1就能判断是否是数组类型 是为true 方案三：原型prototype + isPrototypeOf()1Array.prototype.isPrototypeOf(variable) isPrototypeOf() 函数 : 用于指示对象是否存在于一个对象的原型链中。如果存在返回true，反之返回false。该方法属Object对象，由于所有的对象都继承了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。如果variable的原型链中存在Array对象，就会返回true，也就说明variable是数组类型。方案四：构造函数 constructor123variable.constructorvariable.constructor.toString()variable.constructor.toString().indexOf(&quot;Array&quot;) ！== -1 一个数组类型的实例，其原型proto.constructor右边是Array关键字，再拿到字符串，最后查找字符串中Array关键字的位置是否等于-1 方案五：数组方法 isArray()1Array.isArray(variable) javascript如何判断是否为对象？先声明一个对象 1var obj = &#123;&#125;； 判断是否为对象的方法： 1、toString（推荐） 1Object.prototype.toString.call(obj) === &#x27;[Object Object]&#x27; 2、constructor属性 constructor 属性返回对创建此对象的 Boolean 函数的引用。 1obj.constructor === Object 3、instanceof运算符 1obj instanceof Object 注：需要注意的是由于数组也是对象，因此用 arr instanceof Object 也为true。 4、typeof运算符 typeof运算符返回一个字符串，表示未经计算的操作数的类型。 123456789101112typeof obj === Object// 根据typeof判断对象也不太准确表达式 返回值typeof undefined &#x27;undefined&#x27;typeof null &#x27;object&#x27;typeof true &#x27;boolean&#x27;typeof 123 &#x27;number&#x27;typeof &quot;abc&quot; &#x27;string&#x27;typeof function() &#123;&#125; &#x27;function&#x27;typeof &#123;&#125; &#x27;object&#x27;typeof [] &#x27;object&#x27; 5、$.isPlainObject() 该方法判断指定参数是否是一个纯粹的对象（所谓”纯粹的对象”，就是该对象是通过”{}”或”new Object”创建的。） 1$.isPlainObject(obj)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"localStorage和sessionStorage区别","slug":"localStorage和sessionStorage区别","date":"2020-11-18T03:05:46.000Z","updated":"2020-11-18T04:29:37.000Z","comments":true,"path":"2020/11/18/localStorage和sessionStorage区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/18/localStorage%E5%92%8CsessionStorage%E5%8C%BA%E5%88%AB/","excerpt":"","text":"localStorage 和 sessionStorage一样都是用来存储客户端临时信息的对象。 他们均只能存储字符串类型的对象(虽然规范中可以存储其他类型的对象，但是目前位置没有浏览器对其进行实现)。localStorage生命周期是永久的，这意味着用户除非在浏览器上清除localStorage信息，否则，这些信息将永远存在。sessionStorage生命周期为当前窗口或者当前标签页，一旦窗口或者标签页被永久关闭，那么所有通过sessionStorage存储的数据也就被清空了。 不同的浏览器无法共享localStorage或者sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的localStorage(页面属于相同域名和端口)，但是不同页面或者标签页间无法共享sessionStorage的信息。这里需要注意，页面及标签仅指顶级窗口，如果标签页包含多个iframe标签且他们属于同源页面，那么他们之间可以共享sessionStorage的。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://perfectsymphony.github.io/tags/HTML/"}]},{"title":"table使用总结","slug":"table使用总结","date":"2020-11-13T11:11:30.000Z","updated":"2020-11-13T11:19:28.000Z","comments":true,"path":"2020/11/13/table使用总结/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/13/table%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"1、(IE浏览器)使用 table-layout:fixed;强制table的宽度,内层td,th采用word-break : break-all;或者word-wrap : break-word ;换行 2、解决设置table中td宽度不生效 特性：table是一个整体，每一列td的宽度是由一个其中一个最长td的宽度决定的。 解决：一定要在table标签上加word-wrap: break-word; word-break: break-all;之后再设置百分比宽度就可以生效了(获取你用的bootstrap，可以添加col-md-1) 让一个元素相对于父元素固定定位遇到了一个场景，需要实现相对于父元素的fixed定位：在父元素内拖动滚动条时，”fixed”定位的元素不能滑动，在外层拖动滚动条时，父元素及父元素内的所有元素跟着一起滑动。但是position: fixed是相对于窗口进行的定位，不能直接实现我们需要的效果。 让特定子元素相对于父元素”fixed”定位，也就是说，剩余的子元素不定位。那我们可以分开来想，如果添加一个祖先元素assistor，有两个祖先元素，一个用于辅助定位，一个用于包裹不定位的内容，这个问题就解决了。 实质上是child相对于assistorabsolute定位，parent内的内容自己负责展示。只要assistor和parent一样大，看起来就像是子元素child相对于父元素parent固定定位了。具体原理是position: absolute;的元素会相对于第一个设置了position: relative;的祖先元素进行定位，我们将assistor设置为position: reletive;，滚动条是在parent中的，这样”fixed”定位和parent内的内容滚动就都实现了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;test&lt;/td&gt;&lt;/title&gt;&lt;style&gt;.assistor &#123; position: relative; /*关键点*/ display: block; width: 100%; height: 300px; margin: 100px auto 0 auto; background-color: #ddd;&#125;.parent &#123; width: 100%; height: 300px; background-color: #888; overflow: auto; /*关键点*/&#125;.child &#123; position: absolute; /*关键点*/ width: 120px; height: 120px; margin: 100px 50px; background-color: #eee;&#125;.placeholder &#123; width: 100%; height: 1000px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;assistor&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;111&lt;/div&gt; &lt;div class=&quot;placeholder&quot;&gt; 1114561611&lt;br/&gt;11134111&lt;br/&gt;1111116761111&lt;br/&gt;1111111111111111111111 11111111111111111111111111111111111111111111111111111111111 1111111111111111111111111111111111111122222222222222222222 22222222222222222222222222222222222222222222222222222222222 222222222222222222222222&lt;br/&gt; 2222222222222222222222222222222 22222222222222222222222222&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://perfectsymphony.github.io/tags/HTML/"}]},{"title":"什么是函数柯里化","slug":"什么是函数柯里化","date":"2020-11-10T05:51:26.000Z","updated":"2020-11-10T07:13:46.000Z","comments":true,"path":"2020/11/10/什么是函数柯里化/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/10/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"1、初步认识柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。 12345678910111213var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11 代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。 在实际项目中，柯里化通常有以下三大作用 参数复用 提前确认 延迟运行 作用一、参数复用所谓参数复用，就是利用闭包的原理，让我们前面传输过来的参数不要被释放掉 1234567891011121314151617// 正常封装check函数进行字符串正则匹配function check(reg, txt) &#123; return reg.test(txt)&#125;check(/\\d+/g, &#x27;test&#x27;) //falsecheck(/[a-z]+/g, &#x27;test&#x27;) //true// 使用柯里化函数进行字符串正则匹配function curryingCheck(reg) &#123; return function (txt) &#123; return reg.test(txt) &#125;&#125;var hasNumber = curryingCheck(/\\d+/g)var hasLetter = curryingCheck(/[a-z]+/g)hasNumber(&#x27;test1&#x27;) // truehasNumber(&#x27;testtest&#x27;) // falsehasLetter(&#x27;21212&#x27;) // false 作用二、提前确认这一特性经常是用来对浏览器的兼容性做出一些判断并初始化api，比如说我们目前用来监听事件大部分情况是使用addEventListener来实现的，但是一些较久的浏览器并不支持该方法，所以在使用之前，我们可以先做一次判断，之后便可以省略这个步骤了。 123456789101112131415var on = (function () &#123; if (document.addEventListener) &#123; return function (element, event, handler) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.addEventListener(event, handler, false); &#125; &#125;; &#125; else &#123; return function (element, event, handler) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.attachEvent(&#x27;on&#x27; + event, handler); &#125; &#125;; &#125;&#125;)(); 作用三、 延迟运行js中的bind这个方法，用到的就是柯里化的这个特征。 1234567Function.prototype.bind = function (context) &#123; var _this = this var args = Array.prototype.slice.call(arguments, 1) return function() &#123; return _this.apply(context, args) &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"什么是纯函数","slug":"什么是纯函数","date":"2020-11-09T08:22:58.000Z","updated":"2020-11-09T08:50:07.000Z","comments":true,"path":"2020/11/09/什么是纯函数/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/09/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0/","excerpt":"","text":"纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。下面我们来分别说明一下概念中的两个条件： 返回结果只依赖其参数 返回值只和函数参数有关，与外部无关。无论外部发生什么样的变化，函数的返回值都不会改变。 123456789// 非纯函数 返回值与a相关，无法预料const a = 1const foo = (b) =&gt; a + bfoo(2) // =&gt; 3// 纯函数 返回结果只依赖于它的参数 x 和 b，foo(1, 2) 永远是 3。今天是 3，明天也是 3，在服务器跑是 3，在客户端跑也 3，不管你外部发生了什么变化，foo(1, 2) 永远是 3。只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的。const a = 1const foo = (x, b) =&gt; x + bfoo(1, 2) // =&gt; 3 函数执行过程中没有副作用 函数执行的过程中对外部产生了可观察的变化，我们就说函数产生了副作用。例如修改外部的变量、调用DOM API修改页面，发送Ajax请求、调用window.reload刷新浏览器甚至是console.log打印数据，都是副作用。 123456789101112131415161718// 无副作用const a = 1const foo = (obj, b) =&gt; &#123; return obj.x + b&#125;const counter = &#123; x: 1 &#125;foo(counter, 2) // =&gt; 3counter.x // =&gt; 1// 修改一下 ，再观察(修改了外部变量，产生了副作用。)const a = 1const foo = (obj, b) =&gt; &#123; obj.x = 2; return obj.x + b&#125;const counter = &#123; x: 1 &#125;foo(counter, 2) // =&gt; 4counter.x // =&gt; 2","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"前端常用60余种工具方法","slug":"前端常用60余种工具方法","date":"2020-11-04T09:44:56.000Z","updated":"2020-11-04T11:58:53.000Z","comments":true,"path":"2020/11/04/前端常用60余种工具方法/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/04/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A860%E4%BD%99%E7%A7%8D%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/","excerpt":"","text":"1、邮箱123export const isEmail = (s) =&gt; &#123; return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/.test(s)&#125; 2、手机号123export const isMobile = (s) =&gt; &#123; return /^1[0-9]&#123;10&#125;$/.test(s)&#125; 3、电话号码123export const isPhone = (s) =&gt; &#123; return /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/.test(s)&#125; 4、是否url地址123export const isURL = (s) =&gt; &#123; return /^http[s]?:\\/\\/.*/.test(s)&#125; 5、是否字符串123export const isString = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;String&#x27;&#125; 6、是否数字123export const isNumber = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Number&#x27;&#125; 7、是否boolean123export const isBoolean = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Boolean&#x27;&#125; 8、是否函数123export const isFunction = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Function&#x27;&#125; 9、是否null123export const isNull = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Null&#x27;&#125; 10、是否undefined123export const isUndefined = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Undefined&#x27;&#125; 11、是否对象123export const isObj = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Object&#x27;&#125; 12、是否数组123export const isArray = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Array&#x27;&#125; 13、是否时间123export const isDate = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Date&#x27;&#125; 14、是否正则123export const isRegExp = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;RegExp&#x27;&#125; 15、是否错误对象123export const isError = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Error&#x27;&#125; 16、是否Symbol函数123export const isSymbol = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Symbol&#x27;&#125; 17、是否Promise对象123export const isPromise = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Promise&#x27;&#125; 18、是否Set对象1234export const isSet = (o) =&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) === &#x27;Set&#x27;&#125;export const ua = navigator.userAgent.toLowerCase(); 19、是否是微信浏览器123export const isWeiXin = () =&gt; &#123; return ua.match(/microMessenger/i) == &#x27;micromessenger&#x27;&#125; 20、是否移动端1234export const isDeviceMobile = () =&gt; &#123; const ua = navigator.userAgent.toLowerCase(); return /android|webos|iphone|ipod|balckberry/i.test(ua)&#125; 21、是否是QQ浏览器123export const isQQBrowser = () =&gt; &#123; return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i)&#125; 22、是否是爬虫123export const isSpider = () =&gt; &#123; return /adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider/.test(ua)&#125; 23、是否iOS1234567891011121314export const isIos = () =&gt; &#123; var u = navigator.userAgent; if (u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1) &#123; //安卓手机 return false &#125; else if (u.indexOf(&#x27;iPhone&#x27;) &gt; -1) &#123;//苹果手机 return true &#125; else if (u.indexOf(&#x27;iPad&#x27;) &gt; -1) &#123;//iPad return false &#125; else if (u.indexOf(&#x27;Windows Phone&#x27;) &gt; -1) &#123;//winphone手机 return false &#125; else &#123; return false &#125;&#125; 24、是否为PC端1234567891011121314export const isPC = () =&gt; &#123; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; 25、去除html标签123export const removeHtmltag = (str) =&gt; &#123; return str.replace(/&lt;[^&gt;]+&gt;/g, &#x27;&#x27;)&#125; 26、获取url参数123456export const getQueryString = (name) =&gt; &#123; const reg = new RegExp(&#x27;(^|&amp;)&#x27; + name + &#x27;=([^&amp;]*)(&amp;|$)&#x27;, &#x27;i&#x27;); const search = window.location.search.split(&#x27;?&#x27;)[1] || &#x27;&#x27;; const r = search.match(reg) || []; return r[2];&#125; 27、引入动态js12345678export const injectScript = (src) =&gt; &#123; const s = document.createElement(&#x27;script&#x27;); s.type = &#x27;text/javascript&#x27;; s.async = true; s.src = src; const t = document.getElementsByTagName(&#x27;script&#x27;)[0]; t.parentNode.insertBefore(s, t);&#125; 28、根据url地址下载1234567891011121314151617181920212223export const download = (url) =&gt; &#123; var isChrome = navigator.userAgent.toLowerCase().indexOf(&#x27;chrome&#x27;) &gt; -1; var isSafari = navigator.userAgent.toLowerCase().indexOf(&#x27;safari&#x27;) &gt; -1; if (isChrome || isSafari) &#123; var link = document.createElement(&#x27;a&#x27;); link.href = url; if (link.download !== undefined) &#123; var fileName = url.substring(url.lastIndexOf(&#x27;/&#x27;) + 1, url.length); link.download = fileName; &#125; if (document.createEvent) &#123; var e = document.createEvent(&#x27;MouseEvents&#x27;); e.initEvent(&#x27;click&#x27;, true, true); link.dispatchEvent(e); return true; &#125; &#125; if (url.indexOf(&#x27;?&#x27;) === -1) &#123; url += &#x27;?download&#x27;; &#125; window.open(url, &#x27;_self&#x27;); return true;&#125; 29、el是否包含某个class1234export const hasClass = (el, className) =&gt; &#123; let reg = new RegExp(&#x27;(^|\\\\s)&#x27; + className + &#x27;(\\\\s|$)&#x27;) return reg.test(el.className)&#125; 30、el添加某个class12345678export const addClass = (el, className) =&gt; &#123; if (hasClass(el, className)) &#123; return &#125; let newClass = el.className.split(&#x27; &#x27;) newClass.push(className) el.className = newClass.join(&#x27; &#x27;)&#125; 31、el去除某个class1234567export const removeClass = (el, className) =&gt; &#123; if (!hasClass(el, className)) &#123; return &#125; let reg = new RegExp(&#x27;(^|\\\\s)&#x27; + className + &#x27;(\\\\s|$)&#x27;, &#x27;g&#x27;) el.className = el.className.replace(reg, &#x27; &#x27;)&#125; 32、获取滚动的坐标1234export const getScrollPosition = (el = window) =&gt; (&#123; x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft, y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop&#125;); 33、滚动到顶部1234567export const scrollToTop = () =&gt; &#123; const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125;&#125; 34、el是否在是视口范围内12345678export const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; &#123; const &#123; top, left, bottom, right &#125; = el.getBoundingClientRect(); const &#123; innerHeight, innerWidth &#125; = window; return partiallyVisible ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp; ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth)) : top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;&#125; 35、洗牌随机算法 12345678910export const shuffle = (arr) =&gt; &#123; var result = [], random; while (arr.length &gt; 0) &#123; random = Math.floor(Math.random() * arr.length); result.push(arr[random]) arr.splice(random, 1) &#125; return result;&#125; 36、劫持粘贴板12345678910111213export const copyTextToClipboard = (value) =&gt; &#123; var textArea = document.createElement(&quot;textarea&quot;); textArea.style.background = &#x27;transparent&#x27;; textArea.value = value; document.body.appendChild(textArea); textArea.select(); try &#123; var successful = document.execCommand(&#x27;copy&#x27;); &#125; catch (err) &#123; console.log(&#x27;Oops, unable to copy&#x27;); &#125; document.body.removeChild(textArea);&#125; 37、判断类型集合123456789101112131415161718192021222324252627282930313233343536373839404142434445作者：爱前端不爱恋爱链接：https://zhuanlan.zhihu.com/p/143590337来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。export const checkStr = (str, type) =&gt; &#123; switch (type) &#123; case &#x27;phone&#x27;: //手机号码 return /^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/.test(str); case &#x27;tel&#x27;: //座机 return /^(0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)(-\\d&#123;1,4&#125;)?$/.test(str); case &#x27;card&#x27;: //身份证 return /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/.test(str); case &#x27;pwd&#x27;: //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\\w&#123;5,17&#125;$/.test(str) case &#x27;postal&#x27;: //邮政编码 return /[1-9]\\d&#123;5&#125;(?!\\d)/.test(str); case &#x27;QQ&#x27;: //QQ号 return /^[1-9][0-9]&#123;4,9&#125;$/.test(str); case &#x27;email&#x27;: //邮箱 return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str); case &#x27;money&#x27;: //金额(小数点2位) return /^\\d*(?:\\.\\d&#123;0,2&#125;)?$/.test(str); case &#x27;URL&#x27;: //网址 return /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?/.test(str) case &#x27;IP&#x27;: //IP return /((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))/.test(str); case &#x27;date&#x27;: //日期时间 return /^(\\d&#123;4&#125;)\\-(\\d&#123;2&#125;)\\-(\\d&#123;2&#125;) (\\d&#123;2&#125;)(?:\\:\\d&#123;2&#125;|:(\\d&#123;2&#125;):(\\d&#123;2&#125;))$/.test(str) || /^(\\d&#123;4&#125;)\\-(\\d&#123;2&#125;)\\-(\\d&#123;2&#125;)$/.test(str) case &#x27;number&#x27;: //数字 return /^[0-9]$/.test(str); case &#x27;english&#x27;: //英文 return /^[a-zA-Z]+$/.test(str); case &#x27;chinese&#x27;: //中文 return /^[\\\\u4E00-\\\\u9FA5]+$/.test(str); case &#x27;lower&#x27;: //小写 return /^[a-z]+$/.test(str); case &#x27;upper&#x27;: //大写 return /^[A-Z]+$/.test(str); case &#x27;HTML&#x27;: //HTML标记 return /&lt;(&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*&gt;/.test(str); default: return true; &#125;&#125; 38、严格的身份校验12345678910111213141516171819202122232425262728293031323334353637383940作者：爱前端不爱恋爱链接：https://zhuanlan.zhihu.com/p/143590337来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。export const isCardID = (sId) =&gt; &#123; if (!/(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/.test(sId)) &#123; console.log(&#x27;你输入的身份证长度或格式错误&#x27;) return false &#125; //身份证城市 var aCity = &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;; if (!aCity[parseInt(sId.substr(0, 2))]) &#123; console.log(&#x27;你的身份证地区非法&#x27;) return false &#125; // 出生日期验证 var sBirthday = (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(/-/g, &quot;/&quot;), d = new Date(sBirthday) if (sBirthday != (d.getFullYear() + &quot;/&quot; + (d.getMonth() + 1) + &quot;/&quot; + d.getDate())) &#123; console.log(&#x27;身份证上的出生日期非法&#x27;) return false &#125; // 身份证号码校验 var sum = 0, weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2], codes = &quot;10X98765432&quot; for (var i = 0; i &lt; sId.length - 1; i++) &#123; sum += sId[i] * weights[i]; &#125; var last = codes[sum % 11]; //计算出来的最后一位身份证号码 if (sId[sId.length - 1] != last) &#123; console.log(&#x27;你输入的身份证号非法&#x27;) return false &#125; return true&#125; 39、随机数范围1234567export const random = (min, max) =&gt; &#123; if (arguments.length === 2) &#123; return Math.floor(min + Math.random() * ((max + 1) - min)) &#125; else &#123; return null; &#125;&#125; 40、将阿拉伯数字转换成中文的答谢数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546作者：爱前端不爱恋爱链接：https://zhuanlan.zhihu.com/p/143590337来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。export const numberToChinese = (num) =&gt; &#123; var AA = new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;); var BB = new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;); var a = (&quot;&quot; + num).replace(/(^0*)/g, &quot;&quot;).split(&quot;.&quot;), k = 0, re = &quot;&quot;; for (var i = a[0].length - 1; i &gt;= 0; i--) &#123; switch (k) &#123; case 0: re = BB[7] + re; break; case 4: if (!new RegExp(&quot;0&#123;4&#125;//d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;) .test(a[0])) re = BB[4] + re; break; case 8: re = BB[5] + re; BB[7] = BB[5]; k = 0; break; &#125; if (k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0) re = AA[0] + re; if (a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re; k++; &#125; if (a.length &gt; 1) // 加上小数部分(如果有小数部分) &#123; re += BB[6]; for (var i = 0; i &lt; a[1].length; i++) re += AA[a[1].charAt(i)]; &#125; if (re == &#x27;一十&#x27;) re = &quot;十&quot;; if (re.match(/^一/) &amp;&amp; re.length == 3) re = re.replace(&quot;一&quot;, &quot;&quot;); return re;&#125; 41、将数字转换成大写金额123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154作者：爱前端不爱恋爱链接：https://zhuanlan.zhihu.com/p/143590337来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。export const changeToChinese = (Num) =&gt; &#123; //判断如果传递进来的不是字符的话转换为字符 if (typeof Num == &quot;number&quot;) &#123; Num = new String(Num); &#125;; Num = Num.replace(/,/g, &quot;&quot;) //替换tomoney()中的“,” Num = Num.replace(/ /g, &quot;&quot;) //替换tomoney()中的空格 Num = Num.replace(/￥/g, &quot;&quot;) //替换掉可能出现的￥字符 if (isNaN(Num)) &#123; //验证输入的字符是否为数字 //alert(&quot;请检查小写金额是否正确&quot;); return &quot;&quot;; &#125;; //字符处理完毕后开始转换，采用前后两部分分别转换 var part = String(Num).split(&quot;.&quot;); var newchar = &quot;&quot;; //小数点前进行转化 for (var i = part[0].length - 1; i &gt;= 0; i--) &#123; if (part[0].length &gt; 10) &#123; return &quot;&quot;; //若数量超过拾亿单位，提示 &#125; var tmpnewchar = &quot;&quot; var perchar = part[0].charAt(i); switch (perchar) &#123; case &quot;0&quot;: tmpnewchar = &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar = &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar = &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar = &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar = &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar = &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar = &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar = &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar = &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar = &quot;玖&quot; + tmpnewchar; break; &#125; switch (part[0].length - i - 1) &#123; case 0: tmpnewchar = tmpnewchar + &quot;元&quot;; break; case 1: if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;; break; case 2: if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;; break; case 3: if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;; break; case 4: tmpnewchar = tmpnewchar + &quot;万&quot;; break; case 5: if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;; break; case 6: if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;; break; case 7: if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;; break; case 8: tmpnewchar = tmpnewchar + &quot;亿&quot;; break; case 9: tmpnewchar = tmpnewchar + &quot;拾&quot;; break; &#125; var newchar = tmpnewchar + newchar; &#125; //小数点之后进行转化 if (Num.indexOf(&quot;.&quot;) != -1) &#123; if (part[1].length &gt; 2) &#123; // alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;); part[1] = part[1].substr(0, 2) &#125; for (i = 0; i &lt; part[1].length; i++) &#123; tmpnewchar = &quot;&quot; perchar = part[1].charAt(i) switch (perchar) &#123; case &quot;0&quot;: tmpnewchar = &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar = &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar = &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar = &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar = &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar = &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar = &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar = &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar = &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar = &quot;玖&quot; + tmpnewchar; break; &#125; if (i == 0) tmpnewchar = tmpnewchar + &quot;角&quot;; if (i == 1) tmpnewchar = tmpnewchar + &quot;分&quot;; newchar = newchar + tmpnewchar; &#125; &#125; //替换所有无用汉字 while (newchar.search(&quot;零零&quot;) != -1) newchar = newchar.replace(&quot;零零&quot;, &quot;零&quot;); newchar = newchar.replace(&quot;零亿&quot;, &quot;亿&quot;); newchar = newchar.replace(&quot;亿万&quot;, &quot;亿&quot;); newchar = newchar.replace(&quot;零万&quot;, &quot;万&quot;); newchar = newchar.replace(&quot;零元&quot;, &quot;元&quot;); newchar = newchar.replace(&quot;零角&quot;, &quot;&quot;); newchar = newchar.replace(&quot;零分&quot;, &quot;&quot;); if (newchar.charAt(newchar.length - 1) == &quot;元&quot;) &#123; newchar = newchar + &quot;整&quot; &#125; return newchar;&#125; 42、判断一个元素是否在数组中123export const contains = (arr, val) =&gt; &#123; return arr.indexOf(val) != -1 ? true : false;&#125; 43、数组排序，{type} 1：从小到大 2：从大到小 3：随机1234567891011121314export const sort = (arr, type = 1) =&gt; &#123; return arr.sort((a, b) =&gt; &#123; switch (type) &#123; case 1: return a - b; case 2: return b - a; case 3: return Math.random() - 0.5; default: return arr; &#125; &#125;)&#125; 44、去重1234567891011121314export const unique = (arr) =&gt; &#123; if (Array.hasOwnProperty(&#x27;from&#x27;)) &#123; return Array.from(new Set(arr)); &#125; else &#123; var n = &#123;&#125;, r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (!n[arr[i]]) &#123; n[arr[i]] = true; r.push(arr[i]); &#125; &#125; return r; &#125;&#125; 45、求两个集合的并集1234export const union = (a, b) =&gt; &#123; var newArr = a.concat(b); return this.unique(newArr);&#125; 47、删除其中一个元素1234567export const remove = (arr, ele) =&gt; &#123; var index = arr.indexOf(ele); if (index &gt; -1) &#123; arr.splice(index, 1); &#125; return arr;&#125; 48、将类数组转换成数组123456789export const formArray = (ary) =&gt; &#123; var arr = []; if (Array.isArray(ary)) &#123; arr = ary; &#125; else &#123; arr = Array.prototype.slice.call(ary); &#125;; return arr;&#125; 49、最大值123export const max = (arr) =&gt; &#123; return Math.max.apply(null, arr);&#125; 50、最小值123export const min = (arr) =&gt; &#123; return Math.min.apply(null, arr);&#125; 51、求和12345export const sum = (arr) =&gt; &#123; return arr.reduce((pre, cur) =&gt; &#123; return pre + cur &#125;)&#125; 52、平均值123export const average = (arr) =&gt; &#123; return this.sum(arr) / arr.length&#125; 53、去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格123456789101112131415export const trim = (str, type) =&gt; &#123; type = type || 1 switch (type) &#123; case 1: return str.replace(/\\s+/g, &quot;&quot;); case 2: return str.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;); case 3: return str.replace(/(^\\s*)/g, &quot;&quot;); case 4: return str.replace(/(\\s*$)/g, &quot;&quot;); default: return str; &#125;&#125; 54、字符转换，type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写12345678910111213141516171819202122232425262728export const changeCase = (str, type) =&gt; &#123; type = type || 4 switch (type) &#123; case 1: return str.replace(/\\b\\w+\\b/g, function (word) &#123; return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); &#125;); case 2: return str.replace(/\\b\\w+\\b/g, function (word) &#123; return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); &#125;); case 3: return str.split(&#x27;&#x27;).map(function (word) &#123; if (/[a-z]/.test(word)) &#123; return word.toUpperCase(); &#125; else &#123; return word.toLowerCase() &#125; &#125;).join(&#x27;&#x27;) case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125; 55、监测密码强度12345678910111213141516171819export const checkPwd = (str) =&gt; &#123; var Lv = 0; if (str.length &lt; 6) &#123; return Lv &#125; if (/[0-9]/.test(str)) &#123; Lv++ &#125; if (/[a-z]/.test(str)) &#123; Lv++ &#125; if (/[A-Z]/.test(str)) &#123; Lv++ &#125; if (/[\\.|-|_]/.test(str)) &#123; Lv++ &#125; return Lv;&#125; 56、函数节流器123456export const debouncer = (fn, time, interval = 200) =&gt; &#123; if (time - (window.debounceTimestamp || 0) &gt; interval) &#123; fn &amp;&amp; fn(); window.debounceTimestamp = time; &#125;&#125; 57、在字符串中插入新的字符1234export const insertStr = (soure, index, newStr) =&gt; &#123; var str = soure.slice(0, index) + newStr + soure.slice(index); return str;&#125; 58、判断两个对象是否键值相同1234567891011121314151617export const isObjectEqual = (a, b) =&gt; &#123; var aProps = Object.getOwnPropertyNames(a); var bProps = Object.getOwnPropertyNames(b); if (aProps.length !== bProps.length) &#123; return false; &#125; for (var i = 0; i &lt; aProps.length; i++) &#123; var propName = aProps[i]; if (a[propName] !== b[propName]) &#123; return false; &#125; &#125; return true;&#125; 59、16进制颜色转RGBRGBA字符串12345678910111213141516171819202122export const colorToRGB = (val, opa) =&gt; &#123; var pattern = /^(#?)[a-fA-F0-9]&#123;6&#125;$/; //16进制颜色值校验规则 var isOpa = typeof opa == &#x27;number&#x27;; //判断是否有设置不透明度 if (!pattern.test(val)) &#123; //如果值不符合规则返回空字符 return &#x27;&#x27;; &#125; var v = val.replace(/#/, &#x27;&#x27;); //如果有#号先去除#号 var rgbArr = []; var rgbStr = &#x27;&#x27;; for (var i = 0; i &lt; 3; i++) &#123; var item = v.substring(i * 2, i * 2 + 2); var num = parseInt(item, 16); rgbArr.push(num); &#125; rgbStr = rgbArr.join(); rgbStr = &#x27;rgb&#x27; + (isOpa ? &#x27;a&#x27; : &#x27;&#x27;) + &#x27;(&#x27; + rgbStr + (isOpa ? &#x27;,&#x27; + opa : &#x27;&#x27;) + &#x27;)&#x27;; return rgbStr;&#125; 60、追加url参数1234567891011121314export const appendQuery = (url, key, value) =&gt; &#123; var options = key; if (typeof options == &#x27;string&#x27;) &#123; options = &#123;&#125;; options[key] = value; &#125; options = $.param(options); if (url.includes(&#x27;?&#x27;)) &#123; url += &#x27;&amp;&#x27; + options &#125; else &#123; url += &#x27;?&#x27; + options &#125; return url;&#125;","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://perfectsymphony.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Nginx正向代理与反向代理","slug":"Nginx正向代理与反向代理","date":"2020-11-02T02:27:24.000Z","updated":"2020-11-02T03:35:01.000Z","comments":true,"path":"2020/11/02/Nginx正向代理与反向代理/","link":"","permalink":"https://perfectsymphony.github.io/2020/11/02/Nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/","excerpt":"","text":"一、介绍实践中客户端无法直接跟服务端发起请求的时候，我们就需要代理服务。代理可以实现客户端与服务端之间的通信,我们的Nginx也可以实现相应的代理服务。 二、正向代理和反向代理的区别 正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端正向代理简单地打个租房的比方: A(客户端)想租C(服务端)的房子,但是A(客户端)并不认识C(服务端)租不到。B(代理)认识C(服务端)能租这个房子所以你找了B(代理)帮忙租到了这个房子。 这个过程中C(服务端)不认识A(客户端)只认识B(代理)C(服务端)并不知道A(客户端)租了房子，只知道房子租给了B(代理)。 反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端反向代理也用一个租房的例子: A(客户端)想租一个房子,B(代理)就把这个房子租给了他。这时候实际上C(服务端)才是房东。B(代理)是中介把这个房子租给了A(客户端)。 这个过程中A(客户端)并不知道这个房子到底谁才是房东他都有可能认为这个房子就是B(代理)的 由上的例子和图我们可以知道正向代理和反向代理的区别在于代理的对象不一样,正向代理的代理对象是客户端,反向代理的代理对象是服务端。 三、Nginx代理的配置演示1、正向代理配置场景演示正向代理很常见,我们的科学上网就是一种正向代理。我们接下来演示正向代理的这么一个场景。首先我在我的A服务器的nginx设置访问控制访问控制之前我访问A下的test.html是这样的: 我们打开/etc/nginx/conf.d/default.conf我们加入这么一个判断语句如果访问A的IP不是118.126.106.11(我的B服务器)则返回403. 1234567location &#x2F; &#123; if ( $remote_addr !~* &quot;^118\\.126\\.106\\.11&quot;) &#123; return 403; &#125; root &#x2F;opt&#x2F;app&#x2F;demo&#x2F;html; index index.html index.htm; &#125; 添加后reload一下nginx再访问test.html: 此时本地我的浏览器就是被限制了,访问不了该资源。现在我登录上我的B服务器,打开/etc/nginx/conf.d/default.conf添加resolver和proxy_pass,设置如下: 1234567891011121314server &#123; listen 80; server_name localhost nginx.tangll.cn; resolver 8.8.8.8; location / &#123; proxy_pass http://$http_host$request_uri; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; resolver为DNS解析,这里填写的IP为Google提供的免费DNS服务器的IP地址proxy_pass配置代理转发至此便是配置了B服务器所有访问根一级的请求全部都代理转发对应到$http_host$request_uri去了,$http_host就是我们要访问的主机名,$request_uri就是我们后面所加的参数。简单的说至此就是相当于配置好了我们请求了B服务器,B服务器再去请求我们所请求的地址。 那么接下来我们来看一下结果,我们在本地配置好代理,我这里是mac系统,可以从网络设置中选择高级,然后选择代理 填入我们B服务器的IP,然后我们来看一下代理是否成功。我们登录http://www.ip138.com/ 可以看到此时我们的IP地址已经为B服务器的IP,说明代理成功。 然后我们再来访问一下test.html: 结果证明,此时的客户端已经可以成功访问A服务器的资源。以上就是正向代理的一个场景演示,这个过程中可以知道,我们客户端是想要A的资源,但是A的资源只有B能拿到,便让B代理去帮助我们访问A的资源。整个过程A只知道B拿了他的资源,并不知道客户端拿到。 2、反向代理配置场景演示反向代理的演示更为简单一些。首先在/etc/nginx/conf.d/下新建一个test.conf: 1234567891011121314server &#123; listen 8080; server_name localhost nginx.tangll.cn; location / &#123; root /opt/app/demo/html; index index.html index.htm; &#125; error_page 500 502 503 504 404 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 可以看到我server里listen的是8080端口,但是我的服务器本身不对外开放8080端口,只开放了80端口。所以我们此时访问test.html结果是访问不到的: 然后我们打开我们的/etc/nginx/conf.d/default.conf添加proxy_pass设置如下: 123456789101112131415161718server &#123; listen 80; server_name localhost nginx.tangll.cn; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #设置代理 #location ~ /test.html$ &#123; # proxy_pass http://127.0.0.1:8080; #&#125; error_page 500 502 503 504 404 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 我们设置当匹配test.html结尾的URL时就去代理访问本机的8080端口为了对比我们先注释掉,然后直接80端口访问一下test.html: 可以看到此时返回的404。这时候取消注释我们reload一下nginx然后用80端口访问test.html 此时便可访问8080端口配置的资源。以上便是完成了一个反向代理的演示,这个过程中我们可以知道,客户端想要访问的是test.html,但是test.html实际上是8080端口下配置的,中间经过了代理才能拿到。也就是说客户端并不知道中间经历了什么代理过程,只有服务端知道。客户端只知道他拿到了test.html也就是8080端口下配置的资源内容。 四、总结 由上的打比方和演示例子可以体会到正向代理与反向代理的区别和Nginx正向代理和反向代理的简单配置。正向代理和反向代理的区别上边也说过在于代理的对象不一样,正向代理的代理对象是客户端,反向代理的代理对象是服务端。最后一句话总结此文就是代理服务器站在客户端那边就是正向代理，代理服务器站在原始服务器那边就是反向代理,Nginx通过proxy_pass可以设置代理服务。","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://perfectsymphony.github.io/tags/Nginx/"}]},{"title":"手写出场率极高的面试题","slug":"手写出场率极高的面试题","date":"2020-10-30T12:19:39.000Z","updated":"2020-11-04T12:09:29.000Z","comments":true,"path":"2020/10/30/手写出场率极高的面试题/","link":"","permalink":"https://perfectsymphony.github.io/2020/10/30/%E6%89%8B%E5%86%99%E5%87%BA%E5%9C%BA%E7%8E%87%E6%9E%81%E9%AB%98%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"为什么要会手写?面试遇到手写题一脸懵逼的你也许一定想问：网上代码一堆，随便抄一下不香吗，为什么要手写？关于这个问题最直接的回答：为了区分厉害的和普通的。但坦白来讲，会白板实现关键功能的人，实现业务需求的效率一定更高。 为什么这么说？拿手写 Promise 举例来讲，真实的业务场景会遇到大量的 AJAX 异步请求，而且大多是嵌套多层的异步代码。 普通前端 A 平时只会最简单的 Promise 用法，遇到多层嵌套的 Promise 就搞不清楚逻辑了，于是开发 1 小时，修 Bug 3 小时，内卷 996； 高级前端 B 会手写 Promise，对 Promise 的内在逻辑一清二楚，于是开发半小时，修 Bug 15 分钟，完成质量高速度快，深受 PM 小姐姐和测试小哥哥的喜爱，准点下班绩效高。 再举个 EventHub 的例子，会手写 EventHub 的前端，Vue 里的 $emit、$on 基本就是闭眼写；同理还有 React 里面组件想要调用普通函数（非箭头函数），需要 this.fn.bind(this)，会手写 bind 的前端就更容易举一反三，不会的就只能死记硬背，遇到 Bug 不知所措。。。 所以，会“四大手写”是前端进阶的必由之路，甚至可以说，手写关键代码的能力 ≈ 编程能力。 1、防抖12345678910111213141516function debounce(func, ms = 1000)&#123; let timer; return function(...args)&#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; func.apply(this, args) &#125;, ms) &#125;&#125;// 测试const task = () =&gt; &#123; console.log(&#x27;run task&#x27;) &#125;const debounceTask = debounce(task, 1000)window.addEventListener(&#x27;scroll&#x27;, debounceTask) 2、节流123456789101112131415function throttle(func, ms = 1000)&#123; let canRun = true return function(...args)&#123; if(!canRun) return canRun = false setTimeout(() =&gt; &#123; func.apply(this, args) canRun = true &#125;, ms) &#125;&#125;const task = () =&gt; &#123; console.log(&#x27;run task&#x27;) &#125;const throttleTask = throttle(task, 1000)window.addEventListener(&#x27;scroll&#x27;, throttleTask) 3、深拷贝12345678910111213function deepClone(source)&#123; if(!source &amp;&amp; typeof source !== &#x27;object&#x27;) throw new Error(&#x27;error arguments&#x27;, &#x27;deepClone&#x27;) const targetObj = source.constructor === Array ? [] : &#123;&#125; Object.keys(source).forEach(keys =&gt; &#123; if(source[keys] &amp;&amp; typeof source[keys] === &#x27;object&#x27;)&#123; targetObj[keys] = deepclone(source[keys]) &#125; else &#123; targetObj[keys] = source[keys] &#125; &#125;) return targetObj&#125; 4、new12345678910111213141516171819202122function myNew(Fun, ...args)&#123; const instance = &#123;&#125; if(Func.prototype)&#123; Object.setPrototypeOf(instance, Func.prototype) &#125; const res = Func.apply(instance, args) if(typeof res === &#x27;function&#x27; || (typeof res === &#x27;object&#x27; &amp;&amp; res !== null))&#123; return res &#125; return instance&#125;// 测试function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log(`my name is $&#123;this.name&#125;`);&#125;const me = myNew(person, &#x27;Jack&#x27;)me.sayName();console.log(me) 5、bind123456789101112131415161718192021222324252627Function.prototype.mybind = function(context = globalThis)&#123; const fn = this const args = Array.from(arguments).slice(1) const newFunc = function()&#123; const newArgs = args.concat(...arguments) if(this instanceof newFunc)&#123; // 通过 new 调用，绑定this为实例对象 fn.apply(this, newArgs) &#125; else &#123; //通过普通函数形式调用，绑定context fn.apply(context, newArgs) &#125; &#125; newFunc.prototype = Object.create(fn.prototype) return newFunc&#125;// 测试const me = &#123; name: &#x27;Jack&#x27; &#125;const other = &#123; name: &#x27;Jackson&#x27; &#125;function say()&#123; console.log(`my name is $&#123;this.name || &#x27;default&#x27;&#125;`);&#125;const meSay = say.bind(me);meSay()const otherSay = say.bind(other)otherSay() 5、call123456789101112131415161718Function.prototype.myCall = function(context = globalThis)&#123; // 关键步骤，在 context 上调用方法，触发 this 绑定为 context，使用 Symbol 防止原有属性的覆盖 const key = Symbol(&#x27;key&#x27;); context[key] = this let args = [].slice.call(argments, 1) let res = context[key](...args) delete context[key] return res&#125;// 测试const me = &#123; name: &#x27;Jack&#x27;&#125;function say()&#123; console.log(`my name is $&#123;this.name || &#x27;default&#x27;&#125;`)&#125;say.myCall(me) 6、apply123456789101112131415161718192021Function.prototype.myApply = function(context = globalThis)&#123; // 关键步骤，在 context 上调用方法，触发 this 绑定为 context，使用 Symbol 防止原有属性的覆盖 const key = Symbol(&#x27;key&#x27;); constext[key] = this let res if(arguments[1])&#123; res = context[key](...argments[1]) &#125; else &#123; res = context[key]() &#125; return res&#125;// 测试const me = &#123; name: &#x27;Jack&#x27;&#125;function say()&#123; console.log(`my name is $&#123;this.name || &#x27;default&#x27;&#125;`)&#125;say.myApply(me) 7、deepClone1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Function.prototype.deepClone = function(obj, cache = new weakup())&#123; if(!obj instanceof Object) return obj // 防止循环引用 if(cache.get(obj)) return cache.get(obj) //支持函数 if(obj instanceof Function)&#123; return function()&#123; obj.apply(this, argments) &#125; &#125; //支持日期 if(obj instanceof Date) return new Date(obj) // 支持正则对象 if(obj instanceof RegExp) return new RegExp(obj.source, obj.flags) // 还可以增加其他对象，比如：Map, Set等， // 数组是 key 为数字索引的特殊对象 const res = Array.isArray(obj) ? []: &#123;&#125; // 缓存 copy 的对象，用于处理循环引用的情况 cache.set(obj, res) Object.keys(obj).forEach((key) =&gt; &#123; if(object[key] instanceof Object)&#123; res[key] = deepClone(obj[key], cache) &#125; else &#123; res[key] = obj[key] &#125; &#125;) return res&#125;// 测试const source = &#123; name: &#x27;Jack&#x27;, meta: &#123; age: 12, birth: new Date(&#x27;1970-10-10&#x27;) ary: [1, 2, &#123;a: 1&#125;], say()&#123; console.log(&#x27;hello&#x27;) &#125; &#125;&#125;source.source = source;const newObj = deepClone(source)console.log(newObj.meta.ary[2] === source.meta.ary[2]) 8、事件总线 | 发布订阅模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class EventEmitter = &#123; constructor()&#123; this.cache = &#123;&#125; &#125; on(name, fn)&#123; if(this.cache[name])&#123; this.cache[name].push(fn) &#125; else &#123; this.cache[name] = fn &#125; &#125; off(name, fn)&#123; const tasks = this.cache[name] if(tasks)&#123; const index tasks.findIndex(f =&gt; f === fn || f.callback === fn) if(index &gt;= 0)&#123; tasks.splice(index, 1) &#125; &#125; &#125; emit(name)&#123; if(this.cache[name])&#123; //创建副本，如果回调函数内继续注册相同事件，会造成死循环 const tasks = this.cache[name].slice() for(let fn of tasks)&#123; fn() &#125; &#125; &#125; emit(name, once = false)&#123; if(this.cache[name])&#123; //创建副本，如果回调函数内继续注册相同的事件，会造成死循环 const tasks = this.cache[name].slice() for(let fn of tasks)&#123; fn() &#125; if(once)&#123; delete this.cache[name] &#125; &#125; &#125;&#125;//测试const eventBus = new EventEmitter()const task1 = () =&gt; &#123; console.log(&#x27;task1&#x27;); &#125;const task2 = () =&gt; &#123; console.log(&#x27;task2&#x27;); &#125;eventBus.on(&#x27;task&#x27;, task1)eventBus.on(&#x27;task&#x27;, task2)setTimeout(() =&gt; &#123; eventBus.emit(&#x27;task&#x27;)&#125;, 1000) 9、柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数123456789101112131415161718192021function curry(func)&#123; return function curried(..args)&#123; //关键知识点：function.length 用来获取函数的形参个数 // arguments.length 获取的是实参个数 if(args.length &gt;= func.length)&#123; return func.apply(this, args) &#125; return function(...args2)&#123; return curried.apply(this, args.concat(args2)) &#125; &#125;&#125;//测试funtion sum(a, b, c)&#123; return a + b + c&#125;const curriedSum = curry(sum)console.log(curriedSum(1, 2, 3))console.log(curriedSum(1)(2, 3))console.log(curriedSum(1)(2)(3)) 10、es5实现继承12345678910111213141516171819202122232425262728293031function create(proto)&#123; function F() &#123;&#125; F.prototype = proto; return new F()&#125;//parentfunction Parent(name)&#123; this.name = name;&#125;Parent.prototype.sayName = function()&#123; console.log(this.name)&#125;//childfunction Child(age, name)&#123; Parent.call(this, name) this.age = age&#125;Child.prototype = create(Parent.prototype)Child.prototype.constructor = ChildChild.prototype.sayAge = function()&#123; console.log(this.age)&#125;//测试const child = new Child(18, &#x27;Jack&#x27;)child.sayName()child.sayAge() instanceof123456789101112131415function isInstanceof(instance, klass)&#123; let proto = instance._proto_ let prototyoe = klass.prototype while(true)&#123; if(proto === null) return false if(proto === prototype) return false proto = proto.__proto__ &#125;&#125;// 测试class Parent &#123;&#125;class Child extends Parent &#123;&#125;const child = new Child()console.log(isInstanceof(child, Parent), isInstanceof(child,Child), isInstanceof(child,Array)) 12、异步并发数限制1234567891011121314151617181920212223242526272829303132/** * 关键点 * 1. new promise 一经创建，立即执行 * 2. 使用 Promise.resolve().then 可以把任务加到微任务队列，防止立即执行迭代方法 * 3. 微任务处理过程中，产生的新的微任务，会在同一事件循环内，追加到微任务队列里 * 4. 使用 race 在某个任务完成时，继续添加任务，保持任务按照最大并发数进行执行 * 5. 任务完成后，需要从 doingTasks 中移出 */function limit(count, array, iterateFunc)&#123; const tasks = [] const doingTasks = [] let i = 0 const enqueue = () =&gt; &#123; if(i == array.length)&#123; return Promise.resolve() &#125; const task = Promise.resolve().then(() =&gt; &#123; iterateFunc(array[i++]) &#125;) tasks.push(task) const doing = task.then(() =&gt; doingTasks.splice(doingTasks.indexOf(doing), 1)) doingTasks.push(doing) const res = doingTasks.length &gt;= count ? Promise.race(doingTasks) : Promise.resolve() return res.then(enqueue) &#125; return enqueue().then(() =&gt; Promise.all(tasks))&#125;// 测试const timeout = i =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(i), i))limit(2, [1000, 1000, 1000, 1000], timeout).then(res =&gt; console.log(res)) 13、异步串行 ｜ 异步并行1234567891011121314151617181920212223242526272829303132333435363738394041424344// 实现一个异步加法function asyncAdd(a, b, callback)&#123; setTimeout(function()&#123; callback(null, a + b) &#125;, 500)&#125;// 解决方案// 1、promiseconst promiseAdd = (a, b) =&gt; Promise((resolve, reject) =&gt; &#123; asyncAdd(a, b, (err, res) =&gt; &#123; if(err)&#123; reject(err) &#125; else &#123; resolve(res) &#125; &#125;)&#125;)//2、串行处理async function serialSum(...args)&#123; return args.reduce((task, now) =&gt; task.then(res =&gt; promiseAdd(res, now)), promise.resolve(0))&#125;//3、并行处理async function parallelSum(...args)&#123; if(args.length === 1) return args[0] const tasks = [] for(let i = 0; i &lt; args.length; i += 2)&#123; tasks.push(promiseAdd(args[i], args[i + 1] || 0)) &#125; const results = await Promise.all(tasks) return parallelSum(...results)&#125;// 测试(async () =&gt; &#123; console.log(&#x27;RUNning...&#x27;) const res1 = await serialSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12) console.log(res1) const res2 = await parallelSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12) console.log(res2) console.log(&#x27;Done&#x27;)&#125;)() 14. vue reactive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// Dep moduleclass Dep &#123; static stack = [] static target = null deps = null constructor()&#123; this.deps = new Set() &#125; depend()&#123; if(Dep.target)&#123; this.deps.add(Dep.target) &#125; &#125; notify()&#123; this.deps.forEach(w =&gt; w.update()) &#125; static pushTarget(t)&#123; if(this.target)&#123; this.stack.push(this.target) &#125; this.target = t &#125; static popTarget()&#123; this.target = this.stack.pop() &#125;&#125;// reactivefunction reactive(o)&#123; if(o &amp;&amp; typeof o === &#x27;object&#x27;)&#123; Object.keys(o).forEach(k =&gt; &#123; defineReactive(o, k, o[k]) &#125;) &#125; return o&#125;function defineReactive(obj, k, val)&#123; let dep = new Dep() Object.defineProperty(obj, k, &#123; get()&#123; dep.depend() return val &#125;, set(newVal)&#123; val = newVal dep.notify() &#125; &#125;) if(val &amp;&amp; typeof val === &#x27;object&#x27;)&#123; reactive(val) &#125;&#125;// watcherclass Watcher &#123; constructor(effect)&#123; this.effect = effect this.update() &#125; update()&#123; Dep.pushTarget(this) this.value = this.effect() Dep.popTarget() return this.value &#125;&#125;// 测试const data = reactive(&#123; msg: &#x27;aaa&#x27;&#125;)new Watcher(() =&gt; &#123; console.log(&#x27;===&gt;effect&#x27;, data.msg)&#125;)setTimeout(() =&gt; &#123; data.msg = &#x27;hello&#x27;&#125;, 1000) 15、promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 建议阅读 [Promises/A+ 标准](https://promisesaplus.com/)class MyPromise &#123; constructor(func)&#123; this.status = &#x27;pending&#x27; this.value = null this.resolvedTasks = [] this.rejectedTasks = [] this._resolve = this._resolve.bind(this) this._reject = this._reject.bind(this) try&#123; func(this._resolve, this._reject) &#125; catch (error)&#123; this._reject(error) &#125; &#125; _resolve(value)&#123; setTimeout(() =&gt; &#123; this.status = &#x27;fulfilled&#x27; this.value = value this.resolvedTasks.forEach(t =&gt; t(value)) &#125;) &#125; _reject(reason)&#123; setTimeout(() =&gt; &#123; this.status = &#x27;reject&#x27; this.value = reason this.rejectedTasks.forEach(t =&gt; t(reason)) &#125;) &#125; then(onFulfilled, onRejected)&#123; return new MyPromise((resolve, reject) =&gt; &#123; this.resolvedTasks.push((value) =&gt; &#123; try&#123; const res = onFulfilled(value) if(res instanceof MyPromise)&#123; res.then(resolve, reject) &#125; else &#123; resolve(res) &#125; &#125; catch(error)&#123; reject(error) &#125; &#125;) this.rejectedTasks.push((value) =&gt; &#123; try&#123; const res onRejected(value) if(res instanceof MyPromise)&#123; res.then(resolve, reject) &#125; else &#123; reject(res) &#125; &#125; catch(error)&#123; reject(error) &#125; &#125;) &#125;) &#125; catch(onRejected)&#123; return this.then(null, onRejected) &#125;&#125;//测试new MyPromise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 500)&#125;).then(res =&gt; &#123; console.log(res) return new MyPromise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2) &#125;, 500) &#125;)&#125;).then(res =&gt; &#123; console.log(res) throw new Error(&#x27;a error&#x27;)&#125;).catch(err =&gt; &#123; console.log(&#x27;===&gt;&#x27;, err);&#125;) 16、数组扁平化12345678910111213141516171819202122function recursionFlat(arr = [])&#123; const res = [] arr.forEach(item =&gt; &#123; if(Array.isArray(item))&#123; res.push(...recursionFlat(item)) &#125; else &#123; res.push(item) &#125; &#125;) return res&#125;// 方案二function reduceFlat(arr = [])&#123; return arr.reduce((res, item) =&gt; res.concat(Array.isArray(item) ? reduceFlat(item) : item), [])&#125;// 测试const source = [1, 2, [3, 4, [5, 6]], &#x27;7&#x27;]console.log(recursionFlat(source))console.log(reduceFlat(source)) 17、对象扁平化12345678910111213141516171819202122232425262728293031function objectFlat(obj = &#123;&#125;)&#123; const res = &#123;&#125; function flat(item, preKey = &#x27;&#x27;)&#123; Object.entries(item).foreach(([key, val]) =&gt; &#123; const newKey = preKey ? `$&#123;preKey&#125;.$&#123;key&#125;` : key if(val &amp;&amp; typeof val === &#x27;object&#x27;)&#123; flat(val, newKey) &#125; else &#123; res[newKey] = val &#125; &#125;) &#125; flat(obj) return res&#125;// 测试const source = &#123; a: &#123; b: &#123; c: 1, d: 2 &#125;, e: 3, &#125;, f: &#123; g: 2 &#125;&#125;console.log(objectFlat(source)) 18、图片懒加载1234567891011121314151617181920212223242526272829// &lt;img src=&quot;default.png&quot; data-src=&quot;https://xxxx/real.png&quot;&gt;function isVisible(el)&#123; const position = el.getBoundingClientRect() const windowHeight = document.documentElement.clientHeight //顶部边缘可见 const topVisible = position.top &gt; 0 &amp;&amp; position.top &lt; windowHeight; //底部边缘可见 const bottomVisible = position.bottom &lt; windowHeight &amp;&amp; position.bottom &gt; 0 return topVisible || bottomVisible;&#125;function imageLazyLoad()&#123; const images = document.querySelectorAll(&#x27;img&#x27;) for(let img of images)&#123; const realSrc = img.dataset.src if(!realSrc) contine if(isVisible(img))&#123; img.src = realSrc img.dataset.src = &#x27;&#x27; &#125; &#125;&#125;// 测试window.addEventListener(&#x27;load&#x27;, imageLazyLoad)window.addEventListener(&#x27;scroll&#x27;, imageLazyLoad)// orwindow.addEventListener(&#x27;scroll&#x27;, throttle(imageLazyLoad, 1000))","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"JS能力测评经典题总结","slug":"JS能力测评经典题总结","date":"2020-10-12T09:13:24.000Z","updated":"2020-10-30T11:18:42.000Z","comments":true,"path":"2020/10/12/JS能力测评经典题总结/","link":"","permalink":"https://perfectsymphony.github.io/2020/10/12/JS%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84%E7%BB%8F%E5%85%B8%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"常用的数组方法和字符串方法: 1、查找元素在数组中的位置 12345678910111213141516171819202122232425// 方法一function indexof(arr, item)&#123; if(Array.prototype.indexof)&#123; //判断浏览器是否支持indexof方法 return arr.indexof(item) &#125; else &#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i] === item)&#123; return i &#125; &#125; &#125; return -1;&#125;//方法二function indexof(arr, item)&#123; if(Array.prototype.indexof)&#123; return arr.indexof(item) &#125; else if(arr.indexof(item) &gt; 0) &#123; return arr.indexof(item) &#125; else &#123; return -1 &#125;&#125; Array.prototype.indexOf: indexof()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法： 12arr.indexOf(searchElement) //查找searchElement元素在数组中的第一个位置arr.indexOf(searchElement[, fromIndex = 0]) //从fromIndex开始查找searchElement元素在数组中的第一个位置 还有另外一个查找字符串的方法String.prototype.indexOf() 1str.indexOf(searchValue[, fromIndex]) searchValue：一个字符串表示被查找的值。 fromIndex（可选）：数字表示开始查找的位置。可以是任意整数，默认值为 0。如果 fromIndex 的值小于 0，或者大于 str.length ，那么查找分别从 0 和str.length 开始。（译者注： fromIndex 的值小于 0，等同于为空情况； fromIndex 的值大于或等于 str.length ，那么结果会直接返回 -1 。）举个例子，&#39;hello world&#39;.indexOf(&#39;o&#39;, -5) 返回 4 ，因为它是从位置0处开始查找，然后 o 在位置4处被找到。另一方面，&#39;hello world&#39;.indexOf(&#39;o&#39;, 11) （或 fromIndex 填入任何大于11的值）将会返回 -1 ，因为开始查找的位置11处，已经是这个字符串的结尾了。 详细可查看MDN 2、添加元素(末尾添加) Array.slice() 123456789101112131415161718192021222324252627// 方法一 普通的for循环拷贝+pushfunction append(arr, item)&#123; let resArr = [] for(let i = 0;i &lt; arr.length; i++)&#123; resArr.push(arr[i]); &#125; resArr.push(item) return resArr&#125;// 方法二 使用concat将传入的数组或非数组值与原数组合并 组成一个新的数组并返回function append(arr, item)&#123; return arr.concat(item)&#125;// 方法三 使用slice浅拷贝+pushfunction append(arr, item)&#123; let newArr = arr.slice(0) // slice(start, end)浅拷贝数组 newArr.push(item); return newArr;&#125;// 方法四 `...`扩展运算符function append(arr, item)&#123; let resArr = [...arr, item]; return resArr;&#125; 3、移除数组中的元素(返回原数组) 123456789101112131415161718192021// 方法一 普通for循环+splicefunction removeWithoutCopy(arr, item)&#123; for(let i = arr.length; i &gt;= 0; i--)&#123; if(arr[i] == item)&#123; arr.splice(i, 1); &#125; &#125; return arr;&#125;//方法二 方法一的另外一种写法//在这里要注意在删除掉一个元素时，要i-，即删除这个元素后，其他的位置往前移function removeWidthoutCopy(arr, item)&#123; for(let i = 0; i&lt; arr.length; i++)&#123; if(arr[i] == item)&#123; arr.splice(i, 1); i--; &#125; &#125; return arr&#125; 4、移除数组中的元素(返回新的数组) —– 把第3题稍微变一下 filter 12345678910111213141516171819202122232425262728293031323334353637383940// 方法一 filter过滤function remove(arr, item)&#123; return arr.filter(res =&gt; &#123; return res != item &#125;)&#125;// 方法二 for循环 + pushfunction remove(arr, item)&#123; let resArr = [] for(let i = 0; i &lt; arr.length; i++)&#123; if(arr[i] !== item)&#123; resArr.push(arr[i]) &#125; &#125; return resArr&#125;//方法三 forEach + push (效率高于for循环)function remove(arr, item)&#123; let resArr = [] arr.forEach(v =&gt; &#123; if(v !== item)&#123; resArr.push(v) &#125; &#125;) return resArr&#125;// 方法四 forEach + pushfunction remove(arr, item)&#123; let resArr = arr.slice(0); resArr.forEach((v, i) =&gt; &#123; if(v == item)&#123; resArr.splice(i, 1); i-- &#125; &#125;) return resArr;&#125; 5、数组求和 123456789101112131415161718192021222324252627282930313233// 方法一 普通for循环function sum(arr)&#123; let res = 0; for(let i = 0; i &lt; arr.length; i++)&#123; res += arr[i] &#125;return res&#125;//方法二 forEach循环function sum(arr)&#123; let res = 0; arr.forEach((value, index, array) =&gt; &#123; array[index] = value; res += value &#125;) return res&#125;//方法三 reducereduce()接收一个函数作为累加器，数组中的每个值(从左至右)开始缩减，最终计算为一个值function sum()&#123; return arr.reduce((pre, cur) =&gt; &#123; return pre + cur; &#125;)&#125;//方法四 eval// eval()可计算某个字符串，并执行其中的JavaScript代码function sum()&#123; return eval(arr.join(&#x27;+&#x27;))&#125; 6、删除数组中的最后一个元素 1234567891011//方法一 slicefunction truncate(arr)&#123; return arr.slice(0, arr.length - 1)&#125;//方法二 concat/slice + popfunction truncate(arr)&#123; let resArr = arr.concat(); resArr.pop() return resArr&#125; 7、添加元素(开头添加) 12345678// concat/slice/arr.join.split(&#x27;,&#x27;)+unshiftfunction prepend(arr, item)&#123; // let resArr = arr.slice(0) // let resArr = arr.concat() let resArr = arr.join().slice(&#x27;,&#x27;) resArr.unshift(item) return resArr&#125; 8、删除数组中的第一个元素 12345function curtail()&#123; let resArr = arr.slice(0); resArr.shift() return resArr&#125; 9、合并数组 123456789101112131415161718//方法一 concatfunction concat(arr1, arr2)&#123; let resArr = arr1.concat(arr2) return resArr&#125;//方法二 ...扩展运算符function concat(arr1, arr2)&#123; let resArr = [...arr1, ...arr2]; return resArr&#125;// 方法三 slice + push.apply()function concat(arr1, arr2)&#123; let resArr = arr1.slice(0); [].push.apply(resArr, arr2); return resArr&#125; 10、添加元素(指定位置添加) 123456789101112131415161718192021//方法一 先复制前0～index个元素，将item元素插入之后，再拼接index之后的元素function insert(arr, item, index)&#123; let resArr = arr.slice(0, index); resArr.push(item) resArr = resArr.concat(arr.slice(index)) return resArr&#125;//方法二 使用splice方法插入(效率更高)function insert(arr, item, index)&#123; let resArr = arr.slice(0); resArr.splice(index, 0, item)&#125;// 方法三 push.apply + splicefunction insert(arr, item, index)&#123; let resArr = [] [].push.apply(resArr, arr) resArr.splice(index, 0, item) return resArr&#125; 计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一 普通for循环function count(arr, item)&#123; let resConut = 0; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i] === item)&#123; resCount++ &#125; &#125; return resCount&#125;// 方法二 forEachfunction count(arr, item)&#123; let resCount = 0; arr.forEach(v =&gt; &#123; if(v == item)&#123; resCount++ &#125; &#125;) return resCount&#125;// 方法三 filterfunction count(arr, item)&#123; let res = arr.filter(v =&gt; &#123; return v === item &#125;) return res.length&#125;//方法四 map(效率高于filter)function count(arr, item)&#123; let resCount = 0 arr.map(v =&gt; &#123; if(v === item)&#123; resCount++ &#125; &#125;) return resCount&#125;// 方法五 reducefunction count(arr, item)&#123; let res = arr.reduce((init, curr) =&gt; &#123; // 如果当前值等于item，该函数值加1 return curr === item ? init + 1 : init &#125;, 0) return res;&#125; 查找重复元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 方法一 for/for in/ + sort先进行排序，然后判断排序的前一个数据是否等于后一个数据，如果是且结果数组没有这个元素//for 运行时间：1596ms 占用内存：77772kfunction duplicates(arr)&#123; let resArr = [] arr.sort() for(let i = 0; i &lt; arr.length; i++)&#123; if(arr[i] == arr[i - 1] &amp;&amp; resArr.indexof(arr[i]) == -1)&#123; resArr.push(arr[i]) &#125; &#125; return resArr&#125;//for in 运行时间：1132ms占用内存：77868kfunction duplicates(arr)&#123; let resArr = [] arr.sort() for(let i in arr)&#123; if(arr[i] == arr[i - 1] &amp;&amp; resArr.indexof(arr[i]) == -1)&#123; resArr.push(arr[i]) &#125; &#125; return resArr&#125;// 方法二 forEach利用索引判断是否重复(使用两次)// 运行时间：1184ms 占用内存：77772kfunction duplicates(arr)&#123; let resArr = []; arr.forEach(v =&gt; &#123; // 判断原数组是否有重复数据 // 判断结果数组是否已经具有该数据 if(arr.indexof(v) != arr.lastIndexof(v) &amp;&amp; resArr.indexof(v) == -1)&#123; resArr.push(v) &#125; &#125;) return resArr&#125;// 方法三 reduce先判断数组中元素出现的次数，如果大于1并且结果数组之前无此元素，则将这个元素放在结果数组中// 运行时间：1129ms 占用内存：77776kfunction duplicates(arr)&#123; let b = [] let resArr = [] for(let i = 0; i &lt; arr.length; i++)&#123; b[i] = arr.reduce((init, curr) =&gt; &#123; //如果当前置等于item，该函数值加一 return curr === arr[i] ? init + 1 : init; &#125;, 0) if(b[i] &gt; 1 &amp;&amp; resArr.indexof(arr[i]) == -1)&#123; resArr.push(arr[i]); &#125; &#125; return resArr;&#125; 13、求二次方为什么用for … in? 123456789101112131415161718192021222324252627// for/forEach/map// 运行时间：1466ms 占用内存：77772kfunction square(arr)&#123; var res = [] for(var i in arr)&#123; res.push(arr[i]*arr[i]); &#125; return res;&#125;// forEach 运行时间：1130ms 占用内存：77772kfunction square(arr)&#123; let resArr = [] arr.forEach((e) =&gt; &#123; resArr.push(e*e) &#125;) return resArr&#125;// 运行时间：1433ms 占用内存：78004kfunction square(arr) &#123; //let resArr = arr.slice(0); let resArr = arr.map((e,index,array)=&gt;&#123; return e*e; &#125;); return resArr;&#125; 14、查找元素位置 123456789101112131415161718192021222324// 方法一 for//运行时间：1139ms 占用内存：77772kfunction findAllOccurrences(arr, target)&#123; let resArr = [] for(let i = 0; i &lt; arr.length; i++)&#123; if(arr[i] === target)&#123; resArr.push(i) &#125; &#125; return resArr&#125;// 方法二 forEach// 运行时间：1135ms 占用内存：77776kfunction findAllOccurrences(arr, target)&#123; let resArr = [] arr.forEach((v, index) =&gt; &#123; if(v === target)&#123; resArr.push(index) &#125; &#125;) return resArr&#125; 15、避免全局变量 原代码： 1234567function globals() &#123; myObject = &#123; name : &#x27;Jory&#x27; &#125;; return myObject;&#125; 修复： 123456function globals()&#123; let myObject = &#123; name: &#x27;Jory&#x27; &#125; return myObject;&#125; 16、正确的函数定义 原代码： 123456789function functions(flag) &#123; if (flag) &#123; function getValue() &#123; return &#x27;a&#x27;; &#125; &#125; else &#123; function getValue() &#123; return &#x27;b&#x27;; &#125; &#125; return getValue();&#125; 修复：else中的语句相当于将if中的function重写，因此无论flag为何值，返回的方法始终为重写后的方法。将方法赋值给一个变量，方法就不会被重写，因此才能得到正确的结果。并且只能用var声明。 12345678function functions(flag) &#123; if (flag) &#123; var getValue = function () &#123; return &#x27;a&#x27;; &#125; &#125; else &#123; var getValue = function () &#123; return &#x27;b&#x27;; &#125; &#125; return getValue();&#125; 17、正确的使用 parseInt 原代码： 123function parse2Int(num) &#123; return parseInt(num);&#125; 修复：parseInt(string, radix) 函数可解析一个字符串，并返回一个整数。参数 radix 表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，parseInt() 会根据 string 来判断数字的基数。举例，如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。而本题则是要求解析为十进制的整数。 123function parse2Int(num) &#123; return parseInt(num,10);&#125; 注意： 1.只有字符串中的第一个数字会被返回。2.如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN。3.如果参数 radix 小于 2 或者大于 36，则 parseInt() 将返回 NaN。 18、完全等同 1234567function identity(val1, val2)&#123; if(val1 === val2)&#123; return true; &#125; else &#123; return false; &#125;&#125; 19、计时器 1234567891011121314151617function count(start, end)&#123; //立即输出第一个值 console.log(start++) var timer = setInterval(function()&#123; if(start &lt;= end)&#123; console.log(start++); &#125; else &#123; clearInterval(timer); &#125; &#125;, 100) // 返回一个对象 return &#123; cancel: function()&#123; clearInterval(timer); &#125; &#125;&#125; setInterval(code,millisec) 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。code 是要调用的函数或要执行的代码串，millisec 是周期性执行或调用 code 之间的时间间隔，以毫秒计。setInterval() 方法会不停地调用 code 函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。clearInterval() 方法可取消由 setInterval() 设置的 timeout，其中的参数必须是由 setInterval() 返回的 ID 值。 20、流程控制 12345678910111213function fizzBuzz(num)&#123; if(num%3 == 0 &amp;&amp; num%5 == 0)&#123; return &#x27;fizzbuzz&#x27;; &#125; else if(num%3 == 0)&#123; return &#x27;fizz&#x27;; &#125; else if(num%5 == 0)&#123; return &#x27;buzz&#x27; &#125; else if(num == null || typeof num != &#x27;number&#x27;)&#123; return false &#125; else &#123; return num &#125;&#125; 21、函数传参 1234567891011121314151617181920212223242526// 方法一 apply/callfunction argsAsArray(fn, arr)&#123; return fn(arr[0], arr[1], arr[2])&#125;function argsAsArray(fn, arr)&#123; return fn.apply(fn, arr)&#125;// 或者function argsAsArray(fn, arr)&#123; return fn.apply(this, arr)&#125;function argsAsArray(fn, arr)&#123; return fn.call(fn, arr[0],arr[1], arr[2])&#125;// 或者function argsAsArray(fn, arr)&#123; return fn.call(this, arr[0], arr[1], arr[2])&#125;//方法二 使用扩展运算符function argsAsArray(fn, arr)&#123; return fn(...arr)&#125; function.apply(newObj[, argsArray]) 方法修改指定函数的调用对象。function是调用对象将被修改的函数，newObj是函数的新调用对象，argsArray是传递给function函数的参数，数组或者arguments对象。 apply 方法是将传递给函数的参数放入一个数组中，传入参数数组即可。 function.call(newObj[, arg1[, arg2[, [,…argN]]]]) 方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 22、函数上下文 考察改变this的指向 1234567891011function speak(fn, obj)&#123; return fn.apply(obj)&#125;function speak(fn, obj)&#123; return fn.call(obj)&#125;function speak(fn, obj)&#123; return fn.bind(obj)()&#125; 23、返回函数 12345function functionFunction(str)&#123; return f = function(obj)&#123; return str +&#x27;,&#x27;+ obj &#125;&#125; 24、使用闭包 12345678function makeClosure(arr, fn)&#123; let result = [] for(let i of arr)&#123; result.push(() =&gt; &#123; return fn(i) &#125;) &#125;&#125; 25、二次封装函数 12345function partial(fn, str1, str2)&#123; return result = function(str3)&#123; return fn(str1, str2, str3) &#125;&#125; 26、使用arguments 12345678910111213//方法一 evalfunction useArguments()&#123; let arr = Array.prototype.call(arguments) //把arguments类数组转化为数组 return eval(arr.join(&#x27;+&#x27;))&#125;//方法二：reduce+call组合function useArguments()&#123; let result = Array.prototype.reduce.call(arguments, (a, b) =&gt; &#123; return a + b &#125;) return result;&#125; 27、使用 apply 调用函数 同21题 123function callIt(fn)&#123; return fn.apply(this, [].slice.call(arguments, 1))&#125; [].slice.call(arguments, 1) 28、二次封装函数 与25题的要求区别: 入门级别 123456789function partialUsingArguments(fn)&#123; //先获取p函数第一个参数之后的全部参数 let args = [].slice.call(arguments, 1); //声明result函数 return result = function()&#123; //使用concat合并两个或多个数组中的元素 return fn.apply(this, args.concat([].slice.call(arguments))); &#125;&#125; 29、柯里化 123456789101112function curryIt(fn)&#123; var args = []; var result = function(arg)&#123; args.push(arg); if(args.length &lt; fn.length)&#123; return result; &#125; else &#123; return fn.apply(this, args); &#125; &#125; return result&#125; 30、或运算 123function or(a, b) &#123; return (a || b);&#125; 31、且运算 123function and(a, b) &#123; return (a &amp;&amp; b);&#125; 32、模块 12345678910function createModule(str1, str2)&#123; let obj = &#123; greeting: str1, name: str2, sayIt: function()&#123; return obj.greeting + &#x27;&#x27; + obj.name; &#125; &#125; return obj;&#125; 33、二进制转换(十进制转二进制) 1234function valueAtBit(num, bit)&#123; let res = num.toString(2); return res[res.length - bit]&#125; NumberObject.toString(radix) 可以把一个Number对象转换为一个字符串，并返回数字的字符串表示。radix 表示数字的基数，为 2 ~ 36 之间的整数。若省略该参数，则默认使用基数 10。例如，当 radix 为 2 时，NumberObject 会被转换为二进制值表示的字符串。 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 通过num.toString(2)能直接将num转换为2进制数格式的字符串，利用下标就能将对应值取出来。题目返回的数字是从右往左，因此下标为倒数。 34、二进制转换(二进制转十进制) 123function base10(str)&#123; return parseInt(str, 2);&#125; 35、二进制转换(十进制转8位二进制) 1234567function convertToBinary(num)&#123; let res = num.toString(2); while(res.length &lt; 8)&#123; return &#x27;0&#x27; + res &#125; return res&#125; 36、乘法 12345678910111213function multiply(a, b)&#123; // 先将数字转换为字符串 let str1 = a.toString(); let str2 = b.toString(); // 获取两个数的小数位数 let lenA = (str1.indexOf(&#x27;.&#x27;) == -1) ? 0 : (str1.length - str1.indexOf(&#x27;.&#x27;) - 1); let lenB = (str2.indexOf(&#x27;.&#x27;) == -1) ? 0 : (str2.length - str2.indexOf(&#x27;.&#x27;) - 1); // 比较两数的精度/位数，精度大的作为结果数精度 let len = Math.max(lenA,lenB); // 运算结果 let result = parseFloat(a*b).toFixed(len) return result&#125; toFixed(num):toFixed() 方法可把 Number 四舍五入为指定小数位数的数字; 参数num: 代表小数位数； 1let num = 5.56789; num.toFixed(2); ==&gt;5.57 parseFloat(string): parseFloat()函数可解析一个字符串，并返回一个浮点数；参数 string 可为数字可为字符串，当参数为字符串时，判断个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，如果不是，返回NAN； 12parseFloat(&quot;43ar4s2&quot;)；==&gt;43 parseFloat(&quot;qwar4s2&quot;)；==&gt;NAN 37、改变上下文 12345function alterContext(fn, obj) &#123; //return fn.call(obj); //return fn.apply(obj); return fn.bind(obj)();&#125; 38、批量改变对象的属性 123function alterObjects(constructor, greeting) &#123; constructor.prototype.greeting = greeting;&#125; prototype 属性可以向对象添加属性和方法。这是原型链的知识：当查找一个对象的方法或者是属性时，首先会在该对象中寻找，如果找到则返回如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则返回undefined。将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量，只需要在constructor的原型上面添加greeting属性，并指定值。 39、属性遍历 12345678910//运行时间：1148ms 占用内存：77864kfunction iterate(obj)&#123; let result = [] for(let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; result.push(key + &#x27;:&#x27;+&#x27;&#x27;obj[key]);//使用obj.key部分代码不能通过 &#125; &#125; return result;&#125; 所有继承了 Object 的对象都会继承到 hasOwnProperty() 方法。obj.hasOwnProperty(prop)方法会返回一个布尔值，指示对象 obj 自身属性中是否具有指定的属性 prop 。这个方法可以用来检测一个对象是否含有特定的自身属性，并忽略掉那些从原型链上继承到的属性。 1234567//方法二 map//运行时间：1133ms 占用内存：77828kfunction iterate(obj)&#123; return Object.getOwnPropertyNames(obj).map(key =&gt; &#123; return key +&quot;:&quot;+obj[key] &#125;)&#125; Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。 Object.getOwnPropertyNames() 123456789// 方法三 forEachfunction iterate(obj)&#123; let arr = Object.keys(obj); let resArr = []; arr.forEach(item =&gt; &#123; resArr.push(item + &quot;:&quot; +obj[item]) &#125;) return resArr&#125; 最后5题大部分可以用正则表达式实现，关于正则表达式可以看看 正则表达式不要背 40、判断是否包含数字 String.prototype.charCodeAt() 123456789101112131415161718192021222324252627282930313233343536373839//方法一 正则test/matchfunction containsNumber(str)&#123; // return /\\d/.test(str) return !!str.match(/\\d/g);&#125;//方法二 遍历function containsNumber(str)&#123; for(let i = 0; i &lt; 10; i++)&#123; if(str.indexOf(i) != -1)&#123; return true; &#125; &#125; return false;&#125;//方法三：for循环 + charCodeAt()function containsNumber(str)&#123; let res = str.split(&#x27;&#x27;); for(let i = 0; i &lt; res.length; i++)&#123; let temp = res[i].charCodeAt(); if(temp &gt;= 48 &amp;&amp; temp &lt;= 57)&#123; return true; &#125; &#125; return false;&#125; //方法四：for循环+Number()function containsNumber(str)&#123; let res = str.split(&#x27;&#x27;) for(let i = 0; i &lt; res.length; i++)&#123; let temp = Number(res[i]) if(temp)&#123; return true; &#125; &#125; return false;&#125; 41、检查重复字符串 (String.prototype.charAt())[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charAt] 123function containsRepeatingLetter(str)&#123; return /([a-zA-Z])\\1/.test(str);&#125; 在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\\1就是引用第一个分组，\\2就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。 12345678910// 字符串方法function containsRepeatingLetter(str)&#123; let reg = /[a-zA-Z]/; for(let i = 0; i &lt; str.length; i++)&#123; if(str.charAt(i) == str.charAt(i+1) &amp;&amp; reg.test(str[i]))&#123; return true &#125; &#125; return false&#125; 42、判断是否以元音字母结尾 首先确定元音集合[a,e,i,o,u]，然后是以元音结尾，加上 $ ，最后通配大小写，加上i。 1234function endsWithVowel(str)&#123; return /[a,e,i,o,u]$/i.test(str); // return /(a|o|e|i|u)$/gi.test(str)&#125; 43、获取指定字符串 12345678910function captureThreeNumbers(str)&#123; //声明一个数组保存匹配的字符串结果 let arr = str.match(/\\d&#123;3&#125;/) // 如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr)&#123; return arr[0] &#125; else &#123; return false &#125;&#125; 44、判断是否符合指定格式 12345function matchesPattern(str)&#123; return /^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;/.test(str);&#125;本题需要注意格式，开头 ^ 和结尾 $ 必须加上来限定字符串，3个数可表示为\\d&#123;3&#125;，4个数则为\\d&#123;4&#125;，&#123;n&#125;表示前面内容出现的次数。正则表达式可写作 /^ \\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$ / ，有相同部分\\d&#123;3&#125;-，因此也可写作 /^(\\d&#123;3&#125;-)&#123;2&#125;\\d&#123;4&#125;$/。 45、判断是否符合 USD 格式 12345678910111213141516171819function isUSD(str) &#123; return /^\\$\\d&#123;1,3&#125;(,\\d&#123;3&#125;)*(\\.\\d&#123;2&#125;)?$/.test(str);&#125;? 匹配前面一个表达式0次或者1次。等价于 &#123;0,1&#125;。例如，/e?le?/ 匹配 &#x27;angel&#x27; 中的 &#x27;el&#x27;，和 &#x27;angle&#x27; 中的 &#x27;le&#x27; (注意第二个 ? 前面的匹配表达式是 e 而不是 le) 以及 &#x27;oslo&#x27; 中的&#x27;l&#x27;。如果紧跟在任何量词 *、 +、? 或 &#123;&#125; 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 &quot;123abc&quot; 应用 /\\d+/ 将会返回 &quot;123&quot;，如果使用 /\\d+?/,那么就只会匹配到 &quot;1&quot;。还可以运用于向前断言 正向肯定查找x(?=y) 和 正向否定查找x(?!y) 。* 匹配前一个表达式0次或多次。等价于 &#123;0,&#125;。例如，/bo*/会匹配 &quot;A ghost boooooed&quot; 中的 &#x27;booooo&#x27; 和 &quot;A bird warbled&quot; 中的 &#x27;b&#x27;, 但是在 &quot;A goat grunted&quot; 中将不会匹配任何东西。. (小数点)匹配 除了换行符（\\n）之外的任何单个字符。例如, /.n/将会匹配&quot;nay, an apple is on the tree&quot;中的&#x27;an&#x27;和&#x27;on&#x27;, 但是不会匹配 &#x27;nay&#x27;。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"JS基础(初级)","slug":"JS基础","date":"2020-09-29T10:00:03.000Z","updated":"2020-12-23T09:14:22.000Z","comments":true,"path":"2020/09/29/JS基础/","link":"","permalink":"https://perfectsymphony.github.io/2020/09/29/JS%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、手写冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142let arr = [0, 2, 8, 7, 3, 9, 1, 4, 8];// 方式一：function BubbleSort(arr)&#123; for(let i = 0; i &lt; arr.length - 1; i++)&#123; for(let j = 0; j &lt; arr.length - 1; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; let temp; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;// 方式二：function BubbleSort(arr)&#123; for(let i = 0; i &lt; arr.length; i++)&#123; for(let j = 1; j &lt; arr.length - i - 1; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; let temp; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;// 方式三：function BubbleSort(arr)&#123; for(let i = 0; i &lt; arr.length; i++)&#123; for(let j = 0; j &lt; arr.length - i - 1; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 二、快速排序：利用二分法和递归实现快速排序： 123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length == 0) return [] //利用Math.floor()方法向下取整找到中间位置 let Index = Math.floor(arr.length / 2); //再用splice()方法将数组中间位置的元素取出来 let c = arr.splice(Index, 1); let l = []; let r = []; for(let i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &lt; c)&#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; // 从左至右，从小到大 return quickSort(l).concat(c, quickSort(r)); // 从左至右，从大到小 return quickSort(r).concat(c, quickSort(l));&#125; 三、 按照数组中的对象属性进行比较排序四、事件帧听器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var EventUtil = &#123; addEvent:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type,handler); &#125;else&#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeEvent:function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot; + type,handler); &#125;else&#123; element[&quot;on&quot; + type] = null; &#125; &#125;, getEvent:function()&#123; return event ? event: window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125; &#125;, stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble(); &#125; &#125;&#125;//调用方法var btn = document.getElementById(&quot;myBtn&quot;);var handler = function()&#123; event = EventUtil.getEvent(); EventUtil.preventDefault(); alert(&quot;Clicked&quot;);&#125;;EventUtil.addEvent(btn,click,handler); 五、数据类型1、基本数据类型：undefined、Null、String、Boolean、Number 2、数据封装对象：Object、Array、Boolean、Number、String3、其他对象：Math、Date、Function、Error、RegExp、Arguments 六、闭包1、定义：指有权访问另一个函数作用域中变量的函数。 1234567function parentFunc()&#123; var a = 1; function childFunc()&#123; console.log(a); &#125; return childFunc();&#125; 2、闭包的特征：&lt;1&gt;函数内再嵌套函数；&lt;2&gt;内部函数可以调用外部函数的参数和变量；&lt;3&gt;参数和变量不会被垃圾回收机制回收。 闭包的好处：能够实现封装和缓存。使用闭包主要是为了封装对象的私有属性和私有方法，闭包可以避免全局变量的污染。 闭包的缺点：闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏。 闭包经典问题： 1234567891011function parentFunc()&#123; var arr = []; for(var i = 0;i &lt; 5;i++)&#123; arr[i] = function ()&#123; return i; &#125; &#125; return arr;&#125;console.log(parentFunc()[0]()); //5console.log(parentFunc()[1]()); //5 这里就展现出了几个关键信息，首先分析一下代码：循环中创建了一个匿名函数并将其赋值给arr数组中对应索引的元素，匿名函数作用是返回i值。此时，arr数组中存放的是匿名函数，而匿名函数还没有执行。当调用parentFunc()函数时返回arr数组，再单独执行数组中的元素保存的匿名函数，此时循环已经执行完，所以i值为5。接下来再去调用其它数组元素中的匿名函数也样会获得数值5。要解决这个闭包所产生的问题，有两种办法：&lt;1&gt;立即执行匿名函数 12345678910function parentFunc()&#123; var arr = []; for(var i = 0;i&lt;5;i++)&#123; arr[i] = (function ()&#123; return i; &#125;)(); &#125; return arr;&#125;console.log(parentFunc()); //[0,1,2,3,4] &lt;2&gt;使用let关键字声明变量:使用let声明变量会形成块级作用域 12345678910function parentFunc()&#123; var arr = []; for(let i = 0;i&lt;5;i++)&#123; arr[i] = function ()&#123; return i; &#125;; &#125; return arr;&#125;console.log(parentFunc()[0]()); //0 七、作用域、原型、原型链、继承1、JS作用域：分为全局作用域和函数作用域全局作用域，代码在程序中的任何地方都能访问，window对象的内置属性都拥有全局作用域；函数作用域，在固定的代码片段才能访问。 2、作用域链：作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 3、原型和原型链：每个对象都会在其内部初始化一个属性-prototype（原型）。当我们访问一个对象的属性时，如果这个对象的内部不存在这个属性，就会去prototype中查找这个属性，这个prototype又会有自己的prototype，于是就会像链条一样一直找下去形成原型链。（因为所有的对象都是由Object对象继承而来，因此最终查找到Object的prototype结束） 4、继承：实现继承的常用方法是原型链+借用构造函数。原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name = name;&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;var p1 = new SubType(&quot;老王&quot;, 70);var p2 = new SubType(&quot;小王&quot;, 20);p1.sayName(); //老王p2.sayName(); //小王p1.sayAge(); //70p2.sayAge(); //20 八、组件化、模块化1、组件化：利用组件化思想将多个页面都需要用的功能组件封装起来，提高代码复用性，降低耦合性，增强可维护性和可读性。 2、模块化：主要用途是封装对象模块化的优点：避免全局变量污染，命名冲突；提高代码复用率；提高了可维护性。最常用的模块化封装对象的方法是：构造函数模式+原型模式。构造函数内写属性，原型中放方法和重写构造函数指针。 12345678910111213141516function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;老王&quot;, 70);var person2 = new Person(&quot;小王&quot;, 20);alert(person1.name === person2.name); //false,构造函数内属性不公用alert(person1.sayName === person2.sayName); //true,原型中的方法共用 组合使用构造函数模式和原型模式封装对象的好处在于，每个新建的实例都拥有自己的属性，然后共同享有原型中的方法，不用每次创建新实例都重新创建同样的方法。 九、ajax&lt;1&gt;如何创建一个ajax 12345678910111213141516171819//get方法var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;,&quot;example.php&quot;,true); //发送的请求类型、请求的URL、是否异步发送请求xhr.send(null);xhr.onreadystatechange= function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; success(xhr.responseText); &#125;else&#123; console.log(xhr.status); &#125; &#125;&#125;//post方法var data = new FormData(document.forms[0]);xhr.open(&quot;post&quot;,&quot;example.php&quot;,true);xhr.send(data); &lt;2&gt;同步和异步的区别：同步：用户请求，等待，响应，刷新页面展示内容再操作；异步：用户请求的同时可继续对页面操作，响应完成不刷新页面展示新内容。&lt;3&gt;Ajax优点：异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；Ajax缺点：异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持&lt;4&gt;post一般用于修改服务器上的资源，对发送的数据没有限制；而get一般用于请求获取数据。 十、其他1、事件代理：事件代理又称之为事件委托，是绑定事件的常用技巧。即把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能，节省内存占用，减少事件注册。可以实现当新增子对象时无需再对其绑定。比如在table上代理td的click事件。 2、this对象：·this总是指向函数的直接调用者（而非间接调用者）；·如果有new关键字，this指向new出来的新对象·在事件中，this指向触发这个事件的对象，但IE中的attachEvent中的this指向window对象。 3、事件模型：·冒泡型事件：当你使用事件冒泡时，子元素先触发，父元素后触发；·捕获型事件：当你使用事件捕获时，父元素先触发，子元素后触发；·DOM事件流：同时支持两种事件模型，冒泡型事件和捕获型事件；·阻止冒泡：阻止事件冒泡。在w3c中使用stopPropagation()方法，在IE中使用cancelBubble = true；·阻止捕获：阻止事件的默认行为。在w3c中使用preventDefault()方法，在IE中使用returnValue = false。 4、XML和JSON的区别：·JSON相对XML，数据体积更小，传递速度更快些；·JSON与JS的交互更方便，更容易解析处理，更好的数据交互；·JSON对数据的描述性比XML较差；·JSON的传输速度远远快于XML。 5、eval()的作用：把对应的字符串解析成可执行的JS代码并运行；应该避免使用eval()，不安全且非常耗性能。 6、Null和Undefined的区别：undefined表示声明的变量未赋值，而null表示声明变量的值为空值；两者相比较时要使用===，因为==无法区分。 7、[“1”, “2”, “3”].map(parseInt) 答案是多少？[1,NaN.NaN]。因为parseInt的参数时(val,radix)，radix表示基数（多少进制），而map的参数是(function(currentValue,index,arr),thisIndex)。所以map传了三个参数给parseInt，radix对应index不合法导致解析失败。详细参考的使用技巧案例8、JSON与字符串的转换： 字符串转换为JSON 123var obj = eval(&#x27;(&#x27; + str + &#x27;)&#x27;);var obj = str.parseJSON();var obj = JSON.parse(str); //最常用 JSON转换为字符串 12var str = obj.toJSONString();var str = JSON.stringify(obj); 9、attribute和property的区别：attribute是DOM元素再文档中作为html标签拥有的属性；property是DOM元素再JS中作为对象所拥有的属性； 10、如何判断一个对象是否为数组： 123456function isArray()&#123; if(typeof obj === &#x27;object&#x27;)&#123; return Object.prototype.toString.call(obj) === &#x27;[Object Array]&#x27;; &#125; return false&#125; 10、map、foreach、reduce 间的区别？ 如何形象地解释 JavaScript 中 map、foreach、reduce 间的区别？ 十一、promise1、 123456789101112131415161718new Promise(function(resolve,reject)&#123; console.log(&quot;promise start...&quot;); var timeout = Math.random()*2; //0-2 console.log(&quot;set timeout to：&quot; + timeout + &quot;seconds&quot;); setTimeout(function()&#123; if(timeout &lt; 1)&#123; console.log(&quot;call resolve()...&quot;); resolve(&quot;200 ok&quot;); &#125;else&#123; console.log(&quot;call reject()...&quot;); reject(&quot;timeout in&quot; + timeout + &quot;seconds&quot;); &#125; &#125;,timeout * 1000);&#125;).then(function(resolve)&#123; console.log(&quot;Done：&quot; + resolve);&#125;).catch(function(reject)&#123; console.log(&quot;Failed：&quot; + reject)&#125;); 可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了。 2、任何任务失败则不再继续并执行错误处理函数。要串行执行这样的异步任务，不需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： 1234567891011121314151617181920212223function multi(input)&#123; return new Promise(function(resolve,reject)&#123; console.log(&#x27;计算 &#x27; + input + &#x27; x &#x27; + input + &#x27;...&#x27;); setTimeout(resolve,500, input * input); &#125;);&#125;function add(input)&#123; return new Promise(function(resolve,reject)&#123; console.log(&#x27;计算 &#x27; + input + &#x27; + &#x27; + input + &#x27;...&#x27;); setTimeout(resolve,500,input + input); &#125;);&#125;var p = new Promise(function(resolve,reject)&#123; console.log(&quot;start ....&quot;); resolve(33);&#125;);p.then(multi) .then(add) .then(multi) .then(add) .then(function(result)&#123; console.log(&quot;结果：&quot; + result); &#125;); 十二、事件循环 JS是一门单线程的非阻塞的脚本语言，单线程意味着JS在执行代码的任何时候，都只有一个主线程来处理所有任务。 事件循环流程图： 同步和异步任务分别进入不同的执行场所，同步任务进入主线程，异步任务进入Event table并注册函数；当指定的事件完成时，Event table会将这个函数移入事件队列Event queue中；主线程的任务执行完毕为空，会去Event queue读取对应的函数，进入主线程中执行；上述的过程不断重复，也就是我们说的事件循环Event loop。 举个例子说明他们的执行顺序： 12345console.log(&quot;1&quot;);setTimeout(function()&#123; console.log(&quot;2&quot;);&#125;,0);console.log(&quot;3&quot;); //输出结果为：1,3,2 因为setTimeout是异步任务，其他两个console同步任务按顺序执行，所以setTimeout最后输出。 微任务和宏任务，结合例子说明： 123456789101112131415console.log(&#x27;1&#x27;); setTimeout(() =&gt; &#123; console.log(&#x27;2&#x27;) &#125;, 1000); new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;3&#x27;); &#125;, 0); console.log(&#x27;4&#x27;); resolve(); console.log(&#x27;5&#x27;); &#125;).then(() =&gt; &#123; console.log(&#x27;6&#x27;); &#125;); console.log(&#x27;7&#x27;); //执行结果为1,4,5,7,6,3,2 先来说明下什么是微任务和宏任务，他们都是异步的任务，且都属于队列，区别在于微任务先于宏任务执行。（有一点歧义，之后再说） 宏任务包含有：setTimeout、setInterval、setImmediate、I/O、UI rendering;微任务包含有：process.nextTick()、promise.then、MutationObserver;补充一点 new promise会同步执行。 在执行到new Promise的时候会立马新建一个promise对象并立即执行。所以会输出 1,4,5,7，而then则会在Event Table中注册成回调函数并放在微任务队列中，而两个setTimeout(输出3)和setTimeout(输出2，1s后完成)会被先后注册成回调函数并放在宏任务队列中。 复杂测试题理解程度（分清宏任务和微任务，画出队列执行顺序理解）： 12345678910111213141516171819202122232425262728console.log(1)process.nextTick(() =&gt; &#123; console.log(8) setTimeout(() =&gt; &#123; console.log(9) &#125;)&#125;)setTimeout(() =&gt; &#123; console.log(2) new Promise(() =&gt; &#123; console.log(11) &#125;)&#125;)let promise = new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(10) &#125;) resolve() console.log(4)&#125;)fn()console.log(3)promise.then(() =&gt; &#123; console.log(12)&#125;)function fn()&#123; console.log(6)&#125; //输出结果：1,4,6,3,8,12,2,11,10,9 按顺序执行，同步任务先执行，再到微任务和宏任务，其内部包含的亦是如此。 promise+event loop的题目(链式调用插队问题): 123456789101112131415161718192021222324new Promise((resolve,reject)=&gt;&#123; console.log(&quot;promise1&quot;) resolve()&#125;).then(()=&gt;&#123; console.log(&quot;then11&quot;) new Promise((resolve,reject)=&gt;&#123; console.log(&quot;promise2&quot;) resolve() &#125;).then(()=&gt;&#123; console.log(&quot;then21&quot;) &#125;).then(()=&gt;&#123; console.log(&quot;then23&quot;) &#125;)&#125;).then(()=&gt;&#123; console.log(&quot;then12&quot;)&#125;)new Promise((resolve,reject)=&gt;&#123; console.log(&quot;promise3&quot;) resolve()&#125;).then(()=&gt;&#123; console.log(&quot;then31&quot;)&#125;) //输出结果：[promise1,promise3,then11,promise2,then31,then21,then12,then23] async await + event loop + promise题目: 1234567891011121314151617181920212223242526async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);&#125;async function async2() &#123; console.log( &#x27;async2&#x27;);&#125;console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;settimeout&quot;);&#125;,0);async1();new Promise(function (resolve) &#123; console.log(&quot;promise1&quot;); resolve();&#125;).then(function () &#123; console.log(&quot;promise2&quot;);&#125;);console.log(&#x27;script end&#x27;);// [script start,async1 start,async2,promise1,script end,async1 end,promise2,settimeout] async/await仅仅影响的是函数内的执行，而不会影响到函数体外的执行顺序。也就是说async1()并不会阻塞后续程序的执行，await async2()相当于一个Promise，console.log(&quot;async1 end&quot;);相当于前方Promise的then之后执行的函数。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"谈谈对闭包的理解","slug":"谈谈对闭包的理解","date":"2020-09-28T09:32:33.000Z","updated":"2020-11-12T12:03:23.000Z","comments":true,"path":"2020/09/28/谈谈对闭包的理解/","link":"","permalink":"https://perfectsymphony.github.io/2020/09/28/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"1、定义闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包常用的方式是在一个函数中创建另一个函数，通过另一个函数访问这个函数的局部变量 2、特性 函数嵌套函数 在函数内部可以引用外部的参数和变量 参数和变量不会以垃圾回收机制回收 3、优点 设计私有的方法和变量 利用闭包可以读取函数内部的变量，变量在函数外部不能直接读取到，从而达到保护变量安全的作用。因为私有方法在函数内部都能被访问到，从而实现了私有属性和方法的共享。1234567891011121314151617181920212223242526var Counter = (function() &#123;//私有属性var privateCounter = 0; //私有方法function changeBy(val) &#123; privateCounter += val;&#125;return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125;&#125; &#125;)();console.log(privateCounter); //privateCounter is not defined console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 在jQuery框架的私有方法和变量也是这么设计的12345678910111213var $ = jQuery = function()&#123; return jQuery.fn.init();&#125;jQuery.fn = jQuery.prototype = &#123; init:function()&#123; return this; //this指向jQuery.prototype &#125;, length: 1, size: function()&#123; return this.length; &#125;&#125;console.log($().size()); // 1 将处理结果缓存1234567891011121314151617var mult = (function()&#123; var cache = &#123;&#125;; var calculate = function()&#123; var a = 1; for(vari=0,l=arguments.length;i&lt;l;i++)&#123; a = a*arguments[i]; &#125; return a; &#125;; return function()&#123; var args = Array.prototype.join.call(arguments,&#x27;,&#x27;); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = calculate.apply(null,arguments); &#125;&#125;)(); 4、缺点 闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在JavaScript中，函数即闭包，只有函数才会产生作用域。 当返回的函数为匿名函数时，注意匿名函数中的this指的是window对象。 5、什么是内存泄漏？内存泄漏（Memory Leak）是指不再用到的内存，没有及时释放。 6、JavaScript垃圾回收机制原理解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。现在各大浏览器通常采用的垃圾回收机制有两种方法：标记清除，引用计数。 标记清除： js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为”进入环境”，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境”。 12345function test()&#123; var a = 10; //被标记&quot;进入环境&quot; var b = &quot;hello&quot;; //被标记&quot;进入环境&quot;&#125;test(); //执行完毕后之后，a和b又被标记&quot;离开环境&quot;，被回收 垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数： 语言引擎有一张”引用表”，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。 12const arr = [1,2,3,4];console.log(&quot;hello world&quot;); 上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存。如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。 123let arr = [1,2,3,4];console.log(&quot;hello world&quot;);arr = null; 上面代码中，arr重置为null，就解除了对[1，2，3，4]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用 7、内存泄漏的识别方法怎样可以观察到内存泄漏呢？ 如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 1、浏览器Chrome 浏览器查看内存占用，按照以下步骤操作。 1、打开开发者工具，选择 Timeline 面板 2、在顶部的Capture字段里面勾选 Memory 3、点击左上角的录制按钮。 4、在页面上进行各种操作，模拟用户的使用情况。 5、一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。 2、命令行命令行可以使用 Node 提供的process.memoryUsage方法。 12345console.log(process.memoryUsage());// &#123; rss: 27709440,// heapTotal: 5685248,// heapUsed: 3449392,// external: 8772 &#125; process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。 1、rss（resident set size）：所有内存占用，包括指令区和堆栈。 2、heapTotal：”堆”占用的内存，包括用到的和没用到的。 3、heapUsed：用到的堆的部分。 4、external： V8 引擎内部的 C++ 对象占用的内存。 判断内存泄漏，以heapUsed字段为准。 WeakMap前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。 ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。 下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。 1234567const wm = new WeakMap(); const element = document.getElementById(&#x27;example&#x27;); wm.set(element, &#x27;some information&#x27;);wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 WeakMap 示例根据这个思路 首先，打开 Node 命令行。 1$ node --expose-gc 上面代码中，–expose-gc参数表示允许手动执行垃圾回收机制。 然后，执行下面的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 手动执行一次垃圾回收，保证获取的内存使用状态准确&gt; global.gc(); undefined // 查看内存占用的初始状态，heapUsed 为 4M 左右&gt; process.memoryUsage(); &#123; rss: 21106688, heapTotal: 7376896, heapUsed: 4153936, external: 9059 &#125; &gt; let wm = new WeakMap();undefined &gt; let b = new Object();undefined &gt; global.gc();undefined // 此时，heapUsed 仍然为 4M 左右&gt; process.memoryUsage(); &#123; rss: 20537344, heapTotal: 9474048, heapUsed: 3967272, external: 8993 &#125; // 在 WeakMap 中添加一个键值对，// 键名为对象 b，键值为一个 5*1024*1024 的数组 &gt; wm.set(b, new Array(5*1024*1024));WeakMap &#123;&#125; // 手动执行一次垃圾回收&gt; global.gc();undefined // 此时，heapUsed 为 45M 左右&gt; process.memoryUsage(); &#123; rss: 62652416, heapTotal: 51437568, heapUsed: 45911664, external: 8951 &#125; // 解除对象 b 的引用 &gt; b = null;null // 再次执行垃圾回收&gt; global.gc();undefined // 解除 b 的引用以后，heapUsed 变回 4M 左右// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了&gt; process.memoryUsage(); &#123; rss: 20639744, heapTotal: 8425472, heapUsed: 3979792, external: 8956 &#125; 上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。 扩展更深入一些的讲解 没有被引用的对象就是垃圾，就是要被清除。 其他的算法参考这里","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"webpack性能优化——DLL","slug":"webpack性能优化——DLL","date":"2020-09-27T09:05:03.000Z","updated":"2020-09-27T09:19:42.000Z","comments":true,"path":"2020/09/27/webpack性能优化——DLL/","link":"","permalink":"https://perfectsymphony.github.io/2020/09/27/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94DLL/","excerpt":"","text":"Webpack性能优化的方式有很多种，本文之所以将 dll 单独讲解，是因为 dll 是一种最简单粗暴并且极其有效的优化方式。 在通常的打包过程中，你所引用的诸如：jquery、bootstrap、react、react-router、redux、antd、vue、vue-router、vuex 等等众多库也会被打包进 bundle 文件中。由于这些库的内容基本不会发生改变，每次打包加入它们无疑是一种巨大的性能浪费。 Dll 的技术就是在第一次时将所有引入的库打包成一个 dll.js 的文件，将自己编写的内容打包为 bundle.js 文件，这样之后的打包只用处理 bundle 部分。 以 Vue 项目为例，首先创建一个名为 webpack.dll.config.js 的文件 123456789101112131415161718192021222324252627var path = require(&quot;path&quot;), fs = require(&#x27;fs&#x27;), webpack = require(&quot;webpack&quot;);var vendors = [ &#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;vuex&#x27;];module.exports = &#123; entry: &#123; vendor: vendors &#125;, output: &#123; path: path.join(__dirname, &quot;dist&quot;), filename: &quot;Dll.js&quot;, library: &quot;[name]_[hash]&quot; &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, &quot;dist&quot;, &quot;manifest.json&quot;), name: &quot;[name]_[hash]&quot;, context: __dirname &#125;) ]&#125;; 这个文件的作用是将 vue、vue-router 以及 vuex 合并打包为一个名为 Dll.js 的静态资源包，同时生成一个 manifest.json 文件方便对 Dll.js 中的模块进行引用。 要注意的是，执行 webpack 命令是默认执行该目录下名为 webpack.config.js 或者 webpackfile.js 的文件。所以需要通过 –config 指令手动指定该文件，最后加入 -p 指令将 Dll.js 压缩。 1$ webpack --config webpack.dll.config.js -p 这样，在项目根目录下就会多增加一个 dist 文件夹，其中有压缩之后的 Dll.js 与 manifest.json 文件。 manifest.json 文件内容如下，给各个模块赋予 id 以便引用。 1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;vendor_2beb750db72b1cda4321&quot;, &quot;content&quot;: &#123; &quot;./node_modules/process/browser.js&quot;: &#123; &quot;id&quot;: 0, &quot;meta&quot;: &#123;&#125; &#125;, &quot;./node_modules/vue-router/dist/vue-router.esm.js&quot;: &#123; &quot;id&quot;: 1, &quot;meta&quot;: &#123; &quot;harmonyModule&quot;: true &#125;, &quot;exports&quot;: [ &quot;default&quot; ] &#125;, &quot;./node_modules/vue/dist/vue.runtime.esm.js&quot;: &#123; &quot;id&quot;: 2, &quot;meta&quot;: &#123; &quot;harmonyModule&quot;: true &#125;, &quot;exports&quot;: [ &quot;default&quot; ] &#125;,//....... 最后在 webpack.config.js 中添加引用。在 plugins 属性中添加 DllReferencePlugin 插件，并指明 manifest.json 文件的引用路径。 1234567//...plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require(&#x27;./dist/manifest.json&#x27;) &#125;)] 在确保成功执行 webpack.dll.config.js 文件后，执行 webpack -p 进行项目打包。 可以看到打包在 Dll 文件中的文件都被delegated(委派)，而不是直接打进 bundle 文件中 这样我们就将所有的资源完成打包，生成的 dist 目录如下： 不过 dist 文件夹要想作为一个完整的工程还少一个 html 文件，我创建了一个名为 pack.js 的文件，使用 nodejs 的 fileSystem 对 html 文件进行修改并拷贝。 pack.js: 12345678910111213141516171819202122var fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;./index.html&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (!err) &#123; var dataStr = data.toString(), timestamp = (new Date()).getTime(); dataStr = dataStr .replace(&#x27;bundle.js&#x27;, &#x27;bundle.js?v=&#x27;+timestamp) .replace(&#x27;&lt;!-- dll --&gt;&#x27;, &#x27;&lt;script src=&quot;./dist/Dll.js?v=&#x27;+ timestamp +&#x27;&quot;&gt;&lt;/script&gt;&#x27;); fs.writeFile(&#x27;./dist/index.html&#x27;, dataStr, (error) =&gt; &#123; if (!error) &#123; console.log(&#x27;HTML file copy successfully&#x27;); &#125; else &#123; console.log(error); &#125; &#125;); &#125; else &#123; console.log(err); &#125;&#125;); 我们需要在模块的入口 html 中添加 &lt;!-- dll --&gt; 的占位字符，pack.js 的作用就是将 html 文件拷贝一份到 dist 目录下，同时将 替换为引用 Dll.js 的 script 标签，并在引用文件后添加时间戳。 12345678&lt;!-- .... --&gt;&lt;body&gt;&lt;div id=&quot;demo&quot; class=&quot;container&quot;&gt;&lt;/div&gt;&lt;!-- dll --&gt;&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在执行 webpack -p 打包后，输入下面命令运行 pack.js，就会在 dist 目录下生成 html 文件。 1$ node pack.js 内容如下： 12345678&lt;!-- .... --&gt;&lt;body&gt;&lt;div id=&quot;demo&quot; class=&quot;container&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./dist/Dll.js?v=1488250309725&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./bundle.js?v=1488250309725&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样 dist 文件夹就作为一个完整的、不需要任何手动操作、已经压缩混淆后的项目可以直接进行线上的部署。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://perfectsymphony.github.io/tags/webpack/"}]},{"title":"CSS相关面试题","slug":"CSS相关面试题","date":"2020-09-15T08:59:17.000Z","updated":"2020-11-21T09:33:02.000Z","comments":true,"path":"2020/09/15/CSS相关面试题/","link":"","permalink":"https://perfectsymphony.github.io/2020/09/15/CSS%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"一、使一个盒子水平居中目前有4种方式: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;style&gt;/* 宽度/高度已知 */.box&#123; width: 400px; height: 200px; position: relative; background: #f00;&#125;.inner-box &#123; width: 200px; height: 100px; position: absolute; background: #ff0; top: 50%; left: 50%; margin-left: -100px; margin-top: -50px;&#125;/* 第二种方式 */.box &#123; width: 500px; height: 300px; background: #f00; position: relative;&#125;.inner-box &#123; width: 100px; height: 50px; background: #ff0; position:absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto;&#125;/* flex布局 */.box &#123; width: 400px; height: 200px; background: #f00; display: flex; /* 实现水平居中 */ justify-content: center; /* 实现垂直居中 */ align-items: center;&#125;.inner-box &#123; width: 200px; height: 100px; background: #ff0;&#125;/* 平移 定位+transform (宽度、高度未知时，上下左右居中) */.box &#123; width: 400px; height: 200px; background: #f00; position: relative;&#125;.inner-box &#123; /* width: 200px; height: 100px; */ background:#f90; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;dov class=&quot;inner-box&quot;&gt; content &lt;/dov&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二、盒模型1、盒模型分为标准盒模型和怪异盒模型(IE盒模型) 标准盒模型：盒模型的宽高只是内容的宽高；怪异盒模型：盒模型的宽高是内容(content) + 填充(padding) +边框(border)的总宽度。 现代浏览器和IE9+默认值是content-box。 2、CSS如何设置两种模型 12345# 标准盒模型box-sizing: content-box;# IE 模型border-sizing: border-box; 最终盒子实际所占位置大小计算公式是这样的： 盒子所占位置的实际宽度=宽度+左填充+右填充+左边框+右边框+左边界+右边界 盒子所占位置的实际高度=高度+顶部填充+底部填充+上边框+下边框+上边界+下边界 要注意区分的是盒子所占位置的实际宽度高度值和盒子实际大小的宽度和高度值，盒子实际大小的宽度和高度是所占位置实际宽度高度的值减去边界（margin）所占的大小，即 盒子的实际宽度=宽度+左填充+右填充+左边框+右边框 盒子的实际高度=高度+顶部填充+底部填充+上边框+下边框 盒子模型的3D示意图，如下图所示，padding与margin是看不见的透明元素 从第一层到第五层依次为：border、content+padding、background-image、background-color、margin。 例如一个盒子的 margin 为 20px，border 为 1px，padding 为 10px,content 的宽为 200px、高为50px假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为： 123宽 20*2+1*2+10*2+200=262px、高20*2+1*2*10*2+50=112px盒子的实际大小为：宽1*2+10*2+200=222px、高1*2+10*2+50=72px 假如用ie 盒子模型，那么这个盒子需要占据的位置为： 123宽 20*2+200=240px、高20*2+50=70px盒子的实际大小为：宽 200px、高 50px 浏览器兼容问题由于IE浏览器使用自己的非标准模型。IE浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。解决IE8及更早版本不兼容问题可以在HTML页面声明 即可。就是要在网页的顶部加上DOCTYPE声明。 二、实现三栏布局(两侧定宽，中间自适应) 1234567891011121314151617181920212223242526272829&lt;style&gt; /* flex方式实现 */ .box &#123; display: flex; # justify-content: center; height: 200px; &#125; .left &#123; width: 200px; background: #f00; height: 100%; &#125; .center &#123; background: #f90; flex: 1; &#125; .right &#123; width: 200px; background: #ff0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930&lt;style&gt; /* 浮动方式，此方式 content 必须放在最下边 */ .box &#123; height: 200px; &#125; .left &#123; width: 200px; background: #f00; height: 100%; float: left; &#125; .center &#123; background: #f90; height: 100%; &#125; .right &#123; width: 200px; float: right; height: 100%; background: #ff0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; /* 绝对定位的方式实现 */ .box &#123; position: relative; height: 200px; &#125; .left &#123; width: 200px; background: #f00; height: 100%; position: absolute; left: 0; &#125; .center &#123; background: #f90; height: 100%; position: absolute; left: 200px; right: 200px; &#125; .right &#123; width: 200px; height: 100%; position: absolute; right: 0; background: #ff0; &#125; /* */&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324&lt;style&gt; /* grid网格布局 */ .box &#123; display: grid; grid-template-columns: 200px auto 200px; grid-template-rows: 200px; &#125; .left &#123; background: #f00; &#125; .center &#123; background: #f90; &#125; .right &#123; background: #ff0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 只要一行代码实现CSS五种经典布局 这几个布局都是自适应的，自动适配桌面设备和移动设备。代码实现很简单，核心代码只有一行，有很大的学习价值，内容也很实用。我会用到 CSS 的 Flex 语法和 Grid 语法，每一个布局都带有 CodePen 示例。 一、空间居中布局空间居中布局指的是，不管容器的大小，项目总是占据中心点。 CSS代码如下(CodePen 示例) 1.container &#123; display: grid; place-items: center; &#125; 上面代码需要写在容器上，指定为 Grid 布局。核心代码是place-items属性那一行，它是一个简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; align-items属性控制垂直位置，justify-items属性控制水平位置。这两个属性的值一致时，就可以合并写成一个值。所以，place-items: center;等同于place-items: center center;。 同理，左上角布局可以写成下面这样。 1place-items: start; 右下角布局: 1place-items: end; 二、并列式布局并列式布局就是多个项目并列 如果宽度不够，放不下的项目就自动折行。 它的实现也很简单。首先，容器设置成 Flex 布局，内容居中（justify-content）可换行（flex-wrap）。 1.container &#123; display: flex; flex-wrap: wrap; justify-content: center; &#125; 然后，项目上面只用一行flex属性就够了（CodePen 示例）。 1.item&#123; flex: 0 1 150px; margin: 5px; &#125; flex属性是flex-grow、flex-shrink、flex-basis这三个属性的简写形式。 1flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;; flex: 0 1 150px;的意思就是，项目的初始宽度是150px，且不可以扩大，但是当容器宽度不足150px时，项目可以缩小。 三、两栏式布局两栏式布局就是一个边栏，一个主栏。 下面的实现是，边栏始终存在，主栏根据设备宽度，变宽或者变窄。如果希望主栏自动换到下一行，可以参考上面的”并列式布局”。 使用 Grid，实现很容易（CodePen 示例）。 1.container &#123; display: grid; grid-template-columns: minmax(150px, 25%) 1fr; &#125; 上面代码中，grid-template-columns指定页面分成两列。第一列的宽度是minmax(150px, 25%)，即最小宽度为150px，最大宽度为总宽度的25%；第二列为1fr，即所有剩余宽度。 四、三明治布局 三明治布局指的是，页面在垂直方向上，分成三部分：页眉、内容区、页脚。 这个布局会根据设备宽度，自动适应，并且不管内容区有多少内容，页脚始终在容器底部（粘性页脚）。也就是说，这个布局总是会占满整个页面高度。 CSS 代码如下（CodePen 示例） 1.container &#123; display: grid; grid-template-rows: auto 1fr auto; &#125; 上面代码写在容器上面，指定采用 Grid 布局。核心代码是grid-template-rows那一行，指定垂直高度怎么划分，这里是从上到下分成三部分。第一部分（页眉）和第三部分（页脚）的高度都为auto，即本来的内容高度；第二部分（内容区）的高度为1fr，即剩余的所有高度，这可以保证页脚始终在容器的底部。 五、圣杯布局圣杯布局是最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。 这里的实现是，不管页面宽度，内容区始终分成三栏。如果宽度太窄，主栏和右边栏会看不到。如果想将这三栏改成小屏幕自动堆叠，可以参考并列式布局。 CSS 代码如下（CodePen 示例） 1.container &#123; display: grid; grid-template: auto 1fr auto / auto 1fr auto; &#125; 上面代码要写在容器上面，指定采用 Grid 布局。核心代码是grid-template属性那一行，它是两个属性grid-template-rows（垂直方向）和grid-template-columns（水平方向）的简写形式。 1grid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; grid-template-rows和grid-template-columns都是auto 1fr auto，就表示页面在垂直方向和水平方向上，都分成三个部分。第一部分（页眉和左边栏）和第三部分（页脚和右边栏）都是本来的内容高度（或宽度），第二部分（内容区和主栏）占满剩余的高度（或宽度）。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"ES6中的Set和Map","slug":"ES6中的Set和Map","date":"2020-09-03T07:24:31.000Z","updated":"2020-09-03T08:02:00.000Z","comments":true,"path":"2020/09/03/ES6中的Set和Map/","link":"","permalink":"https://perfectsymphony.github.io/2020/09/03/ES6%E4%B8%AD%E7%9A%84Set%E5%92%8CMap/","excerpt":"","text":"Mapmap对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。 Set和Map区别：set是一种关联式容器，其特性如下： set以RBTree作为底层容器 所得元素的只有key没有value，value就是key 不允许出现键值重复 所有的元素都会被自动排序 不能通过迭代器来改变set的值，因为set的值就是键 map和set一样是关联式容器，它们的底层容器都是红黑树，区别就在于map的值不作为键，键和值是分开的。它的特性如下： map以RBTree作为底层容器 所有元素都是键+值存在 不允许键重复 所有元素是通过键进行自动排序的 map的键是不能修改的，但是其键对应的值是可以修改的 Map和Object的区别 一个Object的键只能是字符串或者Symbols，但一个Map的键可以是任意值。 Map中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。 Map的键值对个数可以从size属性获取，而 Object的键值对个数只能手动计算。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。 Map对象的属性 size：返回Map对象中所包含的键值对个数 Map对象的方法 set(key, val): 向Map中添加新元素 get(key): 通过键值查找特定的数值并返回 has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false delete(key): 通过键值从Map中移除对应的数据 clear(): 将这个Map中的所有元素删除 12345678910const m1 = new Map([[&#x27;a&#x27;, 111], [&#x27;b&#x27;, 222]])console.log(m1) // &#123;&quot;a&quot; =&gt; 111, &quot;b&quot; =&gt; 222&#125;m1.get(&#x27;a&#x27;) // 111const m2 = new Map([[&#x27;c&#x27;, 3]])const m3 = new Map(m2)m3.get(&#x27;c&#x27;) // 3m3.has(&#x27;c&#x27;) // truem3.set(&#x27;d&#x27;, 555)m3.get(&#x27;d&#x27;) // 555 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627282930313233const map = new Map([[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]])for (let key of map.keys()) &#123; console.log(key)&#125;// &quot;a&quot;// &quot;b&quot;for (let value of map.values()) &#123; console.log(value)&#125;// 1// 2for (let item of map.entries()) &#123; console.log(item)&#125;// [&quot;a&quot;, 1]// [&quot;b&quot;, 2]// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value)&#125;// &quot;a&quot; 1// &quot;b&quot; 2// for...of...遍历map等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value)&#125;// &quot;a&quot; 1// &quot;b&quot; 2 map与其他数据结构的互相转换 map转换为数组（使用扩展运算符） 123const arr = [[&#123;&#x27;a&#x27;: 1&#125;, 111], [&#x27;b&#x27;, 222]]const myMap = new Map(arr)[...myMap] // map转数组。 Map与对象的互换 123456const obj = &#123;&#125;const map = new Map([&#x27;a&#x27;, 111], [&#x27;b&#x27;, 222])for(let [key,value] of map) &#123; obj[key] = value&#125;console.log(obj) // &#123;a:111, b: 222&#125; JSON字符串要转换成Map可以先利用JSON.parse()转换成数组或者对象，然后再转换即可 SetSet对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。Set函数可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数，用来初始化。 Set中的特殊值Set对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复 undefined 与 undefined 是恒等的，所以不重复 NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复 Set实例对象的属性 size：返回Set实例的成员总数。 Set实例对象的方法 add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。 delete(value)：删除某个值，删除成功返回true，否则返回false。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 123456const mySet = new Set([&#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, 1, 2, 1])console.log(mySet) // &#123;&#x27;a&#x27;, &#x27;b&#x27;, 1, 2&#125;myset.add(&#x27;c&#x27;).add(&#123;&#x27;a&#x27;: 1&#125;)console.log(mySet) // &#123;&#x27;a&#x27;, &#x27;b&#x27;, 1, 2, &#x27;c&#x27;, &#123;a: 1&#125;&#125;console.log(mySet.size) // 6mySet.has(2) // true 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回键值对的遍历器。 forEach()：使用回调函数遍历每个成员。 由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 1234567891011121314151617181920212223242526272829303132333435const set = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])for (let item of set.keys()) &#123; console.log(item)&#125;// a// b// cfor (let item of set.values()) &#123; console.log(item)&#125;// a// b// cfor (let item of set.entries()) &#123; console.log(item)&#125;// [&quot;a&quot;, &quot;a&quot;]// [&quot;b&quot;, &quot;b&quot;]// [&quot;c&quot;, &quot;c&quot;]// 直接遍历set实例，等同于遍历set实例的values方法for (let i of set) &#123; console.log(i)&#125;// a// b// cset.forEach((value, key) =&gt; console.log(key + &#x27; : &#x27; + value))// a: a// b: b// c: c Set 对象作用 数组去重(利用扩展运算符) 12const mySet = new Set([1, 2, 3, 4, 4])[...mySet] // [1, 2, 3, 4] 合并两个set对象 123let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])let union = new Set([...a, ...b]) // &#123;1, 2, 3, 4&#125; 交集 123let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])let intersect = new Set([...a].filter(x =&gt; b.has(x))) // &#123;2, 3&#125; 利用数组的filter方法 差集 123let a &#x3D; new Set([1, 2, 3])let b &#x3D; new Set([4, 3, 2])let difference &#x3D; new Set([...a].filter(x &#x3D;&gt; !b.has(x))) &#x2F;&#x2F; &#123;1&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"uni-app利用rich-text展示富文本内容,图片的宽度溢出屏幕","slug":"uni-app利用rich-text展示富文本内容-图片的宽度溢出屏幕","date":"2020-09-02T09:45:02.000Z","updated":"2020-09-07T12:34:05.000Z","comments":true,"path":"2020/09/02/uni-app利用rich-text展示富文本内容-图片的宽度溢出屏幕/","link":"","permalink":"https://perfectsymphony.github.io/2020/09/02/uni-app%E5%88%A9%E7%94%A8rich-text%E5%B1%95%E7%A4%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9-%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%BD%E5%BA%A6%E6%BA%A2%E5%87%BA%E5%B1%8F%E5%B9%95/","excerpt":"","text":"一、在App.vue组件中（h5），直接在App.vue修改即可 123uni-rich-text img &#123; max-with: 100% !important;&#125; 二、在小程序里面展示富文本内容，图片的宽度溢出屏幕的问题。 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;rich-text :nodes=&quot;infos.content | formatRichText&quot;&gt;&lt;/rich-text&gt; &lt;/template&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, components: &#123;&#125;, onLoad(option) &#123;&#125;, filters: &#123; /** * 处理富文本里的图片宽度自适应 * 1.去掉img标签里的style、width、height属性 * 2.img标签添加style属性：max-width:100%;height:auto * 3.修改所有style里的width属性为max-width:100% * 4.去掉&lt;br/&gt;标签 * @param html * @returns &#123;void|string|*&#125; */ formatRichText (html) &#123; let newContent= html.replace(/&lt;img[^&gt;]*&gt;/gi,function(match,capture)&#123; match = match.replace(/style=&quot;[^&quot;]+&quot;/gi, &#x27;&#x27;).replace(/style=&#x27;[^&#x27;]+&#x27;/gi, &#x27;&#x27;); match = match.replace(/width=&quot;[^&quot;]+&quot;/gi, &#x27;&#x27;).replace(/width=&#x27;[^&#x27;]+&#x27;/gi, &#x27;&#x27;); match = match.replace(/height=&quot;[^&quot;]+&quot;/gi, &#x27;&#x27;).replace(/height=&#x27;[^&#x27;]+&#x27;/gi, &#x27;&#x27;); return match; &#125;); newContent = newContent.replace(/style=&quot;[^&quot;]+&quot;/gi,function(match,capture)&#123; match = match.replace(/width:[^;]+;/gi, &#x27;max-width:100%;&#x27;).replace(/width:[^;]+;/gi, &#x27;max-width:100%;&#x27;); return match; &#125;); newContent = newContent.replace(/&lt;br[^&gt;]*\\/&gt;/gi, &#x27;&#x27;); newContent = newContent.replace(/\\&lt;img/gi, &#x27;&lt;img style=&quot;max-width:100%;height:auto;display:inline-block;margin:10rpx auto;&quot;&#x27;); return newContent; &#125; &#125;, methods: &#123;&#125; &#125;","categories":[],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://perfectsymphony.github.io/tags/uni-app/"}]},{"title":"解决JavaScript中0.1+0.2不等于0.3的问题","slug":"解决JavaScript中0-1-0-2不等于0-3问题","date":"2020-08-24T09:59:12.000Z","updated":"2020-08-24T10:04:02.000Z","comments":true,"path":"2020/08/24/解决JavaScript中0-1-0-2不等于0-3问题/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/24/%E8%A7%A3%E5%86%B3JavaScript%E4%B8%AD0-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3%E9%97%AE%E9%A2%98/","excerpt":"","text":"此问题主要是考察对JavaScript的理解层度。 在正常的数学逻辑思维中，0.1+0.2=0.3这个逻辑是正确的，但是在JavaScript中0.1+0.2！==0.3。 在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为false。 解决办法： 设置一个误差范围值，通常称为”机器精度“，而对于Javascript来说，这个值通常是2^-52,而在ES6中，已经为我们提供了这样一个属性：Number.EPSILON，而这个值正等于2^-52。这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true。 12345function numbersequal(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON;&#125; var a=0.1+0.2， b=0.3;console.log(numbersequal(a,b)); //true 完美的兼容写法： 123456789101112Number.EPSILON=(function()&#123; //解决兼容性问题 return Number.EPSILON?Number.EPSILON:Math.pow(2,-52); &#125;)();//上面是一个自调用函数，当JS文件刚加载到内存中，就会去判断并返回一个结果，相比if(!Number.EPSILON)&#123; // Number.EPSILON=Math.pow(2,-52); //&#125;这种代码更节约性能，也更美观。function numbersequal(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON; &#125;//接下来再判断 var a=0.1+0.2, b=0.3;console.log(numbersequal(a,b)); //这里就为true了 这个是二进制浮点数最大的问题（不仅JavaScript，所有遵循IEEE 754规范的语言都是如此）。 注意：有人认为，JavaScript应该采用一种可以精确呈现数字的实现方式。一直以来出现过很多替代方案，只是都没能成为标准，以后大概也不会。这个问题看似简单，实则不然，否则早就解决了。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"js基本数据类型有哪些，有什么区别？","slug":"js基本数据类型有哪些，有什么区别？","date":"2020-08-24T09:42:15.000Z","updated":"2020-08-24T09:52:13.000Z","comments":true,"path":"2020/08/24/js基本数据类型有哪些，有什么区别？/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/24/js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/","excerpt":"","text":"一、JavaScript的数据类型： 1、基本数据类型有这五种: Undefined、Null、String、Number、Boolean 2、引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。引用类型值指那些可能为多个值构成的对象。 3、引用类型有这几种：object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)。 二、基本类型和引用类型的区别 1、基本类型的变量是存放在栈区的（栈区指内存里的栈内存）； 2、引用类型的值是同时保存在栈内存和堆内存中的对象； 3、基本类型的比较是值的比较； 4、引用类型的比较是引用的比较； 三、什么是栈内存，什么是堆内存，两者有什么区别？ 栈内存：由程序自动向操作系统申请分配以及回收，速度快，使用方便，但程序员无法控制。若分配失败，则提示栈溢出错误。注意，const局部变量也储存在栈区内，栈区向地址减小的方向增长。 堆内存：程序员向操作系统申请一块内存，当系统收到程序的申请时，会遍历一个记录空闲内存地址的链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。分配的速度较慢，地址不连续，容易碎片化。此外，由程序员申请，同时也必须由程序员负责销毁，否则则导致内存泄露。 四、关于堆和栈区别的比喻： 堆和栈的区别可以引用一位前辈的比喻来看出：使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-08-02T11:10:20.000Z","updated":"2020-08-24T09:01:35.000Z","comments":true,"path":"2020/08/02/两数之和/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和给定一个整数数组nums和一个目标值target,请你在该数组中找出和为目标值的那个两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例: 12345给定 nums = [2, 7, 11, 15], target = 9因为num[0] + num[1] = 2 + 7 = 9所以，返回[0,1] 解题方法: 1、暴力法 使用两层循环，外层循环计算当前元素与target之间的差值，内循环寻找该差值，若找到该差值，则返回两个元素的下标 时间复杂度: O(n^2) 123456789101112131415/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */ var twoSum = function(nums, target)&#123; for(var i = 0; i&lt; nums.length; j++&gt;)&#123; var dif = target - nums[i]; /* j = i + 1 的目的是减少重复计算和避免两个元素下标相同 */ for(var j = i + 1; j &lt; nums.length; j++)&#123; if(nums[j] == dif) return [i, j]; &#125; &#125; &#125; 2、利用数组减少查询时间 在暴力法中，内层循环查找差值很浪费时间，那么如何减少查询时间呢？利用数组就可以减少查询时间。 使用一层循环，每遍历到一个元素就计算该元素与target之间的差值dif，然后以dif为下标到数组temp中寻找，如果temp[dif]有值(即不是undefined)，则返回两个元素在数组nums的下标，如果没有找到，则将当前元素存入数组temp中(下标:nums[i],value:i)。 时间复杂度: O(n) 123456789101112131415/*** @param &#123;number[]&#125; nums* @param &#123;number&#125; target* @return &#123;number[]&#125;*/var twoSum = function(nums, target)&#123; var temp = []; for(var i = 0; i &lt; nums.length; i++&gt;)&#123; var dif = target-nums[i]; if(temp[dif] != undefined)&#123; return [temp[dif], i]; &#125; temp[nums[i]] = i; &#125;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://perfectsymphony.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"时间复杂度和空间复杂度如何计算？","slug":"时间复杂度和空间复杂度如何计算？","date":"2020-08-02T11:08:11.000Z","updated":"2020-08-24T09:02:17.000Z","comments":true,"path":"2020/08/02/时间复杂度和空间复杂度如何计算？/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F/","excerpt":"","text":"时间复杂度和空间复杂度如何计算推导算法：大O推导法1231、用常数1取代运行时间中的所有加法常数2、在修改后的运行次数函数中，只保留最高阶项 3、如果最高阶项存在且不是1，那么我们就去除于这个项相乘的常数。 时间复杂度定义在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n}=0(f(n))。它表示随问题规模n的增大，算法执行时间的埔长率和 f(n)的埔长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f( n)是问题规横n的某个函数。 常数阶12345678910111213141516171819202122232425262728293031323334void main()&#123; func();&#125;void func()&#123; int i=0;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次&#125;/*共执行了4次，所以时间复杂度为O(4);根据大O推导法，略去常数，所以此函数的时间复杂度为O(1);*///假如func变成如下结构void func()&#123; int i=0;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次 i++;//执行1次&#125;/*共执行了13次，时间复杂度为O(13);根据大O推导法，略去常数，所以此函数的时间复杂度仍然为O(1);*/ 线性阶1234567891011121314151617181920212223242526void main()&#123; for(int i=0;i&lt;n;i++) &#123; func(); &#125;&#125;void func()//时间复杂度为O(1)的函数&#123; printf(&quot;大O推导法&quot;);//执行1次&#125;/*在main中，func共被执行了n次，所以main的时间复杂度为O(n);*///加入main函数被修改成如下void main()&#123; for(int i=0;i&lt;n;i++) &#123; func(); func(); &#125;&#125;/*在main中，func共被执行了2n次，main的时间复杂度为O(2n);根据大O推导法，略去常数系数，所以main的时间复杂度仍为为O(n);*/ 对数阶123456789101112131415void main()&#123; for(int i=1;i&lt;n;i++) &#123; func(); i=2i; &#125;&#125;void func()//时间复杂度为O(1)的函数&#123; printf(&quot;大O推导法&quot;);//执行1次&#125;/*在main中，因为i每次被乘2，所以，执行的算法为 2的几次相乘 大于 n，即 2^x&gt;n,--&gt; x= log2n , 在推导对数时间复杂度时，一般都是以10作为对数的底数。 func共被执行了logn次，所以main的时间复杂度为O(logn); 平方阶123456789101112131415161718192021222324252627282930void main()&#123; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;n;j++) &#123; func(); &#125; &#125;&#125;void func()//时间复杂度为O(1)的函数&#123; printf(&quot;大O推导法&quot;);//执行1次&#125;/*在main中， func()共被执行了n^2,所以main的时间复杂度为O(n^2);*///假如main被修改成 如下void main()&#123; for(int i=1;i&lt;n;i++) &#123; for(int j=i;j&lt;n;j++) &#123; func(); &#125; &#125;&#125;/*那么， func() 执行的次数为 n+n-1+n-2+……--&gt; n(n+1)/2 = n2/2 + n/2 根据大O推导方法，保留最高阶项，n2/2 ，然后去掉这个项相乘的常数，1/2， 所以main的时间复杂度为O(n2) 小结 时间复杂度所耗费的时间是： 1O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt;O(2n) &lt; O(n!) &lt;O(nn) 参考 空间复杂度定义百度百科：空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。算法类似于时间复杂度，只是计算的不是运行次数，而是在运行过程中临时变量被运用次数。 参考","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://perfectsymphony.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"NodeJS优缺点及适用场景讨论","slug":"NodeJS优缺点及适用场景讨论","date":"2020-08-02T11:07:13.000Z","updated":"2020-08-24T09:04:31.000Z","comments":true,"path":"2020/08/02/NodeJS优缺点及适用场景讨论/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/NodeJS%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AE%A8%E8%AE%BA/","excerpt":"","text":"NodeJS宣称其目标是“旨在提供一种简单的构建可伸缩网络程序的方法”，那么它的出现是为了解决什么问题呢，它有什么优缺点以及它适用于什么场景呢？一. NodeJS的特点 它是一个Javascript运行环境 依赖于Chrome V8引擎进行代码解释 事件驱动 非阻塞I/O 轻量、可伸缩，适于实时数据交互应用 单进程，单线程 二. NodeJS带来的对系统瓶颈的解决方案 它的出现确实能为我们解决现实当中系统瓶颈提供了新的思路和方案，下面我们看看它能解决什么问题。 1. 并发连接 举个例子，想象一个场景，我们在银行排队办理业务，我们看看下面两个模型。 （1）系统线程模型： 这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达只能处理一个，其余的要先等待，这就是阻塞，正在享受服务的请求阻塞后面的请求了。 （2）多线程、线程池模型： 这个模型已经比上一个有所进步，它调节服务端线程的数量来提高对并发请求的接收和响应，但并发量高的时候，请求仍然需要等待，它有个更严重的问题。到代码层面上来讲，我们看看客户端请求与服务端通讯的过程： 服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接可能需要20M的内存。这就是为什么一般并发量一大，就需要多开服务器。 那么NodeJS是怎么解决这个问题的呢？我们来看另外一个模型，想象一下我们在快餐店点餐吃饭的场景。 （3）异步、事件驱动模型 我们同样是要发起请求，等待服务器端响应；但是与银行例子不同的是，这次我们点完餐后拿到了一个号码，拿到号码，我们往往会在位置上等待，而在我们后面的请求会继续得到处理，同样是拿了一个号码然后到一旁等待，接待员能一直进行处理。 等到饭菜做号了，会喊号码，我们拿到了自己的饭菜，进行后续的处理（吃饭）。这个喊号码的动作在NodeJS中叫做回调（Callback），能在事件（烧菜，I/O）处理完成后继续执行后面的逻辑（吃饭），这体现了NodeJS的显著特点，异步机制、事件驱动整个过程没有阻塞新用户的连接（点餐），也不需要维护已经点餐的用户与厨师的连接。 基于这样的机制，理论上陆续有用户请求连接，NodeJS都可以进行响应，因此NodeJS能支持比Java、PHP程序更高的并发量虽然维护事件队列也需要成本，再由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上去还是会力不从心。 总结一下NodeJS是怎么解决并发连接这个问题的：更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。 2. I/O阻塞 NodeJS解决的另外一个问题是I/O阻塞，看看这样的业务场景：需要从多个数据源拉取数据，然后进行处理。 （1）串行获取数据，这是我们一般的解决方案，以PHP为例 假如获取profile和timeline操作各需要1S，那么串行获取就需要2S。 （2）NodeJS非阻塞I/O，发射/监听事件来控制执行过程 NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行的，因此，拿profile的动作触发一个I/O事件，马上就会执行拿timeline的动作，两个动作并行执行，假如各需要1S，那么总的时间也就是1S。它们的I/O操作执行完成后，发射一个事件，profile和timeline，事件代理接收后继续往下执行后面的逻辑，这就是NodeJS非阻塞I/O的特点。 总结一下：Java、PHP也有办法实现并行请求（子线程），但NodeJS通过回调函数（Callback）和异步机制会做得很自然。 三. NodeJS的优缺点 优点： 高并发（最重要的优点） 适合I/O密集型应用 缺点： 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起； 解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起； 只支持单核CPU，不能充分利用CPU 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 原因：单进程，单线程 解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口； （2）开多个进程监听同一个端口，使用cluster模块； 开源组件库质量参差不齐，更新快，向下不兼容 Debug不方便，错误没有stack trace 四. 适合NodeJS的场景 RESTful API 这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。 统一Web应用的UI层 目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。 不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。 大量Ajax请求的应用 例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。 总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。 五. 结尾 其实NodeJS能实现几乎一切的应用，我们考虑的点只是适不适合用它来做。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://perfectsymphony.github.io/tags/NodeJS/"}]},{"title":"webpack相关面试题","slug":"webpack相关面试题","date":"2020-08-02T11:03:24.000Z","updated":"2020-08-24T09:05:20.000Z","comments":true,"path":"2020/08/02/webpack相关面试题/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/webpack%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1、webpack与grunt、gulp的不同？三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 所以总结一下： 从构建思路来说gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 对于知识背景来说gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路 2、与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack适用于大型复杂的前端站点构建 rollup适用于基础库的打包，如vue、react parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel 3、有哪些常见的Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 4、有哪些常见的Plugin？他们是解决什么问题的？ define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 5.Loader和Plugin的不同？不同的作用 Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。 Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 6.webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 1、初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；2、开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；3、确定入口：根据配置中的 entry 找出所有的入口文件；4、编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；5、完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；6、输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；7、输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 7.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 8.webpack的热更新是如何做到的？说明其原理？webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理： 首先要知道server端和client端都做了处理工作 1、第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。2、第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。3、第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。4、第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。5、webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。6、HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。7、而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。8、最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 9.如何利用webpack来优化前端性能？（提高性能和体验）用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现 提取公共代码。 10.如何提高webpack的构建速度？1、多入口情况下，使用CommonsChunkPlugin来提取公共代码2、通过externals配置来提取常用库3、利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。4、使用Happypack 实现多线程加速编译5、使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度6、使用Tree-shaking和Scope Hoisting来剔除多余代码 11.怎么配置单页应用？怎么配置多页应用？单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 12.npm打包时需要注意哪些？如何利用webpack来更好的构建？ Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 1、要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。2、Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。3、Npm包大小应该是尽量小（有些仓库会限制包大小）4、发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。5、UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。 基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化： 1、CommonJS模块化规范的解决方案： 设置output.libraryTarget=’commonjs2’使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用2、输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: ‘source-map’输出SourceMap以发布调试。3、Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件4、不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。5、对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下： 13.如何在vue项目中实现按需加载？Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过import()语句来控制加载时机，webpack内置了对于import()的解析，会将import()中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import()语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill 参考文章 关于 webpack 的面试题有哪些？ 前端面试之webpack面试常见问题 《深入浅出webpack》电子版 webpack 构建性能优化策略小结","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://perfectsymphony.github.io/tags/webpack/"}]},{"title":"从单页应用改造成多页应用","slug":"从单页应用改造成多页应用","date":"2020-08-02T10:58:33.000Z","updated":"2020-08-24T08:57:36.000Z","comments":true,"path":"2020/08/02/从单页应用改造成多页应用/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E4%BB%8E%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E6%94%B9%E9%80%A0%E6%88%90%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8/","excerpt":"","text":"从单页应用改造成多页应用需求再现项目A/B/C的内容是交叉的，有的页面不同，有的页面和组件是公用的，例如A项目多了个人中心及其里面所有内容（最全的一个项目，但是是放在微信中的，需要获取微信授权），B项目是通用版的项目（也就是说可以放在微信，也可以放在app内，不需要获取授权之类的。）,C项目是A/B项目中共有的一个页面功能抽取出来了。所以有的时候比如说这块功能需要调整，那么就得A/B/C三个项目关于这块的功能与页面也要一起调整。 关于动态组件这一块做的主要是配合vuex来做的。前端页面改成上述模式，具体的组件排列顺序由后台传过来，比如说请求接口的时候，告诉它这是在D页面，并且把相应的机构号6传过去，后台传给我一个组件数组，moduleList:[‘2’, ‘1’, ‘3’, ‘4’]，然后我前端的会按照moduleList里的组件顺序来动态渲染组件，之前一些父子组件传数据，在这里就变得不太适用了，所以这里的数据改用vuex存储。考虑到vuex在刷新数据丢失的问题，部分比较重要的，不想重新请求的，改用sessionStorage存储。 关于多入口多出口其实就是最开始的项目入口是App.vue和main.js，打包出来的出入口是index.html，然后现在增加了两个，我这边是增加了genneral.js和genneral.html以及single.js和single.html。 1.首先要更改vue-cli生成的webpack里的参数，声明一下我这个版本的webpack版本还是2.6.x的，比较老了，现在应该都到4.x.x了吧。 PS：路由和store记得要各自独立，因为我这里的vuex很少只涉及一两个模块。并且仅仅是传递数据之类的，所以这里没有做成独立的。 2.修改build/webpack.base.conf.js 3.修改 build/webpack.dev.conf.js 4.修改 build/webpack.prod.conf.js 5.修改 config/index.js 理一下对应关系 123main.js ==&gt; App.vue ==&gt; router/index.js A项目general.js ==&gt; general.vue ==&gt; router/general.js B项目single.js ==&gt; single.vue ==&gt; router/single.js C项目 部署的时候分三个不同的url 123xxxxx/index.html对应A项目xxxxx/general.html 对应B项目xxxxx/single.html对应C项目 至于页面中的差异，我是通过v-if来控制，A项目的D页面是否有顶部tab，B项目的D页面是否有底部footer。因为这些页面大致是一样，仅有部分微调。所以改成用v-if来控制。 大神给的demo","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"vue中的mixins","slug":"vue中的mixins","date":"2020-08-02T10:57:49.000Z","updated":"2020-08-24T09:05:08.000Z","comments":true,"path":"2020/08/02/vue中的mixins/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/vue%E4%B8%AD%E7%9A%84mixins/","excerpt":"","text":"vue中的mixins","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"vue中的router和route的区别","slug":"vue中的router和route的区别","date":"2020-08-02T10:54:44.000Z","updated":"2020-08-24T09:05:12.000Z","comments":true,"path":"2020/08/02/vue中的router和route的区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/vue%E4%B8%AD%E7%9A%84router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"vue中的$router和$route的区别一、 router是VueRouter的实例，相当于一个全局的路由器对象，里面还有好多的属性和子对象，例如history对象，经常用的跳转链接就可以用this.$router.push(), 和router-linkrouter-link跳转一样。this.$router.push()会往history栈中添加一个新的记录。详细见vue官方文档 route相当于正在跳转的路由对象。可以从里面获取name，path，params，query等。 打印this.$route和this.$router 路由传参的方式： 1、可以手写完整的path： 1this.$router.push(&#123;path:`/user/$&#123;userId&#125;`&#125;) 这样传参的话，配置路由的时候需要在path上加参数path: user/:userId这种接收参数的方式是this.$route.params.userId 2、也可以用params传参 12//命名路由router.push(&#123;name: &#x27;user&#x27;, params: &#123; userId:123 &#125;&#125;) 3、也可以用query传参 12//带查询参数，变成 /register?plan=privaterouter.push(&#123;path: &#x27;register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;) query传参是针对path的，params传参是针对name的。。接收的方式都差不多。。。this.$route.query和this.$route.params注意这只是跳转url，跳转到这个url显示什么组件，得配置路由。router跳转和标签跳转，规则差不多。 展示的话 注意：如果提供了path，params将会被忽略，但是query不属于这种情况。。。 如果使用完整路径和query传参，刷新页面时不会造成路由传参的参数丢失。 这个vue官方文档讲的很详细。 二、 有时候配置路由时path有时候会加 ‘/‘ 有时候不加,例如path:’name’和path:’/name’。区别其实官方文档说了，我当时没仔细看，导致这个问题还困扰了我很久。 意思就是以 / 开头的会被当做路径，就不会一直嵌套之前的路径。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"vue实现路由按需加载(路由懒加载)的3种方式","slug":"vue实现路由按需加载-路由懒加载-的3种方式","date":"2020-08-02T10:52:10.000Z","updated":"2020-08-24T09:05:05.000Z","comments":true,"path":"2020/08/02/vue实现路由按需加载-路由懒加载-的3种方式/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/vue%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD-%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"vue异步组件 es提案的import() webpack的require.ensure() vue异步组件技术 === 异步加载 vue-router配置路由, 使用vue的异步组件技术, 可以实现按需加载. 但是, 这种情况下一个组件生成一个js文件 1234567891011121314/* vue异步组件技术 */&#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: resolve =&gt; require([&#x27;@/components/home&#x27;],resolve)&#125;,&#123; path: &#x27;/index&#x27;, name: &#x27;Index&#x27;, component: resolve =&gt; require([&#x27;@/components/index&#x27;],resolve)&#125;,&#123; path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: resolve =&gt; require([&#x27;@/components/about&#x27;],resolve)&#125; 组件懒加载方案二 路由懒加载(使用import) 12345678910111213141516171819// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。/* const Home = () =&gt; import(&#x27;@/components/home&#x27;)const Index = () =&gt; import(&#x27;@/components/index&#x27;)const About = () =&gt; import(&#x27;@/components/about&#x27;) */// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。 把组件按组分块const Home = () =&gt; import(/* webpackChunkName: &#x27;ImportFuncDemo&#x27; */ &#x27;@/components/home&#x27;)const Index = () =&gt; import(/* webpackChunkName: &#x27;ImportFuncDemo&#x27; */ &#x27;@/components/index&#x27;)const About = () =&gt; import(/* webpackChunkName: &#x27;ImportFuncDemo&#x27; */ &#x27;@/components/about&#x27;)&#123; path: &#x27;/about&#x27;, component: About&#125;, &#123; path: &#x27;/index&#x27;, component: Index&#125;, &#123; path: &#x27;/home&#x27;, component: Home&#125; webpack提供的require.ensure()vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。 1234567891011121314/* 组件懒加载方案三: webpack提供的require.ensure() */&#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/home&#x27;)), &#x27;demo&#x27;)&#125;, &#123; path: &#x27;/index&#x27;, name: &#x27;Index&#x27;, component: r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/index&#x27;)), &#x27;demo&#x27;)&#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/about&#x27;)), &#x27;demo-01&#x27;)&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"Vue相关面试题","slug":"Vue相关面试题","date":"2020-08-02T10:47:17.000Z","updated":"2020-11-04T09:11:25.000Z","comments":true,"path":"2020/08/02/Vue相关面试题/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/Vue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"一、什么是MVVM，MVC和MVVM的区别，MVVM框架VUE实现原理? MVVM定义: MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。 【模型】指的是后端传递的数据。 【视图】指的是所看到的页面。 【视图模型】mvvm模式的核心，它是连接view和model的桥梁。 它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。 总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。MVVM流程图如下： MVC的定义：1⃣️ MVC是Model-View- Controller的简写。即模型-视图-控制器。 M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。 使用MVC的目的就是将M和V的代码分离。 ‘MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。 MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用。 由于mvc出现的时间比较早，前端并不那么成熟，很多业务逻辑也是在后端实现，所以前端并没有真正意义上的MVC模式。而我们今天再次提起MVC，是因为大前端的来到，出现了MVVM模式的框架，我们需要了解一下MVVM这种设计模式是如何一步步演变过来的。2⃣️ 为什么会有MVVM框架？ 在过去的10年中，我们已经把很多传统的服务端代码放到了浏览器中，这样就产生了成千上万行的javascript代码，它们连接了各式各样的HTML 和CSS文件，但缺乏正规的组织形式，这也就是为什么越来越多的开发者使用javascript框架。比如：angular、react、vue。浏览器的兼容性问题已经不再是前端的阻碍。前端的项目越来越大，项目的可维护性和扩展性、安全性等成了主要问题。当年为了解决浏览器兼容性问题，出现了很多类库，其中最典型的就是jquery。但是这类库没有实现对业务逻辑的分成，所以维护性和扩展性极差。综上两方面原因，才有了MVVM模式一类框架的出现。比如vue,通过数据的双向绑定，极大了提高了开发效率。3⃣️. MVVM框架:VUE的介绍Vue就是基于MVVM模式实现的一套框架， 在vue中：Model:指的是js中的数据，如对象，数组等等。 View:指的是页面视图 viewModel:指的是vue实例化对象4⃣️为什么说VUE是一个渐进式的javascript框架, 渐进式是什么意思？ 1.如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，带来更加丰富的交互体验; 2.如果你希望将更多业务逻辑放到前端来实现，那么VUE的核心库及其生态系统也可以满足你的各式需求（core+vuex+vue-route）。和其它前端框架一样，VUE允许你将一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。 3.如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成为各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单（vue init webpack my-project）。我们可以使用VUE的单文件组件，它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。以上这三个例子，是一步步递进的，也就是说对VUE的使用可大可小，它都会有相应的方式来整合到你的项目中。所以说它是一个渐进式的框架。 VUE最独特的特性：响应式系统VUE是响应式的（reactive），也就是说当我们的数据变更时，VUE会帮你更新所有网页中用到它的地方,查看响应式原理。 我们讲一下主流框架实现双向绑定（响应式）的做法： 1⃣️ angular(脏值检查)：angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。 2⃣️ VUE(观察者-订阅者（数据劫持）)：vueObserver 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。 二、Vue的生命周期 beforeCreate（创建前） 实例组件刚创建，元素DOM和数据都还没有初始化。 created（创建后） 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。beforeMount（载入前） DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示双花括号,这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑。 mounted（载入后）数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。可以在这边请求，不过created请求会更好一些。这个周期适合执行初始化需要操作DOM的方法。 beforeUpdate（更新前） 只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。 updated（更新后） 只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。 beforeDestroy（销毁前） 这个周期是在组件销毁之前执行，在我项目开发中，觉得这个其实有点类似路由钩子beforeRouterLeave,都是在路由离开的时候执行，只不过beforeDestroy无法阻止路由跳转，但是可以做一些路由离开的时候操作，因为这个周期里面还可以使用data和method。比如一个倒计时组件，如果在路由跳转的时候没有清除，这个定时器还是在的，这时候就可以在这个里面清除计时器。 destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 1.什么是vue生命周期？答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 2.vue生命周期的作用是什么？答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 3.vue生命周期总共有几个阶段？答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。 4.第一次页面加载会触发哪几个钩子？答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。 5.DOM 渲染在 哪个周期中就已经完成？答：DOM 渲染在 mounted 中就已经完成了。 三、 Vue实现数据双向绑定的原理：Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过**Object.defineProperty()**来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 &#123;&#123;&#125;&#125;），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &#x27;txt&#x27;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&#x27;txt&#x27;).value = newValue document.getElementById(&#x27;show&#x27;).innerHTML = newValue &#125; &#125;) document.addEventListener(&#x27;keyup&#x27;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; vue3.x响应式数据原理 Vue3.x改用Proxy替代Object.defineProperty 因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。 Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 四、Vue组件间的参数传递 父子组件通信 事件机制(**父-&gt;子props,子-&gt;父 $on、$emit) 获取父子组件实例 $parent、$children Ref 获取实例的方式调用组件的属性或者方法 Provide、inject (不推荐使用，组件库时很常用) 兄弟组件通信Vue.prototype.$bus = new Vue Vuex eventBus 这种方法通过一个空的 Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件 跨级组件通信 Vuex $attrs、$listeners Provide、inject 五、Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。” 六、Vue与Angular以及React的区别？1.与AngularJS的区别相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。 不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 2.与React的区别相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 七、vue路由的钩子函数 参看官网：导航守卫一、首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 二、vue-router的钩子函数有三类：1、全局钩子beforeEach(to，from，next) 页面加载之前 页面跳转之前权限认证，访问拦截 afterEach(to，from，next) 页面加载之后 2、组建内的导航钩子beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave,直接在路由组件内部进行定义的。beforeRouteEnter(to, from, next)beforeRouteUpdate(to, from, next)beforeRouteLeave(to, from, next) 用途：清除当前组件中的定时器，避免占用内存；当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转；保存相关内容到Vuex中或Session中 3、路由内的导航钩子 12345678910 const router = new VueRouter(&#123;routes: [ &#123; path: &#x27;/detail&#x27;, component: detail, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125;] 八、vuex是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车 stateVuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。mutationsmutations定义的方法动态修改Vuex 的 store 中的状态或数据。getters类似vue的计算属性，主要用来过滤一些数据。actionactions可以理解为通过将mutations里面处理数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 上图为官网中vuex各个要素的关系图，总的来说，我们可以在组件中触发Action，Action则会提交Mution，Mution会对State进行修改，组件再根据State、Getter渲染页面 什么样的应用场景下需要vuex ？ 如果不打算开发大型单页应用，使用vuex可能是繁琐冗余的。确实是如此——如果你的应用够简单，那最好不要使用vuex。一个简单的global event bus 就足够所需了。但是，如果需要构建是一个中大型单页应用，很可能会考虑如何更好地在组件外部管理状态，vuex将会成为自然而然的选择。 vuex一般用于中大型web单页应用中对应的状态进行管理，对于一些组件间关系较为简单的小型应用，使用vuex的必要性不是很大，因为完全可以用组件prop属性或者事件来完成父子组件之间的通信，vuex更多地用于解决跨组件通信以及作为数据中心集中式存储数据。 使用vuex解决跨组件通信问题 跨组件通信一般指非父子组件间的通信，父子组件的通信一般可以通过以下方式： 1、通过prop属性实现父组件向子组件传递数据2、通过在子组件中触发事件实现向父组件传递数据非父子组件之间的通信一般通过一个空的Vue实例作为 中转站，也可以称之为 事件中心、event bus 12345678910//创建事件中心实例let bus = new Vue();// 在组件A中触发事件bus.$emit(&#x27;test&#x27;,1);//在组件B中接受事件bus.$on(&#x27;test&#x27;, id) =&gt; &#123; //...&#125; 采用event bus的方式适合简单的开组件事件，对于多层级组件嵌套等较为复杂的场景，使用vuex能更好的应对。**vuex是通过将state作为数据中心，各个组件共享state实现跨组件通信**，此时的数据完全独立于组件，因此将组件间共享的数据置于state中能有效解决多层级组件嵌套的跨组件通信问题。 vuex作为数据存储中心vuex的State在单页应用的开发中本身具有一个”数据库”的作用，可以将组件中用到的数据存储在state中，并在Action中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在State中呢？目前主要有两种数据会使用vuex进行管理： 1、组件之间全局共享的数据2、通过后端异步请求的数据 即把通过后端异步请求的数据都纳入vuex状态管理，在Action中封装数据的增删改查等的逻辑，这样可以一定程度上对前端的逻辑代码进行分层，使组件中的代码更多的关注页面交互与数据渲染等视图层的逻辑，而异步请求与状态数据的持久化等则交由vuex管理。 下面是一个使用vuex管理用户数据的demo 12345678910111213141516171819202122232425262728293031// Stateconst state = &#123; userInfo: &#123;&#125;&#125;// Mutationconst mutations = &#123; UPDATE_USER_INFO(state,payload)&#123; state.userInfo = payload &#125;&#125;//Actionexport const fetchUserInfo = async (&#123;commit&#125;) =&gt; &#123; //请求用户数据 // 调用Mutation 写入用户数据 commit(&#x27;UPDATE_USER_INFO&#x27;, userInfo)&#125;//component //在组件中引入Action...mapAction(&#123; fetchUserInfoAction: `fectchUserInfo`&#125;)//在method中调用Actionlet res = self.fetchUserInfoAction() Vuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 新增：vuex的action有返回值吗？返回的是什么？ store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise Action 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程，可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态 mutation 必须同步执行，我们可以在 action 内部执行异步操作 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更） 总结vuex具体应用在哪取决于项目的规模以及具体的业务场景，可能是为了解决多层嵌套组件之间的通信问题，或是为了更好地管理应用中错综复杂的状态关系，而不能为了用vuex而在项目中使vuex。 123456789101112131415const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&#x27;increment&#x27;) &#125; &#125;&#125;) modules 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。 1234567891011121314151617const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125; &#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB&#125;) 九、vue-cli如何新增自定义指令？1、创建局部指令 1234567891011121314151617181920var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; &#125;, // 创建指令(可以多个) directives: &#123; // 指令名称 dir1: &#123; inserted(el) &#123; // 指令中第一个参数是当前使用指令的DOM console.log(el); console.log(arguments); // 对DOM进行操作 el.style.width = &#x27;200px&#x27;; el.style.height = &#x27;200px&#x27;; el.style.background = &#x27;#000&#x27;; &#125; &#125; &#125;&#125;) 2、全局指令 12345Vue.directive(&#x27;dir2&#x27;, &#123; inserted(el) &#123; console.log(el); &#125;&#125;) 3、指令的使用 1234&lt;div id=&quot;app&quot;&gt; &lt;div v-dir1&gt;&lt;/div&gt; &lt;div v-dir2&gt;&lt;/div&gt;&lt;/div&gt; 十、vue如何自定义一个过滤器？html代码： 1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &#123;&#123;msg| capitalize &#125;&#125;&lt;/div&gt; JS代码： 12345678910111213var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; msg:&#x27;&#x27; &#125;, filters: &#123; capitalize: function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 全局定义过滤器 12345Vue.filter(&#x27;capitalize&#x27;, function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;) 过滤器接收表达式的值 (msg) 作为第一个参数。capitalize 过滤器将会收到 msg的值作为第一个参数。 十一、对keep-alive 的了解？keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 1、在vue 2.1.0 版本之后，keep-alive新加入了两个属性:include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。 使用方法: 12345&lt;keep-alive include=&#x27;include_components&#x27; exclude=&#x27;exclude_components&#x27;&gt; &lt;component&gt; &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 参数解释include - 字符串或正则表达式，只有名称匹配的组件会被缓存exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。 使用示例 1234567891011121314&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt; 2、keep-alive的两个生命周期 activated: 页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated deactivated: 页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated 十二、vue中’.native’修饰符的使用官网的解释： 你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native 。 通俗点讲：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加’.native’事件是无法触发的此时点击页面中的按钮无任何反应。添加修饰符： 十三、Vue 中的 .sync 修饰符Vue 修饰符 .sync的功能是：当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定，是编译时的一个语法糖。具体表现如下： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;comp :money.sync=&quot;total&quot;&gt;&lt;/comp&gt; //相当于&lt;comp :money=&quot;total&quot; @update:money=&quot;total=$event&quot;&gt;&lt;/comp&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from &quot;vue&quot;;Vue.component(&quot;comp&quot;, &#123; template: `&lt;div&gt; &#123;&#123; money &#125;&#125; &lt;button @click=&quot;$emit(&#x27;update:money&#x27;:money-100)&quot;&gt;cost&lt;/button&gt; //定义新的事件监听&lt;/div&gt;`, props: [&quot;money&quot;], //子组件的外部属性&#125;); //子组件export default &#123; data() &#123; return &#123; total: 1000 &#125;; &#125;,&#125;;&lt;/script&gt; 具体思路为：为了更新子组件的一个外部数据在父组件中的表现，在子组件中定义一个新的事件监听，而后在父组件中监听这个事件，以更新子组件中这个外部属性的值。因为子组件的外部属性无法在子组件内部得到更新。而 .sync就是父组件中这一系列操作的语法糖。 十四、virtual-dom(Vue实现)简析十五、一句话就能回答的面试题1.css只在当前组件起作用答：在style标签中写入scoped即可 例如： 2.v-if 和 v-show 区别答：v-if按照条件是否渲染，v-show是display的block或none； 区别 1.手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏； 2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； 4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 使用场景 基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 总结 v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 3.route和router的区别答：route是“路由信息对象”，包括path, params, hash, query, fullPath, matched, namerouter是“路由实例”对象包括了路由的跳转方法，钩子函数等。 4.vue.js的两个核心是什么？答：数据驱动、组件系统 5.vue几种常用的指令答：v-for 、 v-if 、v-bind、v-on、v-show、v-else v-for和v-if不应该一起使用，必要情况下应该替换成computed属性。原因：v-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当需要渲染很小一部分的时候。 错误写法： 1234567&lt;li v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; :key=&quot;user.id&quot;&gt; &#123;&#123; user.name &#125;&#125;&lt;/li&gt; 如上情况，即使100个user中之需要使用一个数据，也会循环整个数组。 123456789101112131415computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125;&lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot; &gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 6.vue常用的修饰符？答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用 7.v-on 可以绑定多个方法吗？答：可以 8.什么是vue的计算属性？答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。 9.vue等单页面应用及其优缺点答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。 10.怎么定义 vue-router 的动态路由? 怎么获取传过来的值答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。 组件中的data为什么是一个函数？ 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。 子组件为什么不可以修改父组件传递的Prop？/怎么理解vue的单向数据流？ Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。 这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。 如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。 v-model是如何实现双向绑定的？ v-model是用来在表单控件或者组件上创建双向绑定的 他的本质是v-bind和v-on的语法糖 在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件 nextTick的实现原理是什么？ 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个-异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 Vue不能检测数组的哪些变动？Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？ Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 解决办法： vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 虚拟Dom以及key属性的作用 由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。 Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。) 虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速，更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快 Vue中组件生命周期调用顺序是什么样的？ 组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。 你的接口请求一般放在哪个生命周期中？ 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面loading 时间； ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 什么是 mixin ？ Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。 如果你希望再多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。 在 Vue 实例中编写生命周期 hook 或其他 option/properties 时，为什么不使用箭头函数 ？ 箭头函数自已没有定义 this 上下文中。 当你在 Vue 程序中使用箭头函数 ( =&gt; ) 时，this 关键字并不会绑定到 Vue 实例，因此会引发错误。所以强烈建议改用标准函数声明。 简述Vue模版编译原理 简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段（生成AST树/优化/codegen）： 首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。 Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。 编译的最后一步是将优化后的AST树转换为可执行的代码。 说说你对SSR的了解 SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端 SSR的优势： 更好的SEO 首屏加载速度更快 SSR的缺点： 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子 当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境 更多的服务端负载 做过哪些Vue的性能优化？ 编码阶段 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用 如果需要使用v-for给每项元素绑定事件时使用事件代理 SPA 页面采用keep-alive缓存组件 在更多的情况下，使用v-if替代v-show key保证唯一 使用路由懒加载、异步组件 防抖、节流 第三方模块按需导入 长列表滚动到可视区域动态加载 图片懒加载 SEO优化 预渲染 服务端渲染SSR 打包优化 压缩代码 Tree Shaking/Scope Hoisting使用cdn加载第三方模块多线程打包happypacksplitChunks(webpack分包)sourceMap优化用户体验骨架屏PWA还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。 vue2.x中如何监测数组变化？ 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，当调用数组api时，可以通知依赖更新。 如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。 说说你对 SPA 单页面的理解，它的优缺点分别是什么？ SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对于服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 vue3.0特性 监测机制的改变 3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易 其它方面的更改 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 tree shaking 优化，提供了更多的内置功能。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"Vue的computed和watch的细节全面分析","slug":"Vue的computed和watch的细节全面分析","date":"2020-08-02T10:37:09.000Z","updated":"2020-09-21T11:33:03.000Z","comments":true,"path":"2020/08/02/Vue的computed和watch的细节全面分析/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/Vue%E7%9A%84computed%E5%92%8Cwatch%E7%9A%84%E7%BB%86%E8%8A%82%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/","excerpt":"","text":"1、computed1.1、定义是一个计算属性,类似于过滤器,对绑定到view的数据进行处理 1.2、get用法123456789data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;&#125;,computed: &#123; fullName: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125;&#125; fullName不可在data里面定义,如果定义会报如下图片的错误,因为对应的computed作为计算属性定义fullName并返回对应的结果给这个变量,变量不可被重复定义和赋值 1.3 get和set用法12345678910111213141516171819data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27; &#125;, computed: &#123; fullName：&#123; get()&#123;//回调函数 当需要读取当前属性值时执行，根据相关数据计算并返回当前属性的值 return this.firstName + &#x27; &#x27; + this.lastName &#125;, set(val)&#123;//监视当前属性值的变化，当属性值发生变化时执行，更新相关的属性数据 //val就是fullName的最新属性值 console.log(val) const names = val.split(&#x27; &#x27;); console.log(names) this.firstName = names[0]; this.lastName = names[1]; &#125; &#125; &#125; 2、watch2.1 定义watch是一个观察的动作 2.2 示例12345678910111213data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27;&#125;,watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName&#125;,lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125; 上面是监听firstName和lastName的变化，但是仅限简单数据类型 2.2.1、监听简单数据类型12345678910data()&#123; return&#123; &#x27;first&#x27;:121 &#125; &#125;, watch:&#123; first()&#123; console.log(this.first) &#125; &#125;, 2.2.2 监听复杂数据类型1、监听复杂数据类型需用深度监听 12345678910111213141516data()&#123; return&#123; &#x27;first&#x27;:&#123; second:0 &#125; &#125; &#125;, watch:&#123; secondChange:&#123; handler(oldVal,newVal)&#123; console.log(oldVal) console.log(newVal) &#125;, deep:true &#125; &#125;, 2、console.log打印的结果,发现oldVal和newVal值是一样的,所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化 3、oldVal和newVal值一样的原因是它们索引同一个对象/数组。Vue 不会保留修改之前值的副本vm.$watch的深度监听 补充个知识点儿 Vue.nextTick( [callback, context] ) 4、深度监听对应的函数名必须为handler,否则无效果,因为watcher里面对应的是对handler的调用 2.2.3 监听对象单个属性方法一：可以直接对用对象.属性的方法拿到属性 12345678910111213data()&#123; return&#123; &#x27;first&#x27;:&#123; second:0 &#125; &#125; &#125;, watch:&#123; first.second:function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125; &#125;, 方法二：watch如果想要监听对象的单个属性的变化,必须用computed作为中间件转化,因为computed可以取到对应的属性值 1234567891011121314151617data()&#123; return&#123; &#x27;first&#x27;:&#123; second:0 &#125; &#125; &#125;, computed:&#123; secondChange()&#123; return this.first.second &#125; &#125;, watch:&#123; secondChange()&#123; console.log(&#x27;second属性值变化了&#x27;) &#125; &#125;, 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 3、computed和watch的区别3.1、computed特性1、是计算值，2、应用：就是简化tempalte里面&#123;&#123;&#125;&#125;计算和处理props或$emit的传值3、具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数 3.2、watch特性1、是观察的动作，2、应用：监听props，$emit或本组件的值执行异步操作3、无缓存性，页面重新渲染时值不变化也会执行 4、props传值4.1 常见错误1传入的值想作为局部变量来使用,直接使用会 1234567props:[&#x27;listShop&#x27;], data()&#123; return&#123;&#125; &#125;, created()&#123; this.listShop=30&#125; 报错 这个错误是说的避免直接修改父组件传入的值,因为会改变父组件的值,贴上 4.2 解决方案一简单数据类型解决方案:所以可以在data中重新定义一个变量,改变指向,但是也只是针对简单数据类型,因为复杂数据类型栈存贮的是指针。 123456789props:[&#x27;listShop&#x27;],data()&#123; return&#123; listShopChild:this.listShop &#125;&#125;,created()&#123; this.listShopChild=30&#125; 这样就可以愉快的更改传入的简单数据类型的数据啦!不会有任何报错,也不会影响父组件! 4.2.1 存在的问题复杂数据类型在栈中存贮的是指针,所以赋值给新的变量也会改变原始的变量值.那么应该怎么办?1、可以手动深度克隆一个复杂的数据出来,循环或者递归都行 数组深度克隆: 123456789var x = [1,2,3];var y = [];for (var i = 0; i &lt; x.length; i++) &#123; y[i]=x[i];&#125;console.log(y); //[1,2,3]y.push(4);console.log(y); //[1,2,3,4]console.log(x); //[1,2,3] 对象深度克隆: 123456789var x = &#123;a:1,b:2&#125;;var y = &#123;&#125;;for(var i in x)&#123; y[i] = x[i];&#125;console.log(y); //Object &#123;a: 1, b: 2&#125;y.c = 3;console.log(y); //Object &#123;a: 1, b: 2, c: 3&#125;console.log(x); //Object &#123;a: 1, b: 2&#125; 函数深度克隆: 12345var x = function()&#123;console.log(1);&#125;;var y = x;y = function()&#123;console.log(2);&#125;;x(); //1y(); //2 为什么函数可以直接赋值克隆?由于函数对象克隆之后的对象会单独复制一次并存储实际数据，因此并不会影响克隆之前的对象。所以采用简单的复制“=”即可完成克隆。 2、Object.assign只会对只是一级属性复制，比浅拷贝多深拷贝了一层而已,所以还是无法达到深度克隆的目的.详情 3、强大的JSON.stringify和JSON.parse 1const obj1 = JSON.parse(JSON.stringify(obj)); 这是ES5新出来的API,先将对象转化为字符串,就是简单数据类型赋值,再用JSON.parse转化 4.3 解决方案二直接用computed改变 12345computed:&#123; listShopChild()&#123; return this.listShop &#125;&#125; 4.3.1 存在的问题注意:此时用computed时,如果是数组this.$set(arr,1,true)对应的值也不更新，这个很坑，这个bug我找个很久如果传入的值只是在data定义，并未在methods或生命周期钩子更改，直接改变也会报错所以还是可以先用局部变量接收,再修改，这个坑比较多 5、应用1、监听本组件计算和监听2、计算或监听父传子的props值3、分为简单数据类型和复杂数据类型监听,监听方法如上watch的使用4、监听vuex的state或者getters值的变化 12345678910computed:&#123; stateDemo()&#123; return this.$store.state.demoState; &#125;&#125;watch:&#123; stateDemo()&#123; console.log(&#x27;vuex变化啦&#x27;) &#125;&#125; 6、computed和watch的原理分析接下来给大家简单罗列下他们的原理! 5.1 computed的原理深入理解 Vue Computed 计算属性 5.2 watch的原理分为三个过程:实例化Vue、调用$watch方法、属性变化，触发回调 Vue的数据依赖实现原理简析vue中$watch源码阅读笔记 7、简单实现computed和watch公共类 1234567891011121314151617181920212223242526function defineReactive(data, key, val, fn) &#123; let subs = [] // 新增 Object.defineProperty(data, key, &#123; configurable: true, enumerable: true, get: function() &#123; // 新增 if (data.$target) &#123; subs.push(data.$target) &#125; return val &#125;, set: function(newVal) &#123; if (newVal === val) return fn &amp;&amp; fn(newVal) // 新增 if (subs.length) &#123; // 用 setTimeout 因为此时 this.data 还没更新 setTimeout(() =&gt; &#123; subs.forEach(sub =&gt; sub()) &#125;, 0) &#125; val = newVal &#125;, &#125;) &#125; 7.1 computed实现12345678910111213141516function computed(ctx, obj) &#123; let keys = Object.keys(obj) let dataKeys = Object.keys(ctx.data) dataKeys.forEach(dataKey =&gt; &#123; defineReactive(ctx.data, dataKey, ctx.data[dataKey]) &#125;) let firstComputedObj = keys.reduce((prev, next) =&gt; &#123; ctx.data.$target = function() &#123; ctx.setData(&#123; [next]: obj[next].call(ctx) &#125;) &#125; prev[next] = obj[next].call(ctx) ctx.data.$target = null return prev &#125;, &#123;&#125;) ctx.setData(firstComputedObj)&#125; 7.2 watch实现1234567function watch(ctx, obj) &#123; Object.keys(obj).forEach(key =&gt; &#123; defineReactive(ctx.data, key, ctx.data[key], function(value) &#123; obj[key].call(ctx, value) &#125;) &#125;)&#125; 在微信小程序里使用 watch 和 computed","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"vue的双向绑定原理及实现","slug":"vue的双向绑定原理及实现","date":"2020-08-02T10:34:58.000Z","updated":"2020-08-24T09:04:51.000Z","comments":true,"path":"2020/08/02/vue的双向绑定原理及实现/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"vue的双向绑定原理及实现","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"Vue-Router的params和query传参的使用和区别","slug":"Vue-Router的params和query传参的使用和区别","date":"2020-08-02T10:33:57.000Z","updated":"2020-08-24T09:04:46.000Z","comments":true,"path":"2020/08/02/Vue-Router的params和query传参的使用和区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/Vue-Router%E7%9A%84params%E5%92%8Cquery%E4%BC%A0%E5%8F%82%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Vue Router 的params和query传参的使用和区别首先简单说明以下 $router 和 $route 的区别 12345678910111213141516// $router: 是路由操作对象，只写对象// $route: 路由信息对象，只读对象//操作 路由跳转this.$router.push(&#123; name: &#x27;hello&#x27;, params: &#123; name: &#x27;world&#x27;, age: &#x27;18&#x27; &#125;&#125;)//读取 路由参数接收this.name = this.$route.params.name;this.age = this.$route.params.age; 1、query传递参数query 使用name引入可以传递参数，使用path也可以，如果有人知道其中的原因请告诉我一下，非常感谢。 12345678910111213141516171819202122//query传参，使用name跳转this.$router.push(&#123; name: &#x27;test&#x27;, query: &#123; id: &#x27;20200220&#x27;, name: &#x27;query&#x27; &#125;&#125;)//query传参，使用path跳转this.$router.push(&#123; path: &#x27;test&#x27;, query: &#123; id: &#x27;20200303&#x27;, name: &#x27;query&#x27; &#125;&#125;)//query传参接收this.id = this.$route.query.id;this.name = this.$route.query.name; 最终不管是path引入还是name引入效果都一样 2、params传递参数注：使用params传参只能使用name进行引入 12345678910111213141516171819//params传参 使用namethis.$router.push(&#123; name:&#x27;test&#x27;, params: &#123; id:&#x27;202002020&#x27;, name: &#x27;query&#x27; &#125;&#125;)//params接收参数this.id = this.$route.params.id ;this.name = this.$route.params.name ;//路由&#123;path: &#x27;/test/:id/:name&#x27;,name: &#x27;test&#x27;,component: () =&gt; import(&#x27;@/view/test&#x27;)&#125; 需要注意的是： params是路由的一部分,必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。 3、总结1、传参可以使用params和query两种方式。2、使用params传参只能用name来引入路由，即push里面只能是name:’xxxx’,不能是path:’/xxx’,因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined！！！。3、使用query传参使用path来引入路由。4、params是路由的一部分,必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。5、二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"}]},{"title":"详解git-pull和git-fetch的区别","slug":"详解git-pull和git-fetch的区别","date":"2020-08-02T10:30:18.000Z","updated":"2020-08-24T09:02:28.000Z","comments":true,"path":"2020/08/02/详解git-pull和git-fetch的区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E8%AF%A6%E8%A7%A3git-pull%E5%92%8Cgit-fetch%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"详解git pull和git fetch的区别前言在我们使用git的时候用的更新代码是git fetch，git pull这两条指令。但是有没有小伙伴去思考过这两者的区别呢？有经验的人总是说最好用git fetch+git merge，不建议用git pull。也有人说git pull=git fetch+git merge，真的是这样吗？为什么呢？既然如此为什么git还要提供这两种方式呢？ 1、相同点 首先在作用上他们的功能是大致相同的，都是起到了更新代码的作用。 2、不同点 先补充一些git里面相关的一些知识： 首先我们要说简单说git的运行机制。git分为本地仓库和远程仓库，我们一般情况都是写完代码，commit到本地仓库（生成本地仓的commit ID，代表当前提交代码的版本号），然后push到远程仓库（记录这个版本号），这个流程大家都熟悉。 我们本地的git文件夹里面对应也存储了git本地仓库master分支的commit ID 和 跟踪的远程分支orign/master的commit ID（可以有多个远程仓库）。那什么是跟踪的远程分支呢，打开git文件夹可以看到如下文件： 12git/refs/head/[本地分支]git/refs/remotes/[正在跟踪的分支] 其中head就是本地分支，remotes是跟踪的远程分支，这个类型的分支在某种类型上是十分相似的，他们都是表示提交的SHA1校验和（就是commitID）。 但是，不管他们是如何的相似，他们还是有一个重大的区别： 更改远端跟踪分支只能用git fetch，或者是git push后作为副产品（side-effect）来改变。我们无法直接对远程跟踪分支操作，我们必须先切回本地分支然后创建一个新的commit提交。 首先假设我们本地仓库的 master 分支上 commit ID =1 ，orign/mastter中的commit ID =1 ;这时候远程仓库有人更新了github ogirn库中master分支上的代码，新的代码版本号commit ID =2 ,那么在github上 orign/master的commitID=2，然后我们要更新代码。 1、git fetch 使用git fetch更新代码，本地的库中master的commitID不变，还是等于1。但是与git上面关联的那个orign/master的commit ID变成了2。 这时候我们本地相当于存储了两个代码的版本号，我们还要通过merge去合并这两个不同的代码版本，如果这两个版本都修改了同一处的代码，这时候merge就会出现冲突，然后我们解决冲突之后就生成了一个新的代码版本。 这时候本地的代码版本可能就变成了commit ID=3，即生成了一个新的代码版本。 相当于fetch的时候本地的master没有变化，但是与远程仓关联的那个版本号被更新了，我们接下来就是在本地合并这两个版本号的代码。 2、git pull 是用git pull更新代码的话就比较简单暴力了，看下图。 使用git pull的会将本地的代码更新至远程仓库里面最新的代码版本 3、总结 由此可见，git pull看起来像git fetch+get merge，但是根据commit ID来看的话，他们实际的实现原理是不一样的。 这里借用之前文献看到的一句话： 12345 不要用git pull，用git fetch和git merge代替它。git pull的问题是它把过程的细节都隐藏了起来，以至于你不用去了解git中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。看起来git pull的用法会使你吃惊，简单看一下git的使用文档应该就能说服你。将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。当然，除非你关闭所有的安全选项，否则git pull在你本地工作目录还不至于造成不可挽回的损失，但很多时候我们宁愿做的慢一些，也不愿意返工重来。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://perfectsymphony.github.io/tags/Git/"}]},{"title":"前端性能优化的七大手段","slug":"前端性能优化的七大手段","date":"2020-08-02T10:26:38.000Z","updated":"2020-08-24T09:01:47.000Z","comments":true,"path":"2020/08/02/前端性能优化的七大手段/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%83%E5%A4%A7%E6%89%8B%E6%AE%B5/","excerpt":"","text":"前面的话本文将详细介绍前端性能优化的七大手段，包括减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化 一、减少请求数量【合并】 如果不进行文件合并，有如下3个隐患 1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟 2、受丢包问题影响更严重 3、经过代理服务器时可能会被断开 但是，文件合并本身也有自己的问题 1、首屏渲染问题 2、缓存失效问题 所以，对于文件合并，有如下改进建议 1、公共库合并 2、不同页面单独合并 【图片处理】 1、雪碧图 CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台 2、Base64 将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33% 3、使用字体图标来代替图片 【减少重定向】 尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验 如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面 【使用缓存】 使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应 【不使用CSS @import】 CSS的@import会造成额外的请求 【避免使用空的src和href】 a标签设置空的href，会重定向到当前的页面地址 form设置空的method，会提交表单到当前的页面地址 二、减小资源大小【压缩】 1、HTML压缩 HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等 2、CSS压缩 CSS压缩包括无效代码删除与CSS语义合并 3、JS压缩与混乱 JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护 4、图片压缩 针对真实图片情况，舍弃一些相对无关紧要的色彩信息 【webp】 在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性 【开启gzip】 HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40% 三、优化网络连接【使用CDN】 CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度 【使用DNS预解析】 当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址 DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度 方法是在 head 标签里面写上几个 link 标签 12&lt;link rel=&quot;dns-prefecth&quot; href=&quot;https://www.google.com&quot;&gt;&lt;link rel=&quot;dns-prefecth&quot; href=&quot;https://www.google-analytics.com&quot;&gt; 对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间 【并行连接】 由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数 【持久连接】 使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量 【管道化连接】 在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了 四、优化资源加载【资源加载位置】 通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用 1、CSS文件放在head中，先外链，后本页 2、JS文件放在body底部，先外链，后本页 3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件 4、body中间尽量不写style标签和script标签 【资源加载时机】 1、异步script标签 defer: 异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似 async: 异步加载，加载完成后立即执行 2、模块按需加载 在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块 按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载 webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure 3、使用资源预加载preload和资源预读取prefetch preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度 prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度 4、资源懒加载与资源预加载 资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源 资源预加载是提前加载用户所需的资源，保证良好的用户体验 资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能 五、减少重绘回流【样式设置】 1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率 2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次 3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流 4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流 5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间 6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现 【渲染层】 1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围 2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流 【DOM优化】 1、缓存DOM 1const div = document.getElementById(&#x27;div&#x27;) 由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM 2、减少DOM深度及DOM数量 HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。 3、批量操作DOM 由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM 4、批量操作CSS样式 通过切换class或者使用元素的style.csstext属性去批量操作元素样式 5、在内存中操作DOM 使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上 6、DOM元素离线更新 对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作 7、DOM读写分离 浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行 8、事件代理 事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件 利用事件代理，可以减少内存使用，提高性能及降低代码复杂度 9、防抖和节流 使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发 10、及时清理环境 及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存 六、性能更好的API1、用对选择器 选择器的性能排序如下所示，尽量选择性能更好的选择器 123456789id选择器（#myid）类选择器（.myclassname）标签选择器（div,h1,p）相邻选择器（h1+p）子选择器（ul &gt; li）后代选择器（li a）通配符选择器（*）属性选择器（a[rel=&quot;external&quot;]）伪类选择器（a:hover,li:nth-child） 2、使用requestAnimationFrame来替代setTimeout和setInterval 希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧 3、使用IntersectionObserver来实现图片可视区域的懒加载 传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题 4、使用web worker 客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用 但是，使用一些新的API的同时，也要注意其浏览器兼容性 七、webpack优化【打包公共代码】 使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件 webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk 通过设置 optimization.splitChunks.chunks: “all” 来启动默认的代码分割配置项 【动态导入和按需加载】 webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure 【剔除无用代码】 tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的 【长缓存优化】 1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效 2、使用Name而不是id 每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变 下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建 【公用代码内联】 使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://perfectsymphony.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"关于跨域,以及跨域的几种方式","slug":"关于跨域-以及跨域的几种方式","date":"2020-08-02T10:15:26.000Z","updated":"2020-08-27T09:12:59.000Z","comments":true,"path":"2020/08/02/关于跨域-以及跨域的几种方式/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F-%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"首先我们来想一想 为什么会有跨域这个名词的出现呢? 跨域又是什么呢?为何要跨域? 浏览器的同源策略又是什么?怎么解决? jsonp又是什么? 跨域的原理又是什么呢? 名词解释:跨域: 浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了. 上面提到的,同域的概念又是什么呢??? 简单的解释就是相同域名,端口相同,协议相同。 同源策略: 请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同. 比如:我在本地上的域名是study.cn,请求另外一个域名一段数据 这个时候在浏览器上会报错: 这个就是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险~ | study.cn/json/jsonp/jsonp.html || ——— | ——— | ——— || 请求地址| 形式| 结果| http://study.cn/test/a.html| 同一域名,不同文件夹| 成功| http://study.cn/json/jsonp/jsonp.html| 同一域名,统一文件夹| 成功| http://a.study.cn/json/jsonp/jsonp.html| 不同域名,文件路径相同| 失败| http://study.cn:8080/json/jsonp/jsonp.html| 同一域名,不同端口| 失败| https://study.cn/json/jsonp/jsonp.html| 同一域名,不同协议| 失败 jsonp: jsonp 全称是JSON with Padding,是为了解决跨域请求资源而产生的解决方案,是一种依靠开发人员创造出的一种非官方跨域数据交互协议。 一个是描述信息的格式，一个是信息传递双方约定的方法。 jsonp的产生: 1.AJAX直接请求普通文件存在跨域无权限访问的问题,不管是静态页面也好. 2.不过我们在调用js文件的时候又不受跨域影响,比如引入jquery框架的,或者是调用相片的时候 3.凡是拥有src这个属性的标签都可以跨域例如&lt;script&gt;&lt;img&gt;&lt;iframe&gt; 4.如果想通过纯web端跨域访问数据只有一种可能,那就是把远程服务器上的数据装进js格式的文件里. 5.而json又是一个轻量级的数据格式,还被js原生支持 6.为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端， demo1:基于script标签实现跨域 举个例子:我在http://study.cn/json/jsonp/jsonp_2.html下请求一个远程的js文件 123456789101112131415161718 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var message = function(data) &#123; alert(data[1].title); &#125;;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://web.cn/js/message.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&#x27;testdiv&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 远程的message.js文件是 123456789101112message([ &#123;&quot;id&quot;:&quot;1&quot;, &quot;title&quot;:&quot;天津新闻联播，雷人搞笑的男主持人&quot;&#125;, &#123;&quot;id&quot;:&quot;2&quot;, &quot;title&quot;:&quot;楼市告别富得流油 专家:房价下跌是大概率事件&quot;&#125;, &#123;&quot;id&quot;:&quot;3&quot;, &quot;title&quot;:&quot;法国人关注时事 八成年轻人每天阅读新闻&quot;&#125;, &#123;&quot;id&quot;:&quot;4&quot;, &quot;title&quot;:&quot;新闻中的历史,历史中的新闻&quot;&#125;, &#123;&quot;id&quot;:&quot;5&quot;, &quot;title&quot;:&quot;东阳新闻20140222&quot;&#125;, &#123;&quot;id&quot;:&quot;6&quot;, &quot;title&quot;:&quot;23个职能部门要增加新闻发布频次&quot;&#125;, &#123;&quot;id&quot;:&quot;7&quot;, &quot;title&quot;:&quot;《贵州新闻联播》 中国美丽乡村&quot;&#125;, &#123;&quot;id&quot;:&quot;8&quot;, &quot;title&quot;:&quot;朝韩离散家属团聚首轮活动结束&quot;&#125;, &#123;&quot;id&quot;:&quot;9&quot;, &quot;title&quot;:&quot;索契冬奥会一天曝出两例兴奋剂事件&quot;&#125;, &#123;&quot;id&quot;:&quot;10&quot;, &quot;title&quot;:&quot;今天中国多地仍将出现中度霾&quot;&#125; ]); 这个时候我们得到的相应头是: 这样就实现跨域成功了,因为服务端返回数据时会将这个callback参数(message)作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 demo2: 基于script标签实现跨域 让远程js知道它应该调用的本地函数叫什么名字,只要服务端提供的js脚本是动态生成的就好了,这样前台只需要传一个callback参数过去告诉服务端,我需要XXX代码,于是服务端就会得到相应了. 例如 在http://study.cn/json/jsonp/jsonp_3.html页面请求 http://192.168.31.137/train/test/jsonpthree 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; var messagetow = function(data)&#123; alert(data); &#125;; var url = &quot;http://192.168.31.137/train/test/jsonpthree?callback=messagetow&quot;; var script = document.createElement(&#x27;script&#x27;); script.setAttribute(&#x27;src&#x27;, url); document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 得到的响应头是: demo3: 基于jquery跨域 那么如何用jquery来实现我们的跨域呢???jquery已经把跨域封装到ajax上了,而且封装得非常的好,使用起来也特别方便 如果是一般的ajax请求: 1234567891011$.ajax(&#123; url:&#x27;http://192.168.31.137/train/test/testjsonp&#x27;, type : &#x27;get&#x27;, dataType : &#x27;text&#x27;, success:function(data)&#123; alert(data); &#125;, error:function(data)&#123; alert(2); &#125; &#125;); 那么在浏览器中会报错: jsonp形式的ajax请求:并且通过get请求的方式传入参数, 注意:跨域请求是只能是get请求不能使用post请求 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; var name = &#x27;chenshishuo&#x27;; var sex = &#x27;man&#x27;; var address = &#x27;shenzhen&#x27;; var looks = &#x27;handsome &#x27;; $.ajax(&#123; type : &#x27;get&#x27;, url:&#x27;http://192.168.31.137/train/test/testjsonp&#x27;, data : &#123; name : name, sex : sex, address : address, looks : looks, &#125;, cache :false, jsonp: &quot;callback&quot;, jsonpCallback:&quot;success&quot;, dataType : &#x27;jsonp&#x27;, success:function(data)&#123; alert(data); &#125;, error:function(data)&#123; alert(&#x27;error&#x27;); &#125; &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input id=&#x27;inputtest&#x27; value=&#x27;546&#x27; name=&#x27;inputtest&#x27;&gt;&lt;div id=&#x27;testdiv&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jsonp 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)jsonpCallback 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名 看看请求头和相应头吧 请求头:jquery会自动带入callback参数,当服务端获取到这个参数后,返回回来.(响应头) 现在是不是明白了跨域的基本原理,和基本的使用方法呢?? 上面我们说到img中的src可以自动调用远程图片的(这个比较简单我在这里就不说了) 还有ifram请求: 基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com 这种特点， 也就是两个页面必须属于一个基础域（例如都是xxx.com)，使用同一协议和同一端口，这样在两个页面中同时添加document.domain，就可以实现父页面调用子页面的函数 要点就是 :通过修改document.domain来跨子域 demo4: 通过iframe来跨子域 http://a.study.cn/a.html 请求 http://b.study.cn/b.html 在a.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.domain = &#x27;study.cn&#x27;; function test() &#123; alert(document.getElementById(&#x27;a&#x27;).contentWindow); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id=&#x27;a&#x27; src=&#x27;http://b.study.cn/b.html&#x27; onload=&#x27;test()&#x27;&gt;&lt;/body&gt;&lt;/html&gt; 在b.html: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.domain = &#x27;study.cn&#x27;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 我是b.study.cn的body&lt;/body&gt;&lt;/html&gt; 运行效果截图: 我们就可以通过js访问到iframe中的各种属性和对象了 如果你想在http://a.study.cn/a.html页面中通过ajax直接请求页面http://b.study.cn/b.html，即使你设置了相同的document.domain也还是不行的. 所以修改document.domain的方法只适用于不同子域的框架(父类与子类)间的交互。 如果想通过使用ajax的方法去与不同子域间的数据交互或者是js调用，只有两种方法,一种是使用jsonp的方法外，还有一种是使用iframe来做一个代理。 原理就是让这个 iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据 的， 然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发 送ajax请求，然后收到的数据我们也可以获得了。 上面的所有知识点,应该可以解决第一开始提出的问题了吧.","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://perfectsymphony.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"nginx的gzip设置详解","slug":"nginx的gzip设置详解","date":"2020-08-02T10:14:20.000Z","updated":"2020-08-24T09:04:18.000Z","comments":true,"path":"2020/08/02/nginx的gzip设置详解/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/nginx%E7%9A%84gzip%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"nginx中gzip压缩(节省带宽)原理:浏览器—请求—-&gt; 声明可以接受 gzip压缩 或 deflate压缩 或compress 或 sdch压缩从http协议的角度看–请求头 声明 acceopt-encoding: gzip deflate sdch (是指压缩算法,其中sdch是google倡导的一种压缩方式,目前支持的服务器尚不多)服务器–&gt;回应—把内容用gzip方式压缩—-&gt;发给浏览器浏览&lt;—–解码gzip—–接收gzip压缩内容—- 官方文档 http://nginx.org/en/docs/http/ngx_http_gzip_module.html gzip配置的常用参数gzip on|off; #是否开启gzipgzip_buffers 32 4K| 16 8K #缓冲(压缩在内存中缓冲几块? 每块多大?)gzip_comp_level [1-9] #推荐6 压缩级别(级别越高,压的越小,越浪费CPU计算资源)gzip_disable #正则匹配UA 什么样的Uri不进行gzipgzip_min_length 200 # 开始压缩的最小长度(再小就不要压缩了,意义不在)gzip_http_version 1.0|1.1 # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)gzip_proxied # 设置请求者代理服务器,该如何缓存内容gzip_types text/plain application/xml # 对哪些类型的文件用压缩 如txt,xml,html ,cssgzip_vary on|off # 是否传输gzip压缩标志 注意:图片/mp3这样的二进制文件,不必压缩因为压缩率比较小, 比如100-&gt;80字节,而且压缩也是耗费CPU资源的,比较小的文件不必压缩 nginx中的expires缓存(缓存在浏览器中 提高网站性能)使用场景:对于网站的图片,尤其是新闻站, 图片一旦发布, 改动的可能是非常小的.我们希望 能否在用户访问一次后, 图片缓存在用户的浏览器端,且时间比较长的缓存.列如:缓存一个小时location ~..(jpg|png|jpeg|gif){expires 1d;}(注意:服务器的日期要准确,如果服务器的日期落后于实际日期,可能导致缓存失效)304 也是一种很好的缓存手段原理是: 服务器响应文件内容是,同时响应etag标签(内容的签名,内容一变,他也变), 和 last_modified_since 2个标签值浏览器下次去请求时,头信息发送这两个标签, 服务器检测文件有没有发生变化,如无,直接头信息返回 etag,last_modified_since浏览器知道内容无改变,于是直接调用本地缓存.这个过程,也请求了服务器,但是传着的内容极少.对于变化周期较短的,如静态html,js,css,比较适于用这个方式","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://perfectsymphony.github.io/tags/Nginx/"}]},{"title":"从输入url到页面加载完成发生了什么(详解)","slug":"从输入url到页面加载完成发生了什么(详解)","date":"2020-08-02T10:01:26.000Z","updated":"2020-11-23T10:24:30.000Z","comments":true,"path":"2020/08/02/从输入url到页面加载完成发生了什么(详解)/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88(%E8%AF%A6%E8%A7%A3)/","excerpt":"","text":"这是一道经典的面试题，这道题没有一个标准的答案，它涉及很多的知识点，面试官会通过这道题了解你对哪一方面的知识比较擅长，然后继续追问看看你的掌握程度。当然我写的这些也只是我的一些简单的理解，从前端的角度出发，我觉得首先回答必须包括几个基本的点，然后在根据你的理解深入回答。 1、浏览器的地址栏输入URL并按下回车。 2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。 3、DNS解析URL对应的IP。 4、根据IP建立TCP连接（三次握手）。 5、HTTP发起请求。 6、服务器处理请求，浏览器接收HTTP响应。 7、渲染页面，构建DOM树。 8、关闭TCP连接（四次挥手）。 说完整个过程的几个关键点后我们再来展开的说一下。一、URL 我们常见的RUL是这样的:http://www.baidu.com, 这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。除此之外URL还会包含一些路径、查询和其他片段，例如：http://www.tuicool.com/search?kw=%E4%。我们最常见的的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。URL的中间部分为域名或者是IP，之后就是端口号了。通常端口号不常见是因为大部分的都是使用默认端口，如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题，我今天就不在这里展开了 二、缓存 说完URL我们说说浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，对比缓存。 强制缓存判断HTTP首部字段：cache-control，Expires。 Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。 cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。 如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。 对比缓存通过HTTP的last-modified，Etag字段进行判断。 last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。 Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。 在第一次请求服务器的时候在获取资源之后是会先把该资源缓存在本地的，同时服务器response返回了一个响应头ETag，ETag全称Entity Tag，用来标识一个资源。在具体的实现中，ETag可以是资源的hash值，也可以是一个内部维护的版本号。但不管怎样，ETag应该能反映出资源内容的变化，这是Http缓存可以正常工作的基础。服务器对于hello world这个字符串使用上述返回的ETag来表示，只要hello world这个资源不变，这个Etag就不会变。 客户端第二次请求服务器的时候，利用请求头If-None-Match来告诉服务器自己已经有个ETag为xxx的资源。如果服务器上的资源没有变化，也就是说服务器上的资源的ETag也是xxx的话，服务器就不会再返回该资源的内容，而是返回一个304的响应，告诉浏览器该资源没有变化，缓存有效，浏览器将直接调用本地缓存。 三、DNS域名解析 我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。 首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。 如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。 最后迭代查询，按根域服务器 -&gt;顶级域,.cn-&gt;第二层域，hb.cn -&gt;子域，www.hb.cn的顺序找到IP地址。 递归查询，按上一级DNS服务器-&gt;上上级-&gt;….逐级向上查询找到IP地址。 四、TCP连接 在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。 第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认； 第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据。 五、浏览器向服务器发送HTTP请求 完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。 六、浏览器接收响应 服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。 状态码主要包括以下部分 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 响应头主要由Cache-Control、 Connection、Date、Pragma等组成。 响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。 七、页面渲染 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。 在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。 Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。 Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。 所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。 下面这些动作有很大可能会是成本比较高的： 1、增加、删除、修改DOM结点时，会导致Reflow或Repaint 2、移动DOM的位置，或是搞个动画的时候 3、内容发生变化 4、修改CSS样式的时候 5、Resize窗口的时候（移动端没有这个问题），或是滚动的时候 6、修改网页的默认字体时 基本上来说，reflow有如下的几个原因： 1、Initial，网页初始化的时候 2、Incremental，一些js在操作DOM树时 3、Resize，其些元件的尺寸变了 4、StyleChange，如果CSS的属性发生变化了 5、Dirty，几个Incremental的reflow发生在同一个frame的子树上 八、关闭TCP连接或继续保持连接 通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。 第一次挥手是浏览器发完数据后，发送FIN请求断开连接。 第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。 这样浏览器需要返回ACK表示同意，也就是第四次挥手。 至此从浏览器地址栏输入URL到页面呈现到你面前的整个过程就分析完了。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://perfectsymphony.github.io/tags/http/"}]},{"title":"HTTP状态码汇总","slug":"HTTP状态码汇总","date":"2020-08-02T10:00:24.000Z","updated":"2020-08-24T09:03:51.000Z","comments":true,"path":"2020/08/02/HTTP状态码汇总/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E6%B1%87%E6%80%BB/","excerpt":"","text":"HTTP状态码总的分为五类： 1开头：信息状态码 2开头：成功状态码 3开头：重定向状态码 4开头：客户端错误状态码 5开头：服务端错误状态码 1XX：信息状态码 状态码 含义 描述 100 继续 初始的请求已经接受，请客户端继续发送剩余部分 101 切换协议 请求这要求服务器切换协议，服务器已确定切换 2XX：成功状态码 状态码 含义 描述 200 成功 服务器已成功处理了请求 201 已创建 请求成功并且服务器创建了新的资源 202 已接受 服务器已接受请求，但尚未处理 203 非授权信息 服务器已成功处理请求，但返回的信息可能来自另一个来源 204 无内容 服务器成功处理了请求，但没有返回任何内容 205 重置内容 服务器处理成功，用户终端应重置文档视图 206 部分内容 服务器成功处理了部分GET请求 3XX：重定向状态码 状态码 含义 描述 300 多种选择 针对请求，服务器可执行多种操作 301 永久移动 请求的页面已永久跳转到新的url 302 临时移动 服务器目前从不同位置的网页响应请求，但请求仍继续使用原有位置来进行以后的请求 303 查看其他位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码 304 未修改 自从上次请求后，请求的网页未修改过 305 使用代理 请求者只能使用代理访问请求的网页 307 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 4XX：客户端错误状态码 状态码 含义 描述 400 错误请求 服务器不理解请求的语法 401 未授权 请求要求用户的身份验证 403 禁止 服务器拒绝请求 404 未找到 服务器找不到请求的页面 405 方法禁用 禁用请求中指定的方法 406 不接受 无法使用请求的内容特性响应请求的页面 407 需要代理授权 请求需要代理的身份认证 408 请求超时 服务器等候请求时发生超时 409 冲突 服务器在完成请求时发生冲突 410 已删除 客户端请求的资源已经不存在 411 需要有效长度 服务器不接受不含有效长度表头字段的请求 412 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件 413 请求实体过大 由于请求实体过大，服务器无法处理，因此拒绝请求 414 请求url过长 请求的url过长，服务器无法处理 415 不支持格式 服务器无法处理请求中附带媒体格式 416 范围无效 客户端请求的范围无效 417 未满足期望 服务器无法满足请求表头字段要求 5XX：服务端错误状态码 状态码 含义 描述 500 服务器错误 服务器内部错误，无法完成请求 501 尚未实施 服务器不具备完成请求的功能 502 错误网关 服务器作为网关或代理出现错误 503 服务不可用 服务器目前无法使用 504 网关超时 网关或代理服务器，未及时获取请求 505 不支持版本 不支持版本","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://perfectsymphony.github.io/tags/http/"}]},{"title":"ES6遍历数组和对象的方法总结","slug":"ES6遍历数组和对象的方法总结","date":"2020-08-02T09:57:11.000Z","updated":"2020-08-24T09:03:30.000Z","comments":true,"path":"2020/08/02/ES6遍历数组和对象的方法总结/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/ES6%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"1、every 数组的每一项都返回true，遍历完整个数组，最终返回值才为true 123arr.every((val,index,arr)=&gt;&#123; return val&lt;10; &#125;) 2、some 数组任意一项返回true，则停止遍历，返回值为true 123arr.some((val,index,arr)=&gt;&#123; return val&lt;10; &#125;) 3、filter 遍历整个数组，找到符合的元素，返回这个新组成的数组 123 arr.filter((val,index,arr)=&gt;&#123; return val&lt;10; &#125;) 4、map 遍历整个数组，返回每个元素调用后的结果组成新的数组 123arr.map((val,index,arr)=&gt;&#123; return val**2; &#125;) 5、forEach 遍历数组每一项 123arr.foreach((val,index,arr)=&gt;&#123; return val**2; &#125;) 6、数组累加器reduce、reduceRight 123arr.reduce((preValue, currentValue)=&gt;&#123; return preValue + currentValue &#125;) 7、for of方法不仅可以遍历数组和对象，还可以遍历自定义的数据结构 1234let arr = [1,2,3,4,5]for(let item of arr)&#123; console.log(item)&#125; 8、for…in既可以遍历对象也可以遍历数组 1234var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];for(var i in arr) &#123; console.log(&#x27;index:&#x27;, i, &#x27;value:&#x27;, arr[i])&#125; ES5~ES8 数组拥有的方法1、判断是否是数组 Array.isArray( arg ) 有兼容性;2、toString 数组转字符串 arr.toString();3、join 数组每一项间的拼接 arr.join(); String.split();4、pop 删除原数组最后一项，返回删除项 arr.pop() 原数组被修改;5、push 在原数组末尾添加一项，返回数组新长度，改变原数组 arr.push( …arg )6、shift 删除数组第一项，改变原数组，返回删除项 arr.shift( );7、unshift 在原数组首位添加项，返回数组新长度 arr.unshift( …arg );8、reverse 反转数组项的顺序，返回修改后的数组 arr.reverse();9、sort 数组每项按照unicode编码排序，默认升序 arr.sort(); 10、concat 数组合并，返回合并后的数组 arr1.concat( arr2 );11、slice 截取数组 参数一：开始位置 参数二：结束位置后一位 参数为负数，用数组总长度加上该负数来确定位置; 结束位置小于起始位置，返回空数组 arr.slice(arg1,arg2)12、splice 删除、插入、替换数组元素 参数一：起始位置 参数二：删除元素个数 参数三：插入的元素 arr.splice(arg1,arg2,arg3) 返回被删除的项，会改变原数组。13、indexOf/lastIndexOf 数组中查找元素的位置 参数一：要查找的元素 参数二：开始查找位置 返回值-1 不存在，返回值大于等于0表示元素位置 arr.indexOf(arg1,arg2) 从左往右查找 arr.lastIndexOf(arg1,arg2) 从右往左查找 总结：1、forEach、map、filter都可以遍历数组2、forEach操作的原数组，map、filter会返回一个新的数组3、纯粹的遍历操作使用forEach，如果想得到原数组的克隆使用map，如果想根据条件筛选使用filter ES6新增数组方法1、from 将类似数组的对象和可遍历的对象转为真正的数组。 Array.from([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]) Array.from(&quot;fool&quot;)2、of 将一组值转为数组 弥补Array()的不足 Array.of(7) //[,,,,,,] Array.of(7) // [7] Array.of(1, 2, 3); // [1, 2, 3]3、copyWithin 将数组中指定位置的元素复制到其他位置（会覆盖掉原有元素） 参数一：从该位置开始替换元素 参数二：从该位置开始读取数据，默认为0 参数三：到该位置停止读 取数据，默认为数组长度 arr.copyWithin(arg1,arg2,arg3)4、fill 使用给定值，填充数组 参数一：给定的值 参数二：起始位置 参数三：结束位置 arr.fill(arg1,arg2,arg3)5、find/findIndex 找到数组中符合条件的值/位置，若没找到返回undefined 123 arr.find((val,index,arr)=&gt;&#123; return val&gt;9; &#125;) 6、keys() 遍历数组获取键名 values() 遍历数组获取键值 entries() 遍历数组获取键值对 123 for(let [index,val] of arr.keys()) &#123; console.log(val) &#125; ES7.0新增的数组方法1、includes 判断数组中是否存在该元素 弥补indexOf不能判断NaN arr.includes() ES8没有新增数组方法ES6遍历对象的方法总结1、for … in 循环遍历对象自身的和继承的可枚举属性(循环遍历对象自身的和继承的可枚举属性(不含Symbol属性))。 2、使用Object.keys()遍历 (返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)). 3、Object.getOwnPropertyNames(obj),返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性). 12345var obj = &#123;&#x27;0&#x27;:&#x27;a&#x27;,&#x27;1&#x27;:&#x27;b&#x27;,&#x27;2&#x27;:&#x27;c&#x27;&#125;;Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); 4、Reflect.ownKeys(obj),返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举. 12345var obj = &#123;&#x27;0&#x27;:&#x27;a&#x27;,&#x27;1&#x27;:&#x27;b&#x27;,&#x27;2&#x27;:&#x27;c&#x27;&#125;;Reflect.ownKeys(obj).forEach(function(key)&#123;console.log(key,obj[key]);&#125;);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"帮你彻底搞懂JS中的prototype、__proto__与constructor(图解)","slug":"帮你彻底搞懂JS中的prototype、-proto-与constructor(图解)","date":"2020-08-02T09:49:22.000Z","updated":"2020-11-18T09:36:11.000Z","comments":true,"path":"2020/08/02/帮你彻底搞懂JS中的prototype、-proto-与constructor(图解)/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E5%B8%AE%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JS%E4%B8%AD%E7%9A%84prototype%E3%80%81-proto-%E4%B8%8Econstructor(%E5%9B%BE%E8%A7%A3)/","excerpt":"","text":"可以先看一下最后的总结部分再回过头来完整看完1. 前言作为一名前端工程师，必须搞懂JS中的prototype、__proto__与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，__proto__属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格：_ _proto_ _，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf(&#123;__proto__: null&#125;) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。 现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解： 12function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示： 看到这图别怕，让我们一步步剖析，彻底搞懂它们！ 图的说明：右下角为图例，红色箭头表示__proto__属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。 2. _ _ proto _ _ 属性 首先，我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析： 第一，这里我们仅留下 __proto__ 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 3. prototype属性第二，接下来我们看 prototype 属性： prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：f1.__proto__ === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 4. constructor属性 最后，我们来看一下 constructor 属性： constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过__proto__在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下： 5. 总结** 总结一下：** 1、我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。2、__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。3、prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，同时，在实例化的时候(let f1 = new Foo() )，prototype上的属性会作为原型对象赋值给实例，即f1.__proto__ === Foo.prototype。4、constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 参考文章：https://www.cnblogs.com/xiaohuochai/p/5721552.html https://www.cnblogs.com/Narcotic/p/6899088.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"JS事件循环机制(event loop)之宏任务、微任务","slug":"JS事件循环机制-event-loop-之宏任务、微任务","date":"2020-08-02T09:47:24.000Z","updated":"2020-08-24T09:03:57.000Z","comments":true,"path":"2020/08/02/JS事件循环机制-event-loop-之宏任务、微任务/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop-%E4%B9%8B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"JS事件循环机制(event loop)之宏任务、微任务","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"Promise精选","slug":"Promise精选","date":"2020-08-02T09:44:05.000Z","updated":"2021-01-02T16:24:28.000Z","comments":true,"path":"2020/08/02/Promise精选/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/Promise%E7%B2%BE%E9%80%89/","excerpt":"","text":"一、常见 Promise 面试题123456781、了解 Promise 吗？2、Promise 解决的痛点是什么？3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。4、Promise 如何使用？5、Promise 常用的方法有哪些？它们的作用是什么？6、Promise 在事件循环中的执行过程是怎样的？7、Promise 的业界实现都有哪些？8、能不能手写一个 Promise 的 polyfill。 Promise 出现的原因在 Promise 出现以前，我们处理一个异步网络请求，大概是这样： 12345// 请求 代表 一个异步网络调用。// 请求结果 代表网络请求的响应。请求1(function(请求结果1)&#123; 处理请求结果1&#125;) 看起来还不错。但是，需求变化了，我们需要根据第一个网络请求的结果，再去执行第二个网络请求，代码大概如下 12345请求1(function(请求结果1)&#123; 请求2(function(请求结果2)&#123; 处理请求结果2 &#125;)&#125;) 看起来也不复杂。但是需求是永无止境的，于是乎出现了如下的代码 12345678910111213请求1(function(请求结果1)&#123; 请求2(function(请求结果2)&#123; 请求3(function(请求结果3)&#123; 请求4(function(请求结果4)&#123; 请求5(function(请求结果5)&#123; 请求6(function(请求结果3)&#123; ... &#125;) &#125;) &#125;) &#125;) &#125;)&#125;) 这回傻眼了。。。 臭名昭著的 回调地狱 现身了。 更糟糕的是，我们基本上还要对每次请求的结果进行一些处理，代码会更加臃肿，在一个团队中，代码 review 以及后续的维护将会是一个很痛苦的过程。 回调地狱带来的负面作用有以下几点： 代码臃肿。 可读性差。 耦合度过高，可维护性差。 代码复用性差。 容易滋生 bug。 只能在回调里处理异常。 出现了问题，自然就会有人去想办法。这时，就有人思考了，能不能用一种更加友好的代码组织方式，解决异步嵌套的问题。 let 请求结果1 = 请求1();let 请求结果2 = 请求2(请求结果1);let 请求结果3 = 请求3(请求结果2);let 请求结果4 = 请求2(请求结果3);let 请求结果5 = 请求3(请求结果4); 类似上面这种同步的写法。 于是 Promise 规范诞生了，并且在业界有了很多实现来解决回调地狱的痛点。比如业界著名的 Q 和 bluebird，bluebird 甚至号称运行最快的类库。 看到这里，对于上面的问题 2 和问题 7 ，心中是否有了答案呢。 什么是 Promise Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。 代码书写比较还是使用上面的网络请求例子，我们看下 Promise 的常规写法： new Promise(请求1) .then(请求2(请求结果1)) .then(请求3(请求结果2)) .then(请求4(请求结果3)) .then(请求5(请求结果4)) .catch(处理异常(异常信息)) 比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。 APIPromise 的常用 API 如下： Promise.resolve(value) 123类方法，该方法返回一个以 value 值解析后的 Promise 对象 1、如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）2、如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。3、其他情况以该值为成功状态返回一个 Promise 对象。 上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。这个 API 比较重要，建议大家通过练习一些小例子，并且配合上面的解释来熟悉它。如下几个小例子： 12345678910//如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。 function fn(resolve)&#123; setTimeout(function()&#123; resolve(123); &#125;,3000);&#125;let p0 = new Promise(fn);let p1 = Promise.resolve(p0);// 返回为true，返回的 Promise 即是 入参的 Promise 对象。console.log(p0 === p1); 传入 thenable 对象，返回 Promise 对象跟随 thenable 对象的最终状态。 ES6 Promises 里提到了 Thenable 这个概念，简单来说它就是一个非常类似 Promise 的东西。最简单的例子就是 jQuery.ajax，它的返回值就是 thenable 对象。但是要谨记，并不是只要实现了 then 方法就一定能作为 Promise 对象来使用。 12345//如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。let promise = Promise.resolve($.ajax(&#x27;/test/test.json&#x27;));// =&gt; promise对象promise.then(function(value)&#123; console.log(value);&#125;); 返回一个状态已变成 resolved 的 Promise 对象。 123let p1 = Promise.resolve(123); //打印p1 可以看到p1是一个状态置为resolved的Promise对象console.log(p1) Promise.reject 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。 Promise.prototype.then 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。 Promise.prototype.catch 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。 Promise.race 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。 Promise.all 12 类方法，多个 Promise 任务同时执行。如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。 如何理解 Promise 为了便于理解 Promise，大家除了要多加练习以外，最好的方式是能够将Promise的机制与现实生活中的例子联系起来，这样才能真正得到消化。 我们可以把 Promise 比作一个保姆，家里的一连串的事情，你只需要吩咐给他，他就能帮你做，你就可以去做其他事情了。 比如，某一天要出门办事，但是我还要买菜做饭送到老婆单位。 出门办的事情很重要，买菜做饭也重要。但我自己只能做一件事。这时我就可以把买菜做饭的事情交给保姆，我会告诉她： 你先去超市买菜。 用超市买回来的菜做饭。 将做好的饭菜送到老婆单位。 送到单位后打电话告诉我。我们知道，上面三步都是需要消耗时间的，我们可以理解为三个异步任务。利用 Promise 的写法来书写这个操作： 12345678910111213141516171819202122function 买菜(resolve，reject) &#123; setTimeout(function()&#123; resolve([&#x27;西红柿&#x27;、&#x27;鸡蛋&#x27;、&#x27;油菜&#x27;]); &#125;,3000)&#125;function 做饭(resolve, reject)&#123; setTimeout(function()&#123; //对做好的饭进行下一步处理。 resolve (&#123; 主食: &#x27;米饭&#x27;, 菜: [&#x27;西红柿炒鸡蛋&#x27;、&#x27;清炒油菜&#x27;] &#125;) &#125;,3000) &#125;function 送饭(resolve，reject)&#123; //对送饭的结果进行下一步处理 resolve(&#x27;老婆的么么哒&#x27;);&#125;function 电话通知我()&#123; //电话通知我后的下一步处理 给保姆加100块钱奖金;&#125; 好了，现在我整理好了四个任务，这时我需要告诉保姆，让他按照这个任务列表去做。这个过程是必不可少的，因为如果不告诉保姆，保姆不知道需要做这些事情。 123456789101112131415// 告诉保姆帮我做几件连贯的事情，先去超市买菜new Promise(买菜)//用买好的菜做饭.then((买好的菜)=&gt;&#123; return new Promise(做饭);&#125;)//把做好的饭送到老婆公司.then((做好的饭)=&gt;&#123; return new Promise(送饭);&#125;)//送完饭后打电话通知我.then((送饭结果)=&gt;&#123; 电话通知我();&#125;) 至此，我通知了保姆要做这些事情，然后我就可以放心地去办我的事情。 请一定要谨记：如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象。如果后续任务是同步任务，只需 return 一个结果即可。我们上面举的例子，除了电话通知我是一个同步任务，其余的都是异步任务，异步任务 return 的是 promise对象。 除此之外，一定谨记，一个 Promise 对象有三个状态，并且状态一旦改变，便不能再被更改为其他状态。 pending，异步任务正在进行。 resolved (也可以叫fulfilled)，异步任务执行成功。 rejected，异步任务执行失败。 Promise的使用总结Promise 这么多概念，初学者很难一下子消化掉，那么我们可以采取强制记忆法，强迫自己去记住使用过程。 首先初始化一个 Promise 对象，可以通过两种方式创建， 这两种方式都会返回一个 Promise 对象。 1、new Promise(fn) 2、Promise.resolve(fn) 然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。 then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如: 1234new Promise(fn).then(fn1(value）&#123; //处理value&#125;) 最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。 通常按照这三个步骤，你就能够应对绝大部分的异步处理场景。用熟之后，再去研究 Promise 各个函数更深层次的原理以及使用方式即可。 看到这里之后，我们便能回答上面的问题 4 和问题 5了。 Promsie 与事件循环Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环。 关于 Promise 在事件循环中还有一个 微任务的概念(microtask)，感兴趣的话可以看另外一篇关于nodejs 时间循环的文章 剖析nodejs的事件循环，虽然和浏览器端有些不同，但是Promise 微任务的执行时机相差不大。 Promise 的升级 ES6 出现了 generator 以及 async/await 语法，使异步处理更加接近同步代码写法，可读性更好，同时异常捕获和同步代码的书写趋于一致。上面的列子可以写成这样： 123456(async ()=&gt;&#123; let 蔬菜 = await 买菜(); let 饭菜 = await 做饭(蔬菜); let 送饭结果 = await 送饭(饭菜); let 通知结果 = await 通知我(送饭结果);&#125;)(); 需要记住的是，async/await也是基于 Promise 实现的，所以，我们有必要深入理解 Promise 的用法。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"浅谈js防抖和节流","slug":"浅谈js防抖和节流","date":"2020-08-02T09:41:10.000Z","updated":"2020-08-24T09:01:55.000Z","comments":true,"path":"2020/08/02/浅谈js防抖和节流/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E6%B5%85%E8%B0%88js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖和节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管就容易引起浏览器卡死。所以还是很有必要早点掌握的。（信我，你看完肯定就懂了） 从滚动条监听的例子说起先说一个常见的功能，很多网站会提供这么一个按钮：用于返回顶部。 这个按钮只会在滚动到距离顶部一定位置之后才出现，那么我们现在抽象出这个功能需求– 监听浏览器滚动事件，返回当前滚条与顶部的距离 这个需求很简单，直接写: 12345function showTop () &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = showTop 但是！ 在运行的时候会发现存在一个问题：这个函数的默认执行频率，太！高！了！。 高到什么程度呢？以chrome为例，我们可以点击选中一个页面的滚动条，然后点击一次键盘的【向下方向键】，会发现函数执行了8-9次！ 然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里，所以接着讨论如何优化这种场景。 防抖(debounce)基于上述场景，首先提出第一种思路：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后： 如果在200ms内没有再次触发滚动事件，那么就执行函数 如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时 效果：如果短时间内大量触发同一事件，只会执行一次函数。 实现：既然前面都提到了计时，那实现的关键就在于setTimeOut这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现： 123456789101112131415/** fn [function] 需要防抖的函数* delay [number] 毫秒，防抖期限值*/function debounce(fn,delay)&#123; let timer = null //借助闭包 return function() &#123; if(timer)&#123; clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时 timer = setTimeOut(fn,delay) &#125;else&#123; timer = setTimeOut(fn,delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时 &#125; &#125;&#125; 当然 上述代码是为了贴合思路，方便理解（这么贴心不给个赞咩？），写完会发现其实 time = setTimeOut(fn,delay)是一定会执行的，所以可以稍微简化下： 12345678910111213141516/*****************************简化后的分割线 ******************************/function debounce(fn,delay)&#123; let timer = null //借助闭包 return function() &#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(fn,delay) // 简化写法 &#125;&#125;// 然后是旧代码function showTop () &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = debounce(showTop,1000) // 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置 此时会发现，必须在停止滚动1秒以后，才会打印出滚动条位置。 到这里，已经把防抖实现了，现在给出定义： 对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。 节流(throttle)继续思考，使用上面的防抖方案来处理问题的结果是： 如果在限定时间段内，不断触发滚动事件（比如某个用户闲着无聊，按住滚动不断的拖来拖去），只要不停止触发，理论上就永远不会输出当前距离顶部的距离。 但是如果产品同学的期望处理方案是：即使用户不断拖动滚动条，也能在某个时间间隔之后给出反馈呢？（此处暂且不论哪种方案更合适，既然产品爸爸说话了我们就先考虑怎么实现） 其实很简单：我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间）。 效果：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 实现 这里借助setTimeout来做一个简单的实现，加上一个状态位valid来表示当前函数是否处于工作状态： 1234567891011121314151617181920212223242526function throttle(fn,delay)&#123; let valid = true return function() &#123; if(!valid)&#123; //休息时间 暂不接客 return false &#125; // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() =&gt; &#123; fn() valid = true; &#125;, delay) &#125;&#125;/* 请注意，节流函数并不止上面这种实现方案, 例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样 */// 以下照旧function showTop () &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = throttle(showTop,1000) 运行以上代码的结果是： 如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离 其他应用场景举例讲完了这两个技巧，下面介绍一下平时开发中常遇到的场景： 1、搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。2、页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况） 思考总结上述内容基于防抖和节流的核心思路设计了简单的实现算法，但是不代表实际的库（例如undercore js）的源码就直接是这样的，最起码的可以看出，在上述代码实现中，因为showTop本身的很简单，无需考虑作用域和参数传递，所以连apply都没有用到，实际上肯定还要考虑传递argument以及上下文环境（毕竟apply需要用到this对象）。这里的相关知识在本专栏《柯里化》和《this对象》的文章里也有提到。本文依然坚持突出核心代码，尽可能剥离无关功能点的思路行文因此不做赘述。 结合参看 https://www.cnblogs.com/goloving/p/8672361.html","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://perfectsymphony.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"call、apply和bind方法的用法以及区别","slug":"call、apply和bind方法的用法以及区别","date":"2020-08-02T09:37:08.000Z","updated":"2020-08-24T09:02:48.000Z","comments":true,"path":"2020/08/02/call、apply和bind方法的用法以及区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/call%E3%80%81apply%E5%92%8Cbind%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/","excerpt":"","text":"call、apply、bind的作用是改变函数运行时this的指向，所以先说清楚this。 以下是函数的调用方法： 当一个函数被保存为对象的一个方法时，如果调用表达式包含一个提取属性的动作，那么它就是被当做一个方法来调用，此时的this被绑定到这个对象。 12345678var a = 1var obj1 = &#123; a:2, fn:function()&#123; console.log(this.a) &#125;&#125;obj1.fn()//2 此时的this是指obj1这个对象，obj1.fn()实际上是obj1.fn.call(obj1)，事实上谁调用这个函数，this就是谁。补充一下，DOM对象绑定事件也属于方法调用模式，因此它绑定的this就是事件源DOM对象。如 123456document.addEventListener(&#x27;click&#x27;, function(e)&#123; console.log(this); setTimeout(function()&#123; console.log(this); &#125;, 200);&#125;, false); 点击页面，依次输出：document和window对象解析：点击页面监听click事件属于方法调用，this指向事件源DOM对象，即obj.fn.apply(obj)，setTimeout内的函数属于回调函数，可以这么理解，f1.call(null,f2)，所以this指向window。 函数调用模式： 就是普通函数的调用，此时的this被绑定到window 最普通的函数调用 1234function fn1()&#123; console.log(this)//window &#125;fn1() 函数嵌套 1234567function fn1()&#123; function fn2()&#123; console.log(this)//window &#125; fn2()&#125;fn1() 把函数赋值之后再调用 123456789var a = 1var obj1 = &#123; a:2, fn:function()&#123; console.log(this.a) &#125;&#125;var fn1 = obj1.fnfn1()//1 obj1.fn是一个函数function()&#123;console.log(this.a)&#125;，此时fn1就是不带任何修饰的函数调用，function()&#123;console.log(this.a)&#125;.call(undefined)，按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则： 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 因此上面的this绑定的就是window，它也被称为隐性绑定。如果你希望打印出2，可以修改fn1()为fn1.call(obj1)，显示地绑定this为obj1 回调函数 12345678910var a = 1function f1(fn)&#123; fn() console.log(a)//1&#125;f1(f2)function f2()&#123; var a = 2&#125; 改写代码如下： 123456var a = 1function f1()&#123; (function ()&#123;var a = 2&#125;)() console.log(a)//1&#125;f1() 仍旧是最普通的函数调用，f1.call(undefined)，this指向window，打印出的是全局的a。借此，我们终于可以解释为什么setTimeout总是丢失this了，因为它也就是一个回调函数而已。 1234567setTimeout(function() &#123; console.log(this)//window function fn()&#123; console.log(this)//window &#125; fn()&#125;, 0); 构造器调用模式: new一个函数时，背地里会将创建一个连接到prototype成员的新对象，同时this会被绑定到那个新对象上 1234567891011function Person(name,age)&#123;// 这里的this都指向实例 this.name = name this.age = age this.sayAge = function()&#123; console.log(this.age) &#125;&#125;var dot = new Person(&#x27;Dot&#x27;,2)dot.sayAge()//2 call call 方法第一个参数是要绑定给this的值，后面传入的是一个参数列表。当第一个参数为null、undefined的时候，默认指向window。 12var arr = [1, 2, 3, 89, 46]var max = Math.max.call(null, arr[0], arr[1], arr[2], arr[3], arr[4])//89 可以这么理解： 12345678obj1.fn() obj1.fn.call(obj1);fn1()fn1.call(null)f1(f2)f1.call(null,f2) 看一个例子： 123456789var obj = &#123; message: &#x27;My name is: &#x27;&#125;function getName(firstName, lastName) &#123; console.log(this.message + firstName + &#x27; &#x27; + lastName)&#125;getName.call(obj, &#x27;Dot&#x27;, &#x27;Dolby&#x27;) apply apply接受两个参数，第一个参数是要绑定给this的值，第二个参数是一个参数数组。当第一个参数为null、undefined的时候，默认指向window。 12var arr = [1,2,3,89,46]var max = Math.max.apply(null,arr)//89 可以这么理解： 12345678obj1.fn() obj1.fn.apply(obj1);fn1()fn1.apply(null)f1(f2)f1.apply(null,f2) 是不是觉得和前面写的call用法很像，事实上apply 和 call 的用法几乎相同, 唯一的差别在于：当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量。看一个例子： 123456789var obj = &#123; message: &#x27;My name is: &#x27;&#125;function getName(firstName, lastName) &#123; console.log(this.message + firstName + &#x27; &#x27; + lastName)&#125;getName.apply(obj, [&#x27;Dot&#x27;, &#x27;Dolby&#x27;])// My name is: Dot Dolby 可以看到，obj 是作为函数上下文的对象，函数 getName 中 this 指向了 obj 这个对象。参数 firstName 和 lastName 是放在数组中传入 getName 函数。 call和apply可用来借用别的对象的方法，这里以call()为例： 1234567891011var Person1 = function () &#123; this.name = &#x27;Dot&#x27;;&#125;var Person2 = function () &#123; this.getname = function () &#123; console.log(this.name); &#125; Person1.call(this);&#125;var person = new Person2();person.getname(); // Dot 从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。 对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。像上面的找一组数中最大值的例子，当然是用apply合理。 bind 和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。 bind返回值是函数 1234567891011var obj = &#123; name: &#x27;Dot&#x27;&#125;function printName() &#123; console.log(this.name)&#125;var dot = printName.bind(obj)console.log(dot) // function () &#123; … &#125;dot() // Dot bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 printName 中的 this 并没有被改变，依旧指向全局对象 window。 参数的使用 123456789function fn(a, b, c) &#123; console.log(a, b, c);&#125;var fn1 = fn.bind(null, &#x27;Dot&#x27;);fn(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); // A B Cfn1(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); // Dot A Bfn1(&#x27;B&#x27;, &#x27;C&#x27;); // Dot B Cfn.call(null, &#x27;Dot&#x27;); // Dot undefined undefined call 是把第二个及以后的参数作为 fn 方法的实参传进去，而 fn1 方法的实参实则是在 bind 中参数的基础上再往后排。 有时候我们也用bind方法实现函数珂里化，以下是一个简单的示例： 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 在低版本浏览器没有 bind 方法，我们也可以自己实现一个。 12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context, [].concat.call(args, [].slice.call(arguments))); &#125; &#125;&#125; 应用场景 求数组中的最大和最小值 123var arr = [1,2,3,89,46]var max = Math.max.apply(null,arr)//89var min = Math.min.apply(null,arr)//1 将类数组转化为数组 1var trueArr = Array.prototype.slice.call(arrayLike) 数组追加 12345var arr1 = [1,2,3];var arr2 = [4,5,6];var total = [].push.apply(arr1, arr2);//6// arr1 [1, 2, 3, 4, 5, 6]// arr2 [4,5,6] 判断变量类型 12345function isArray(obj)&#123; return Object.prototype.toString.call(obj) == &#x27;[object Array]&#x27;;&#125;isArray([]) // trueisArray(&#x27;dot&#x27;) // false 利用call和apply做继承 123456789101112function Person(name,age)&#123; // 这里的this都指向实例 this.name = name this.age = age this.sayAge = function()&#123; console.log(this.age) &#125;&#125;function Female()&#123; Person.apply(this,arguments)//将父元素所有方法在这里执行一遍就继承了&#125;var dot = new Female(&#x27;Dot&#x27;,2) 使用 log 代理 console.log 1234function log()&#123; console.log.apply(console, arguments);&#125;// 当然也有更方便的 var log = console.log() 总结call、apply和bind函数存在的区别: bind返回对应函数, 便于稍后调用； apply, call则是立即调用。 除此外, 在 ES6 的箭头函数下, call 和 apply 将失效, 对于箭头函数来说: 箭头函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象;所以不需要类似于var _this = this这种丑陋的写法 箭头函数不可以当作构造函数，也就是说不可以使用 new 命令, 否则会抛出一个错误 箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在. 如果要用, 可以用 Rest 参数代替 不可以使用 yield 命令, 因此箭头函数不能用作 Generator 函数，什么是Generator函数可自行查阅资料，推荐阅读阮一峰Generator 函数的含义与用法，Generator 函数的异步应用 参考资料： this 的值到底是什么？一次说清楚 一次性讲清楚apply/call/bind","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"jsonp返回的数据格式与普通json的区别","slug":"jsonp返回的数据格式与普通json的区别","date":"2020-08-02T09:36:01.000Z","updated":"2020-08-24T09:04:07.000Z","comments":true,"path":"2020/08/02/jsonp返回的数据格式与普通json的区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/jsonp%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E6%99%AE%E9%80%9Ajson%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"jsonp返回的数据格式与普通json的区别","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://perfectsymphony.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"变量提升必须注意的问题","slug":"变量提升必须注意的问题","date":"2020-08-02T09:34:36.000Z","updated":"2020-08-24T09:02:55.000Z","comments":true,"path":"2020/08/02/变量提升必须注意的问题/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%BF%85%E9%A1%BB%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"声明变量在使用一个变量的时候，我们必须先声明一个变量，我们共有 var，let，const 这三个关键字可选择，具体使用哪个关键字，那就要根据业务场景来使用。声明一个变量可以赋值为任何数据类型的，因为JS的松散性，然后要注意的是声明变量的时候可以简写。 1let a = 10, b = 20; 变量提升我们在使用变量或函数的时候，理解什么时候被初始化值的是至关重要。变量提升是指在声明一个变量之前就使用了变量，在全局作用域中，只有使用var关键字声明的变量才会变量提升，变量提升的时候浏览器只知道有这么一个变量，但你下面定义的值还没有赋值给这个变量，这时候变量的值是undefined的，等到浏览器执行到下面的代码的时候才是一个赋值的过程。所以变量提升的时候没有初始化值。用var声明变量的时候回给window增加一个相同变量名的属性，所以你也可以通过属性名的方式获取这个变量的值，当没有使用任何关键字声明时，只是给一个变量赋值时，变量也相当于给window增加一个相同变量名的属性。 1234567console.log(a); // -&gt; undefinedvar a = 10;console.log(a); // -&gt; 10console.log(window.a); // -&gt; 10b = 10;console.log(window.b); // -&gt; 10 函数提升定义一个函数可以使用函数声明和函数表达式，这两种方式在提升的时候也是有区别的，函数声明会提升到作用域的顶部，在提升的时候会分配一个内存空间，变量指向这个函数的内存空间，所以在定义一个函数之前是可以执行这个函数的，函数声明的方式定义函数会提升。而函数表达式就跟变量提升，仅仅只是声明，并没有给其赋值。 123456789fn1() // -&gt; &quot;函数声明&quot;function fn1() &#123; console.log(&quot;函数声明&quot;)&#125;fn2() // -&gt; &quot;fn2 is not a function&quot;var fn2 = function () &#123; console.log(&quot;函数表达式&quot;)&#125; 重复声明用var可以重复声明同一个变量，如果重复声明了，就相当于给变量赋值一样，用let和const在同一个作用域中是不可以重复声明同一个变量的，如果重复声明了会报错。关于函数表达式，如果重复的定义相同函数名的函数，后面的会覆盖前面的函数，因为JavaScript没有重载。 1234567891011var a = 10;var a = 100;console.log(a); // -&gt; 100function fn() &#123; return &quot;第一个fn函数&quot;&#125;function fn() &#123; return &quot;第二个fn函数&quot;&#125;console.log(fn()) // -&gt; &quot;第二个fn函数&quot; 特殊情况1、在块级作用域中（如if，for），var声明变量function定义函数的时候，他们都是只声明但还未初始化值。2、return语句下面的语句也是会提升的，变量是只提前声明，函数是声明跟初始化值一起完成。3、return本身这条语句不会提升。4、自执行函数不会提升。5、回调函数不会提升。 综合练习12345678var a = 1;function b() &#123; a = 10; return; function a() &#123;&#125;&#125;b();console.log(a); 答案：1 12345678910function foo()&#123; function bar() &#123; return 3; &#125; return bar(); function bar() &#123; return 8; &#125;&#125;alert(foo()); 答案：8 12345678function parent() &#123; var hoisted = &quot;I&#x27;m a variable&quot;; function hoisted() &#123; return &quot;I&#x27;m a function&quot;; &#125; return hoisted(); &#125;console.log(parent()); 答案：“TypeError: hoisted is not a function” 12345678910alert(foo());function foo() &#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125; 答案：3 123456var myVar = &#x27;foo&#x27;;(function() &#123; console.log(&#x27;Original value was: &#x27; + myVar); var myVar = &#x27;bar&#x27;; console.log(&#x27;New value is: &#x27; + myVar);&#125;)(); 答案：“Original value was: undefined”, “New value is: bar”","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"typeof与instanceof区别","slug":"typeof与instanceof区别","date":"2020-08-02T09:31:56.000Z","updated":"2020-08-24T09:04:42.000Z","comments":true,"path":"2020/08/02/typeof与instanceof区别/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/typeof%E4%B8%8Einstanceof%E5%8C%BA%E5%88%AB/","excerpt":"","text":"typeof可以判断数据类型，但是无法判断array和object，如何解决? typeof用于判断数据类型，返回值为6个字符串，分别为string、Boolean、number、function、object、undefined。 123456789101112131415var a = [34,4,3,54], b = 34, c = &#x27;adsfas&#x27;, d = function()&#123;console.log(&#x27;我是函数&#x27;)&#125;, e = true, f = null, g; console.log(typeof(a));//object console.log(typeof(b));//number console.log(typeof(c));//string console.log(typeof(d));//function console.log(typeof(e));//boolean console.log(typeof(f));//object console.log(typeof(g));//undefined 但是你可能会发现，typeof在判断null、array、object以及函数实例（new + 函数）时，得到的都是object。这使得在判断这些数据类型的时候，得不到真是的数据类型。由此引出instanceof。 instanceofinstance中文翻译为实例，因此instanceof的含义就不言而喻，判断该对象是谁的实例，同时我们也就知道instanceof是对象运算符。这里的实例就牵扯到了对象的继承，它的判断就是根据原型链进行搜寻，在对象obj1的原型链上如果存在另一个对象obj2的原型属性，那么表达式（obj1 instanceof obj2）返回值为true；否则返回false。 总结： typeof和instanceof都是用来判断变量类型的，两者的区别在于： typeof判断所有变量的类型，返回值有number，boolean，string，function，object，undefined。 typeof对于丰富的对象实例，只能返回”Object”字符串。instanceof用来判断对象，代码形式为obj1 instanceof obj2（obj1是否是obj2的实例），obj2必须为对象，否则会报错！其返回值为布尔值。 instanceof可以对不同的对象实例进行判断，判断方法是根据对象的原型链依次向下查询，如果obj2的原型属性存在obj1的原型链上，（obj1 instanceof obj2）值为true。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"}]},{"title":"css优先级和权重问题以及important优先级","slug":"css优先级和权重问题以及important优先级","date":"2020-08-02T09:30:32.000Z","updated":"2020-08-24T09:03:17.000Z","comments":true,"path":"2020/08/02/css优先级和权重问题以及important优先级/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/css%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Aimportant%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"css优先级和权重问题以及!important优先级css选择器大致可以分为四类： 行内样式; id选择器; class选择器; 元素选择器; 这四种选择器可以根据权重和权值比较决定渲染谁先谁后，谁大谁小。 一个selector的权重表示方式：0.0.0.0，按照计算规则给每位填充数字，对应位置相等，则比较下一位； 也有分别以1000、100、10、1四个权值系数对CSS选择器进行权重计算; 选择器类别 说明 权重表示 权值表示 行内样式 行内只有一个 style = “” （1.0.0.0）｜1000 id选择器 selector中使用了几个id，即#的个数 （0.1.0.0）｜ 100 类选择器 类,伪类,以及属性的个数如： .outerClass .buttonClass[type=”button”]:hover{}选择器中有2个类,1个属性,1个伪类 （0.0.1.0）｜ 10 元素选择器 伪元素和标签元素的个数，如： p:first-child选择器中有一个标签元素p和一个伪元素first-child （0.0.0.1）｜ 1 张鑫旭大神的256个class类名选择器干掉一个id选择器实例页面 ，我试了下256个好像也不行。。。 重点： !important 表示强制应用该样式，例如：button{ width: 150px !important;}，与以上的选择器相遇时，强制使用此样式； 如果比较后权重相同，那么后者覆盖前者，后渲染的胜出； 内联样式 &gt; id选择器样式 &gt; 类选择器样式 &gt; 元素选择器样式； CSS选择器的使用，应该尽量避免使用 !important 和 内联样式；id通常也是与class区分开使用，前者多用于JS中的结点定位，后者多用于CSS选择器。 重中之重，1000/100/10/1这种权值系数的比较方式只是便于理解，真实情况下10个class并不能逆转1个id。 eg:对权重排序正确的是：a) .list .box p 10 + 10 + 1 + 1 = 22 b) #list .box div span 100 + 10 + 1 +1 = 112 c) .list span 10 + 1 = 11 d) #list #box 100 + 100 = 200 e) p:last-child 1 = 1 f) style 1000 = 10000 f&gt;d&gt;b&gt;a&gt;c&gt;e","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"collapse、overflow、float这些特性相互叠加后会怎么样","slug":"collapse、overflow、float这些特性相互叠加后会怎么样","date":"2020-08-02T09:18:22.000Z","updated":"2020-08-24T09:03:06.000Z","comments":true,"path":"2020/08/02/collapse、overflow、float这些特性相互叠加后会怎么样/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/collapse%E3%80%81overflow%E3%80%81float%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E7%9B%B8%E4%BA%92%E5%8F%A0%E5%8A%A0%E5%90%8E%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/","excerpt":"","text":"position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？这是寒冬大神提出的一个题目，刚开始看到这题的时候完全不知道从什么地方回答起好，题目内容比较广泛，找不到针对点。后来我觉得这个题目应该能拆成几个点来回答：1、’display’、’position’ 和 ‘float’ 的相互关系；2、position跟display、overflow、float下的margin collapse。 一、’display’、’position’ 和 ‘float’ 的相互关系首先我们先来看下这3个属性。display 属性规定元素应该生成的框的类型。 block 象块类型元素一样显示，none 缺省值。象行内元素类型一样显示， inline-block 象行内元素一样显示，但其内容象块类型元素一样显示，list-item 象块类型元素一样显示，并添加样式列表标记（display 还有很多其他值设置，读者自行查找）。 position 属性规定元素的定位类型。 absolute表示生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位；fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位；relative生成相对定位的元素，相对于其正常位置进行定位；static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 Float也是是一种布局方式，它定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 在布局过程中也经常会使用它来达到左右并排布局的效果。那么这三种布局和框形成的关键特性( display )之间有什么关系呢，请看下面流程图： 转换对应表： 设定值 计算值 inline-table table inline, run-in, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block block 其他 同设定值 总的来说，可以把它看作是一个类似优先级的机制， “position:absolute” 和 “position:fixed” 优先级最高，有它存在的时候，浮动不起作用，’display’ 的值也需要调整； 其次，元素的 ‘float’ 特性的值不是 “none” 的时候或者它是根元素的时候，调整 ‘display’ 的值； 最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’ 特性值同设置值。 这从另一个侧面说明了一个问题：浮动或绝对定位的元素，只能是块元素或表格。 1. ‘display’ 的值为 ‘none’ 如果 ‘display’ 的值为 ‘none’，那么 ‘position’ 和 ‘float’ 不起作用。在这种情况下，元素不产生框。因此浮动和定位无效。 2. ‘position’ 的值是 ‘absolute’ 或 ‘fixed’ 否则，如果 ‘position’ 的值是 ‘absolute’ 或 ‘fixed’，框就是绝对定位的，’float’ 计算后的值应该是 ‘none’，并且，’display’ 会被按照上表设置。 框的位置将由 ‘top’，’right’，’bottom’ 和 ‘left’ 属性和该框的包含块确定。 也就是说，当元素是绝对定位时，浮动失效，’display’ 会被按规则重置。 示例代码： 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function getStyle(obj, style) &#123; var _style = (style == &quot;float&quot;) ? &quot;styleFloat&quot; : style; return document.defaultView ? document.defaultView.getComputedStyle(obj, null).getPropertyValue(style) : obj.currentStyle[_style.replace(/-[a-z]/g, function() &#123; return arguments[0].charAt(1).toUpperCase(); &#125;)]; &#125; window.onload = function() &#123; document.getElementById(&quot;info&quot;).innerHTML = &quot;float : &quot; + getStyle(document.getElementById(&quot;test&quot;), &quot;float&quot;) + &quot;&lt;br/&gt;display : &quot; + getStyle(document.getElementById(&quot;test&quot;), &quot;display&quot;); &#125;&lt;/script&gt;&lt;div id=&quot;test&quot; style=&quot;position:absolute; float:left;display:inline;&quot;&gt;&lt;/div&gt;&lt;div id=&quot;info&quot;&gt;&lt;/div&gt; 上面代码中有一个既是绝对定位又是浮动的元素，以上代码可取出其 ‘display’ 和 ‘float’ 的计算值。 IE 中，’float’ 值和 ‘display’ 的特性值未发生变化，还是 “float: left; display: inline”。 其他浏览器中计算后的结果是：”float: none; display: block”。 3. ‘float’ 的值不是 “none” 如果 ‘float’ 的值不是 “none”，该框浮动并且 ‘display’ 会被按照转换对应表设置。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getStyle(obj, style) &#123; var _style = (style == &quot;float&quot;) ? &quot;styleFloat&quot; : style; return document.defaultView ? document.defaultView.getComputedStyle(obj, null).getPropertyValue(style) : obj.currentStyle[_style.replace(/-[a-z]/g, function() &#123; return arguments[0].charAt(1).toUpperCase(); &#125;)]; &#125; window.onload = function() &#123; document.getElementById(&quot;info&quot;).innerHTML = &quot;display : &quot; + getStyle(document.getElementById(&quot;test&quot;), &quot;display&quot;); &#125;&lt;/script&gt;&lt;span id=&quot;test&quot; style=&quot;width:100px; height:100px; border:1px solid red;float:left;&quot;&gt;float span&lt;/span&gt;&lt;div id=&quot;info&quot;&gt;&lt;/div&gt; 按照规则，SPAN 是行内元素，因此不能够设置其宽度和高度。但是浮动后，’display’ 值按照转换对应表设置后，成为块级元素。 其他浏览器中： 4. 元素是根元素 如果元素是根元素，’display’ 的值按照转换对应表设置。 5. 否则，应用指定的 ‘display’ 特性值。 二、position跟display、overflow、float下的margin collapse。margin collapse我觉得这里的意思应该是Collapsing margins，即外边距折叠，指的是毗邻的两个或多个外边距 (margin) 会合并成一个外边距。 其中所说的 margin 毗邻，可以归结为以下两点： 这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开。 这些 margin 都处于普通流中。 1.两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠。 注意一点，在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； 只有在一个元素的 height 是 “auto” 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。 示例代码： 1234567&lt;div style=&quot;border:1px solid red; width:100px;&quot;&gt; &lt;div style=&quot;margin:50px 0; background-color:green; height:50px; width:50px;&quot;&gt; &lt;div style=&quot;margin:20px 0;&quot;&gt; &lt;div style=&quot;margin:100px 0;&quot;&gt;B&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果图： 以上代码中，margin 会把 B 的包含块撑开。 如果一个元素的 height 特性的值不是 auto，那么它的 margin-bottom 和它子元素的 margin-bottom 不算相邻，因此，不会发生折叠。 margin-top 没有此限制，所以是 100px，margin-bottom 没有折叠，只有 50px。 垂直方向 是指具体的方位，只有垂直方向的 margin 才会折叠，也就是说，水平方向的 margin 不会发生折叠的现象。 折叠后 margin 的计算 1). 参与折叠的 margin 都是正值 例子： 12&lt;div style=&quot;height:50px; margin-bottom:50px;width:50px; background-color: red;&quot;&gt;A&lt;/div&gt;&lt;div style=&quot;height:50px;margin-top:100px; width:50px; background-color: green;&quot;&gt;B&lt;/div&gt; 示意图： 在 margin 都是正数的情况下，取其中 margin 较大的值为最终 margin 值。 2). 参与折叠的 margin 都是负值 当 margin 都是负值的时候，取的是其中绝对值较大的，然后，从 0 位置，负向位移。 示例代码： 12&lt;div style=&quot;height:100px; margin-bottom:-75px;width:100px; background-color: red;&quot;&gt;A&lt;/div&gt;&lt;div style=&quot;height:100px;margin-top:-50px; margin-left:50px; width:100px; background-color: green;&quot;&gt;B&lt;/div&gt; 示意图： 3). 参与折叠的 margin 中有正值，有负值 如果，毗邻的 margin 中有正值，同时存在负值会怎样呢？有正有负，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 示例代码： 12&lt;div style=&quot;height:50px; margin-bottom:-50px;width:50px; background-color: red;&quot;&gt;A&lt;/div&gt;&lt;div style=&quot;height:50px;margin-top:100px; width:50px; background-color: green;&quot;&gt;B&lt;/div&gt; 示意图： 上面的例子最终的 margin 应该是 100 + (-50) = 50px。 4). 相邻的 margin 要一起参与计算，不得分步计算 要注意，相邻的元素不一定非要是兄弟节点，父子节点也可以，即使不是兄弟父子节点也可以相邻。 而且，在计算时，相邻的 margin 要一起参与计算，不得分步计算。 一个复杂的实例： 12345678910&lt;div style=&quot;margin:50px 0;background-color:green; width:50px;&quot;&gt; &lt;div style=&quot;margin:-60px 0;&quot;&gt; &lt;div style=&quot;margin:150px 0;&quot;&gt;A&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;margin:-100px 0;background-color:green; width:50px;&quot;&gt; &lt;div style=&quot;margin:-120px 0;&gt; &lt;div style=&quot;margin:200px 0;&quot;&gt;B&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 错误的计算方式：算 A 和 B 之间的 margin，分别算 A 和其父元素的折叠，然后与其父元素的父元素的折叠，这个值算出来之后，应该是 90px。依此法算出 B 的为 80px；然后，A和B折叠，margin 为 90px。 请注意，多个 margin 相邻折叠成一个 margin，所以计算的时候，应该取所有相关的值一起计算，而不能分开分步来算。 以上例子中，A 和 B 之间的 margin 折叠产生的 margin，是6个相邻 margin 折叠的结果。将其 margin 值分为两组： 正值：50px，150px，200px负值：-60px，-100px，-120px根据有正有负时的计算规则，正值的最大值为 200px，负值中绝对值最大的是 -120px，所以，最终折叠后的 margin 应该是 200 + (-120) = 80px。 2.浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠 浮动元素的 margin 在垂直方向上也不会发生 margin 折叠，即使和它相邻的子元素也不会。 1234&lt;div style=&quot;margin-bottom:50px;width:50px; height:50px; background-color:green;&quot;&gt;A&lt;/div&gt;&lt;div style=&quot;margin-top:50px; width:100px; height:100px; background-color:green; float:left;&quot;&gt; &lt;div style=&quot;margin-top:50px;background-color:gold;&quot;&gt;B&lt;/div&gt;&lt;/div&gt; 示意图： 两个绿色的块儿之间，相距100px，而若 B 和它的浮动包含块发生 margin 折叠的话，金色的条应该位于绿色块的最上方，显然，没有发生折叠。inline-block 元素、绝对定位元素的 margin同样如此， 不会和垂直方向上其他元素的 margin 折叠。 3.创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠 以 “overflow : hidden” 的元素为例： 123&lt;div style=&quot;margin-top:50px; width:100px; height:100px; background-color:green; overflow:hidden;&quot;&gt; &lt;div style=&quot;margin-top:50px; background-color:gold;&quot;&gt;B&lt;/div&gt;&lt;/div&gt; 若 B 和它的 “overflow:hidden” 包含块发生 margin 折叠的话，金色的条应该位于绿色块的最上方，否则，没有发生。 示意图： 4.元素自身的 margin-bottom 和 margin-top 相邻时也会折叠 自身 margin-bottom 和 margin-top 相邻，只能是自身内容为空，垂直方向上 border、padding 为 0。 示例： 123&lt;div style=&quot;border:1px solid red; width:100px;&quot;&gt; &lt;div style=&quot;margin-top: 100px;margin-bottom: 50px;&gt;&lt;/div&gt;&lt;/div&gt; 以上代码运行后，我们讲得到的是红色边框的正方形，方框的宽高都应该是 100px，高度不应该是 150px。 示意图： 参考资料来源: http://www.w3help.org/zh-cn/","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"css3中定位模型之position属性的使用方法","slug":"css3中定位模型之position属性的使用方法","date":"2020-08-02T09:12:11.000Z","updated":"2020-11-22T03:23:04.000Z","comments":true,"path":"2020/08/02/css3中定位模型之position属性的使用方法/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/css3%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%9E%8B%E4%B9%8Bposition%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、position元素介绍 属性值 描述 所属类别 static 默认值。没有定位，元素出现在正常的流中(忽略top,bottom,left,right或者z-index声明) relative 元素遵循默认的文档流。相对于元素的原位置进行移动，周围元素忽略该元素的移动。需要设置top、bottom、left、right值进行定位 相对定位 absolute 元素脱离正常的文档流相对于包含该元素的第一个非静态定位的元素进行定位，若不满足条件，则会根据最外层的window进行定位。需要设置top、bottom、left、right值进行定位 绝对定位 fixed 元素脱离正常文档流。相对于最外层的window进行定位，固定在屏幕上的某个位置，不因屏幕滚动而消失。需要设置top、bottom、left、right值进行定位 绝对定位(固定定位) inherit 继承父元素的position值 设置position属性只会让元素脱离文档流，需要设置偏移属性使元素移动。包括4个偏移属性，分别为top、bottom、left、right。 具体描述如下表格所示： 偏移属性 描述 left 表示向元素左端插入多少距离，正值使元素右移多少距离。 right 表示向元素右端插入多少距离，正值使元素左移多少距离。 bottom 表示向元素下方插入多少距离，正值使元素上移多少距离。 top 表示向元素上方插入多少距离，正值使元素下移多少距离。 偏移属性的值可以为负值，负值时向相同方向移动。一般设置时设置一个或两个偏移量即可。 当元素中设置position为非默认值后，该元素会成为设定位置的元素。在元素变成设定位置后，就成为了最近的绝对定位后代元素的定位参考点，即该元素为设置为绝对定位子元素的第一个非静态定位的元素。 目前所有主流的浏览器都支持position属性的使用，但注意所有IE浏览器均不支持inherit属性值。 二、属性值详细介绍首先设置示例的显示内容，分别设定了三个div块元素，并分别设置class属性值。HTML源代码如下： 12345&lt;div class=&quot;div0&quot;&gt; &lt;div class=&quot;div1 div&quot;&gt;This is div1.&lt;/div&gt; &lt;div class=&quot;div2 div&quot;&gt;This is div2.&lt;/div&gt; &lt;div class=&quot;div3 div&quot;&gt;This is div3.&lt;/div&gt;&lt;/div&gt; 设置原始示例的显示效果，为了截图容易理解，将body设置为3px的红色边框。包围三个div块的大div块设置1px的黑边框，灰色的背景色以及50%的宽度。三个div块则设置相同的边框和100px的高度。CSS源代码如下： 123456789101112131415body &#123; border: 3px solid red;&#125;.div0 &#123; border: 1px solid black; width: 50%; background-color: #f0f0f0; margin: 50px;&#125;.div &#123; height: 100px; border: 1px solid black; margin: 20px; padding: 5px;&#125; 最终的示例效果图如下： 1、relative——使元素相对于文档流的位置偏移一段距离 元素遵循默认的文档流，相对于元素的原位置进行移动，周围元素忽略该元素的移动。需要设置top、bottom、left、right的值进行相对定位。举个栗子：设置第二个div块的position属性为relative，并且设置偏移量为向右偏移50px、向下偏移50px。 123456.div2 &#123; background-color: #e0e0e0; position: relative; left: 50px; top: 50px;&#125; 可以看到如下效果图中，第一和第三块div块并没有移动位置，说明relative属性值使元素遵循默认的文档流。设置偏移量后，第二块div块则向右、向下分别偏移50px。 123456.div2 &#123; background-color: #e0e0e0; position: relative; left: -50px; top: 50px;&#125; 当设置左偏移量为-50px时，则如下图所示，第二元素块向左偏移了50px。 2、absolute——使元素相对于文档流的位置或最近定位祖先元素的位置偏移一定的距离元素脱离默认的文档流，相对于包含该元素的第一个非静态定位的元素进行定位。需要设置top、bottom、left、right值进行绝对定位。 对于元素，使用width、height可以设置它的尺寸，设定百分数是相对于最近定位祖先元素的尺寸。 举个栗子*2：设置第二个div块的position属性为absolute，并且设置偏移量为向右偏移50px、向下偏移50px。注意此时没有设置该元素的父元素的position值为非默认值。 123456.div2 &#123; background-color: #e0e0e0; position: absolute; left: 20px; top: 20px;&#125; 可以从图中看到，第三块div元素向上移动，第二块元素脱离了原来的文档流。而在没有设置该元素的父元素的position值为非默认值时，第二块div元素块是相对于body的值来向右、向下偏移的。 再来看设置了该元素的父元素的position值为非默认值的情况。 1234567.div0 &#123; border: 1px solid black; width: 50%; background-color: #f0f0f0; margin: 50px; position: relative;&#125; 当设置了该元素的父元素的position值为非默认值的情况时，此时的第二块div元素块则是相对于包含三个元素块的大div元素块来进行向右、向下的偏移。 3、fixed——使元素相对于视口偏移一定的距离 元素脱离默认的文档流，相对于最外层的window进行定位，固定在屏幕上的某个位置，不因屏幕滚动而消失。需要设置top、bottom、left、right值进行定位。 举个栗子*3：设置第二个div块的position属性为fixed，并且设置偏移量为向右偏移20px、向下偏移200px。 123456.div2 &#123; background-color: #e0e0e0; position: fixed; right: 20px; top: 200px;&#125; 从图中看出，第二个div元素块的位置在右下角，是相对于视口进行了向左20px、向下200px的偏移。并且在页面滑动时，也会保持着同样的位置不变。 三、Z-indexZ-index可用于设置元素之间的层叠顺序。只对于定位元素有效，即只对于position属性的属性值为absolute、relative和fixed有效。静态定位元素按照文档出现顺序从后往前进行堆叠。设定位置元素忽略文档出现顺序，根据z-index值由小到大的顺序从后往前堆叠，即Z-index的值越高表示元素显示的顺序越优先。设置为负值z-index的设定位置元素位于静态定位元素和非设定位置浮动元素之下。z-index值不必为连续值，其默认值为auto。当设置的值相同时，后加载的元素优先显示。 举个栗子*4：将relative示例的元素设置-index值为-1。 1234567.div2 &#123; background-color: #e0e0e0; position: relative; left: 50px; top: 50px; z-index: -1;&#125; 从图中可以看到，当元素的z-index设置为负值时，设定位置元素是位于静态定位元素之下，即是di第二个div元素的父元素div0的位置之下。 四、实际应用——使用绝对定位显示二级菜单使用无序列表和Flex布局导航栏菜单，HTML源代码如下： 123456789101112&lt;ul class=&quot;MenuWrap&quot;&gt; &lt;li id=&quot;ListItem1&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;ListItem&quot; &gt;Home&lt;/a&gt; &lt;ul class=&quot;MenuWrap2&quot; id=&quot;MenuWrap2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;ListItem2&quot;&gt;Item1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;ListItem2&quot;&gt;Item2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;ListItem2&quot;&gt;Item3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li id=&quot;ListItem2&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;ListItem&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;ListItem3&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;ListItem&quot;&gt;Products&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 将包裹二级菜单的ul元素设置的position属性设置为非默认值relative。再将二级菜单的position属性设置为绝对定位，根据一级菜单的高度设置偏移量。并且将二级菜单的显示方式display属性设置为none值表示不显示。最后再通过JavaScript设置鼠标悬浮经过一级菜单栏时显示二级菜单栏。CSS源代码如下： 1234567891011121314151617181920212223242526272829303132.MenuWrap &#123; background-color: #f0f0f0; min-height: 2.75em; display: flex; align-items: center; list-style-type: none; position: relative;&#125;.ListItem &#123; color: black; text-decoration: none; padding:0px 20px;&#125;ul.MenuWrap2 &#123; padding: 0px;&#125;.MenuWrap2 &#123; list-style-type: none; background-color: #f0f0f0; min-width: 4.5em; text-align: center; position: absolute; top: 2.75em; display: none;&#125;.MenuWrap2 li &#123; padding-bottom: 5px;&#125;.ListItem2 &#123; color:black; text-decoration: none;&#125; 总结元素的定位模型中需要区分每个属性值的不同定位方式，分为绝对定位、相对定位、固定定位以及默认定位和继承父元素。其中绝对定位和固定定位都脱离原本的文档流，而相对定位则遵循原本的文档流。设置元素的定位方式后，还需要指定偏移量。可以从上、右、下、左四个方向进行偏移。并且可以利用Z-index属性设置元素之间的层叠顺序。 定位模型是在CSS中设置元素位置的重要方式之一，使用该模型可以实现页面常用的菜单导航、悬浮公告等效果。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"移动端Web页面适配方案","slug":"移动端Web页面适配方案","date":"2020-08-02T09:10:05.000Z","updated":"2020-08-24T09:02:37.000Z","comments":true,"path":"2020/08/02/移动端Web页面适配方案/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/%E7%A7%BB%E5%8A%A8%E7%AB%AFWeb%E9%A1%B5%E9%9D%A2%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"移动端Web页面适配方案","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"flex","slug":"flex","date":"2020-08-02T09:04:21.000Z","updated":"2021-01-11T06:15:16.000Z","comments":true,"path":"2020/08/02/flex/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/flex/","excerpt":"","text":"Flex 布局教程：语法篇Flex 布局教程：实例篇grid布局","categories":[],"tags":[{"name":"flex","slug":"flex","permalink":"https://perfectsymphony.github.io/tags/flex/"}]},{"title":"CSS中的BFC详解","slug":"CSS中的BFC详解","date":"2020-08-02T07:48:38.000Z","updated":"2020-08-24T09:03:23.000Z","comments":true,"path":"2020/08/02/CSS中的BFC详解/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/CSS%E4%B8%AD%E7%9A%84BFC%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"CSS中的BFC详解一、何为BFCBFC（Block Formatting Context）格式化上下文，是web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 二、形成BFC的条件1、浮动元素，float除none以外的值。2、定位元素，position（absolute、fixed）。3、display为以下其中之一的值inline-block、table-cell、table-table-caption。4、overflow除了 visible 以外的值（hidden、auto、scroll）。 三、BFC的特性1、内部的Box会在垂直方向上一个接一个的放置。2、垂直方向上的距离由margin决定。3、bfc的区域不会与float的元素区域重叠。4、计算bfc的高度时，浮动元素也参与计算。5、bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 下面使用案例来帮助认识理解： 四、实践是检验真理的唯一标准（1）BFC中的盒子对齐特性的第一条是：内部的Box（块级元素）会在垂直方向上一个接一个的放置。（这条特性不必纠结，即便不在BFC里块级盒子也会垂直排列） （2）外边距折叠特性的第二条：垂直方向上的距离由margin决定在常规文档流中，两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准。 html: 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; css: 123456789101112131415161718.container &#123; overflow: hidden; width: 100px; height: 100px; background-color: red;&#125;.box1 &#123; height: 20px; margin: 10px 0; background-color: green;&#125;.box2 &#123; height: 20px; margin: 20px 0; background-color: green;&#125; 这里我门可以看到，第一个子盒子有上边距（不会发生margin穿透的问题）；两个子盒子的垂直距离为20px而不是30px，因为垂直外边距会折叠，间距以较大的为准。 那么有没有方法让垂直外边距不折叠呢？答案是：有。特性的第5条就说了：bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素，同样外面的元素不会影响到BFC内的元素。所以就让box1或box2再处于另一个BFC中就行了。 html: 123456 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt; css: 12345678910111213141516171819202122.container &#123; overflow: hidden; width: 100px; height: 100px; background-color: red;&#125;.wrapper &#123; overflow: hidden;&#125;.box1 &#123; height: 20px; margin: 10px 0; background-color: green;&#125;.box2 &#123; height: 20px; margin: 20px 0; background-color: green;&#125; （3）不被浮动元素覆盖以常见的两栏布局为例。 左边固定宽度，右边不设宽，因此右边的宽度自适应，随浏览器窗口大小的变化而变化。 html: 12&lt;div class=&quot;column&quot;&gt;&lt;/div&gt;&lt;div class=&quot;column&quot;&gt;&lt;/div&gt; css: 12345678910111213.column:nth-of-type(1) &#123; float: left; width: 200px; height: 300px; margin-right: 10px; background-color: red;&#125;.column:nth-of-type(2) &#123; overflow: hidden;/*创建bfc */ height: 300px; background-color: purple;&#125; 三栏布局: 左右两边固定宽度，中间不设宽，因此中间的宽度自适应，随浏览器的大小变化而变化。 html: 12345&lt;div class=&quot;contain&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;/div&gt;&lt;/div&gt; css: 1234567891011121314151617.column:nth-of-type(1),.column:nth-of-type(2) &#123; float: left; width: 100px; height: 300px; background-color: green;&#125;.column:nth-of-type(2) &#123; float: right;&#125;.column:nth-of-type(3) &#123; overflow: hidden; /*创建bfc*/ height: 300px; background-color: red;&#125; 也可以用来防止字体环绕： 众所周知，浮动的盒子会遮盖下面的盒子，但是下面盒子里的文字是不会被遮盖的，文字反而还会环绕浮动的盒子。这也是一个比较有趣的特性。 html: 12345&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;p&gt;你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好&lt;/p&gt; css: (1) 环绕 1234567891011.left &#123; float: left; width: 100px; height: 100px; background-color: yellow;&#125;p &#123; background-color: green; /* overflow: hidden; */&#125; （2）利用bfc防止环绕 1234567891011.left &#123; float: left; width: 100px; height: 100px; background-color: yellow;&#125;p &#123; background-color: green; overflow: hidden;&#125; （4）BFC包含浮动的块 利用overflow:hidden清除浮动嘛，因为浮动的盒子无法撑出处于标准文档流的父盒子的height。这个就不过多解释了。 如果你有任何想要补充的欢迎issues","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"}]},{"title":"html相关面试题","slug":"html相关面试题","date":"2020-08-02T07:15:34.000Z","updated":"2020-11-23T09:57:12.000Z","comments":true,"path":"2020/08/02/html相关面试题/","link":"","permalink":"https://perfectsymphony.github.io/2020/08/02/html%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"一、什么是HTML语义化标签语义化的标签，说明让标签有自己的含义。 一行文字 一行文字 如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签则没有独特的含义。 二、语义化标签的特点 代码结构清晰，方便阅读，有利于团队合作开发。 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。 有利于搜索引擎优化（SEO）。 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 三、常见的语义化标签 因此我们在写页面结构时，应尽量使用有 语义的HTML 标签 &lt;title&gt;：页面主体内容。 &lt;hn&gt;：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。 &lt;ul&gt;：无序列表。 &lt;ol&gt;：有序列表。 &lt;header&gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。 &lt;nav&gt;：标记导航，仅对文档中重要的链接群使用。 &lt;main&gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。 &lt;article&gt;：定义外部的内容，其中的内容独立于文档的其余部分。 &lt;section&gt;：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 &lt;aside&gt;：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。 &lt;footer&gt;：页脚，只有当父级是body时，才是整个页面的页脚。 &lt;small&gt;：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。 &lt;strong&gt;：和 em 标签一样，用于强调文本，但它强调的程度更强一些。 &lt;em&gt;：将其中的文本表示为强调的内容，表现为斜体。 &lt;mark&gt;：使用黄色突出显示部分文本。 &lt;figure&gt;：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。 &lt;figcaption&gt;：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。 &lt;cite&gt;：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。 &lt;blockquoto&gt;：定义块引用，块引用拥有它们自己的空间。 &lt;q&gt;：短的引述（跨浏览器问题，尽量避免使用）。 &lt;time&gt;：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。 &lt;abbr&gt;：简称或缩写。 &lt;dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。 &lt;del&gt;：移除的内容。 &lt;ins&gt;：添加的内容。 &lt;code&gt;：标记代码。 &lt;meter&gt;：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签） &lt;progress&gt;：定义运行中的进度（进程）。 二、什么是回流，什么是重绘，有什么区别？html 加载时发生了什么在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。 什么是回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 什么是重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 区别他们的区别很大：回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流当页面布局和几何属性改变时就需要回流比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变 扩展：能得知回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系因为这些机制的存在，所以浏览器会帮助我们优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 触发重排途径添加、删除或改变元素的可见性使用JavaScript更改DOM会导致回流 添加、删除或改变css样式直接应用CSS样式或者类名都可能会改变布局。比如更改元素的宽度会影响同一DOM树及其周围的所有元素 CSS3 animations 和 transitions动画的每一帧都会引起回流 用offsetWidth 和 offsetHeight读取元素的offsetWidth和offsetHeight属性会触发回流来计算属性值。 用户行为一些用户行为会触发回流，比如：hover、在输入框中输入文本、调整窗口大小、更改字体大小、切换样式表或字体。 减少回流和重绘的技巧减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求。 具体方法： 1、不要1个1个改变元素的样式属性，最好直接改变className，但className是预先定义好的样式，不是动态的，如果你要动态改变一些样式，则使用cssText来改变，见下面代码：1234567891011// 不好的写法 var left = 1; var top = 1; el.style.left = left + &quot;px&quot;; el.style.top = top + &quot;px&quot;; // 比较好的写法 el.className += &quot; className1&quot;; // 比较好的写法 el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;; 2、让要操作的元素进行”离线处理”，处理完后一起更新，这里所谓的”离线处理”即让元素不存在于render tree中，比如：a) 使用documentFragment或div等元素进行缓存操作，这个主要用于添加元素的时候，大家应该都用过，就是先把所有要添加的元素添加到1个div(这个div也是新加的)，最后才把这个div append到body中。 b) 先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。 3、不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，就先读取到变量中进行缓存，以后用的时候直接读取变量就可以了，见下面代码：1234567891011121314// 别这样写 for(循环) &#123; elel.style.left = el.offsetLeft + 5 + &quot;px&quot;; elel.style.top = el.offsetTop + 5 + &quot;px&quot;; &#125; // 这样写好点 var left = el.offsetLeft,top = el.offsetTop,s = el.style; for(循环) &#123; left += 10; top += 10; s.left = left + &quot;px&quot;; s.top = top + &quot;px&quot;; &#125; 4、操作会影响到render tree中的多少节点以及影响的方式，影响越多，花费肯定就越多。比如现在很多人使用jquery的animate方法移动元素来展示一些动画效果，想想下面2种移动的方法：123456789// block1是position:absolute 定位的元素，它移动会影响到它父元素下的所有子元素。 // 因为在它移动过程中，所有子元素需要判断block1的z-index是否在自己的上面， // 如果是在自己的上面,则需要重绘,这里不会引起回流 $(&quot;#block1&quot;).animate(&#123;left:50&#125;); // block2是相对定位的元素,这个影响的元素与block1一样，但是因为block2非绝对定位 // 而且改变的是marginLeft属性，所以这里每次改变不但会影响重绘， // 还会引起父元素及其下元素的回流 $(&quot;#block2&quot;).animate(&#123;marginLeft:50&#125;); 使用最佳布局方案不要使用内联样式和table布局！内联样式会在下载HTML时影响布局，并触发额外的reflow。table布局开销很大，因为解析器需要多次传递去计算单元格维度，使用table时应用fixed定位有一定的优化效果，因为列的宽度是基于标题行的内容。主页面布局应用flexbox也会有性能影响，因为在HTML下载的时候，flex items的位置和尺寸可能会变化。 最小化CSS规则的数量css规则越少，重排越快，要尽量避免复杂的css选择器。如果您使用的是Bootstrap这样的框架，那么这一点尤其成问题——很少有站点使用了框架提供的所有样式。像Unused CSS、uCSS、grunt-uncss和gulp-uncss这样的工具可以显著减少样式定义和文件大小。 最小化DOM层级稍微复杂一点——减小DOM树大小和每个分支的元素数量。文档越小越浅，回流越快。如果不需要支持古老的浏览器，可以删除不必要的包裹元素 从文档流中移除复杂的动效通过使用position: absolute; 或者 position: fixed;来使有动效的元素脱离文档流，这可以在不影响文档流中的其它元素的情况下更新尺寸和位置。 更新隐藏的元素通过display: none;来隐藏的元素在改变时不会触发重绘和重排，可以的话，在元素可见之前进行更改。 行内元素和块级元素的区别1）、行内元素 ①：设置宽高无效 ②：对margin设置左右方向有效，而上下无效，padding设置都无效 ③：不会自动换行 2）、块级元素 ①：可以设置宽高 ②：设置margin和padding都有效 ③：可以自动换行 ④：多个块状，默认排列从上到下 JS数字递归求和： 12345function sum (n)&#123; if(n == 0) return 0; return n + sum(n-1)&#125;console.log(sum(100))","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://perfectsymphony.github.io/tags/HTML/"}]}],"categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://perfectsymphony.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"问题记录","slug":"问题记录","permalink":"https://perfectsymphony.github.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://perfectsymphony.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://perfectsymphony.github.io/tags/JavaScript/"},{"name":"flex","slug":"flex","permalink":"https://perfectsymphony.github.io/tags/flex/"},{"name":"vue","slug":"vue","permalink":"https://perfectsymphony.github.io/tags/vue/"},{"name":"CSS","slug":"CSS","permalink":"https://perfectsymphony.github.io/tags/CSS/"},{"name":"跨域","slug":"跨域","permalink":"https://perfectsymphony.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"http","slug":"http","permalink":"https://perfectsymphony.github.io/tags/http/"},{"name":"Git","slug":"Git","permalink":"https://perfectsymphony.github.io/tags/Git/"},{"name":"HTML","slug":"HTML","permalink":"https://perfectsymphony.github.io/tags/HTML/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://perfectsymphony.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Nginx","slug":"Nginx","permalink":"https://perfectsymphony.github.io/tags/Nginx/"},{"name":"webpack","slug":"webpack","permalink":"https://perfectsymphony.github.io/tags/webpack/"},{"name":"uni-app","slug":"uni-app","permalink":"https://perfectsymphony.github.io/tags/uni-app/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://perfectsymphony.github.io/tags/NodeJS/"},{"name":"性能优化","slug":"性能优化","permalink":"https://perfectsymphony.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]}