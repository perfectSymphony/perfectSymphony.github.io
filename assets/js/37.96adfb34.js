(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{395:function(v,_,t){"use strict";t.r(_);var a=t(45),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"从输入url到页面加载完成发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面加载完成发生了什么"}},[v._v("#")]),v._v(" 从输入url到页面加载完成发生了什么")]),v._v(" "),t("p",[v._v("这是一道经典的面试题，这道题没有一个标准的答案，它涉及很多的知识点，面试官会通过这道题了解你对哪一方面的知识比较擅长，然后继续追问看看你的掌握程度。当然我写的这些也只是我的一些简单的理解，从前端的角度出发，我觉得首先回答必须包括几个基本的点，然后在根据你的理解深入回答。")]),v._v(" "),t("p",[v._v("1、浏览器的地址栏输入URL并按下回车。")]),v._v(" "),t("p",[v._v("2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。")]),v._v(" "),t("p",[v._v("3、DNS解析URL对应的IP。")]),v._v(" "),t("p",[v._v("4、根据IP建立TCP连接（三次握手）。")]),v._v(" "),t("p",[v._v("5、HTTP发起请求。")]),v._v(" "),t("p",[v._v("6、服务器处理请求，浏览器接收HTTP响应。")]),v._v(" "),t("p",[v._v("7、渲染页面，构建DOM树。")]),v._v(" "),t("p",[v._v("8、关闭TCP连接（四次挥手）。")]),v._v(" "),t("p",[v._v("说完整个过程的几个关键点后我们再来展开的说一下。")]),v._v(" "),t("h2",{attrs:{id:"一、url"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、url"}},[v._v("#")]),v._v(" 一、URL")]),v._v(" "),t("p",[v._v("我们常见的RUL是这样的:"),t("code",[v._v("http://www.baidu.com")]),v._v(", 这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。除此之外URL还会包含一些路径、查询和其他片段，例如："),t("code",[v._v("http://www.tuicool.com/search?kw=%E4%")]),v._v("。我们最常见的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。URL的中间部分为域名或者是IP，之后就是端口号了。通常端口号不常见是因为大部分的都是使用默认端口，如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题。")]),v._v(" "),t("h2",{attrs:{id:"二、缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、缓存"}},[v._v("#")]),v._v(" 二、缓存")]),v._v(" "),t("p",[v._v("说完URL我们说说浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，对比缓存。")]),v._v(" "),t("p",[t("strong",[v._v("强制缓存判断HTTP首部字段：cache-control，Expires。")])]),v._v(" "),t("p",[v._v("Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。")]),v._v(" "),t("p",[v._v("cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。 如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。")]),v._v(" "),t("p",[t("strong",[v._v("对比缓存通过HTTP的last-modified，Etag字段进行判断。")])]),v._v(" "),t("p",[v._v("last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。")]),v._v(" "),t("p",[v._v("Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。")]),v._v(" "),t("p",[v._v("在第一次请求服务器的时候在获取资源之后是会先把该资源缓存在本地的，同时服务器response返回了一个响应头ETag，ETag全称Entity Tag，用来标识一个资源。在具体的实现中，ETag可以是资源的hash值，也可以是一个内部维护的版本号。但不管怎样，ETag应该能反映出资源内容的变化，这是Http缓存可以正常工作的基础。服务器对于hello world这个字符串使用上述返回的ETag来表示，只要hello world这个资源不变，这个Etag就不会变。")]),v._v(" "),t("p",[v._v("客户端第二次请求服务器的时候，利用请求头If-None-Match来告诉服务器自己已经有个ETag为xxx的资源。如果服务器上的资源没有变化，也就是说服务器上的资源的ETag也是xxx的话，服务器就不会再返回该资源的内容，而是返回一个304的响应，告诉浏览器该资源没有变化，缓存有效，浏览器将直接调用本地缓存。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYXzPf.png",alt:"aYXzPf.png"}})]),v._v(" "),t("h2",{attrs:{id:"三、dns域名解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、dns域名解析"}},[v._v("#")]),v._v(" 三、DNS域名解析")]),v._v(" "),t("p",[v._v("我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。")]),v._v(" "),t("p",[v._v("首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。")]),v._v(" "),t("p",[v._v("如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。")]),v._v(" "),t("p",[v._v("如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。")]),v._v(" "),t("p",[v._v("最后迭代查询，按根域服务器 ->顶级域,.cn->第二层域，hb.cn ->子域，www.hb.cn的顺序找到IP地址。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYXvIP.jpg",alt:"aYXvIP.jpg"}})]),v._v(" "),t("p",[v._v("递归查询，按上一级DNS服务器->上上级->....逐级向上查询找到IP地址。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYXXVI.jpg",alt:"aYXXVI.jpg"}})]),v._v(" "),t("h2",{attrs:{id:"四、tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、tcp连接"}},[v._v("#")]),v._v(" 四、TCP连接")]),v._v(" "),t("p",[v._v("在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。")]),v._v(" "),t("p",[v._v("第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；")]),v._v(" "),t("p",[v._v("第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；")]),v._v(" "),t("p",[v._v("第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")]),v._v(" "),t("p",[v._v("完成三次握手，客户端与服务器开始传送数据。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYXLqA.png",alt:"aYXLqA.png"}})]),v._v(" "),t("h2",{attrs:{id:"五、浏览器向服务器发送http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、浏览器向服务器发送http请求"}},[v._v("#")]),v._v(" 五、浏览器向服务器发送HTTP请求")]),v._v(" "),t("p",[v._v("完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。\n"),t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYXjat.jpg",alt:"aYXjat.jpg"}})]),v._v(" "),t("h2",{attrs:{id:"六、浏览器接收响应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、浏览器接收响应"}},[v._v("#")]),v._v(" 六、浏览器接收响应")]),v._v(" "),t("p",[v._v("服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。")]),v._v(" "),t("p",[v._v("状态码主要包括以下部分")]),v._v(" "),t("p",[v._v("1xx：指示信息–表示请求已接收，继续处理。")]),v._v(" "),t("p",[v._v("2xx：成功–表示请求已被成功接收、理解、接受。")]),v._v(" "),t("p",[v._v("3xx：重定向–要完成请求必须进行更进一步的操作。")]),v._v(" "),t("p",[v._v("4xx：客户端错误–请求有语法错误或请求无法实现。")]),v._v(" "),t("p",[v._v("5xx：服务器端错误–服务器未能实现合法的请求。")]),v._v(" "),t("p",[v._v("响应头主要由Cache-Control、 Connection、Date、Pragma等组成。")]),v._v(" "),t("p",[v._v("响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。")]),v._v(" "),t("h2",{attrs:{id:"七、页面渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、页面渲染"}},[v._v("#")]),v._v(" 七、页面渲染")]),v._v(" "),t("p",[v._v("如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYjSG8.png",alt:"aYjSG8.png"}})]),v._v(" "),t("p",[v._v("在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。")]),v._v(" "),t("p",[v._v("Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。")]),v._v(" "),t("p",[v._v("Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。")]),v._v(" "),t("p",[v._v("所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。")]),v._v(" "),t("p",[v._v("下面这些动作有很大可能会是成本比较高的：")]),v._v(" "),t("p",[v._v("1、增加、删除、修改DOM结点时，会导致Reflow或Repaint")]),v._v(" "),t("p",[v._v("2、移动DOM的位置，或是搞个动画的时候")]),v._v(" "),t("p",[v._v("3、内容发生变化")]),v._v(" "),t("p",[v._v("4、修改CSS样式的时候")]),v._v(" "),t("p",[v._v("5、Resize窗口的时候（移动端没有这个问题），或是滚动的时候")]),v._v(" "),t("p",[v._v("6、修改网页的默认字体时")]),v._v(" "),t("h2",{attrs:{id:"基本上来说-reflow有如下的几个原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本上来说-reflow有如下的几个原因"}},[v._v("#")]),v._v(" 基本上来说，reflow有如下的几个原因：")]),v._v(" "),t("p",[v._v("1、Initial，网页初始化的时候")]),v._v(" "),t("p",[v._v("2、Incremental，一些js在操作DOM树时")]),v._v(" "),t("p",[v._v("3、Resize，某些元件的尺寸变了")]),v._v(" "),t("p",[v._v("4、StyleChange，如果CSS的属性发生变化了")]),v._v(" "),t("p",[v._v("5、Dirty，几个Incremental的reflow发生在同一个frame的子树上")]),v._v(" "),t("p",[v._v("八、关闭TCP连接或继续保持连接")]),v._v(" "),t("p",[v._v("通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/02/aYj9xg.png",alt:"aYj9xg.png"}})]),v._v(" "),t("p",[v._v("第一次挥手是浏览器发完数据后，发送FIN请求断开连接。")]),v._v(" "),t("p",[v._v("第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。")]),v._v(" "),t("p",[v._v("这样浏览器需要返回ACK表示同意，也就是第四次挥手。")]),v._v(" "),t("p",[v._v("至此从浏览器地址栏输入URL到页面呈现到你面前的整个过程就分析完了。")])])}),[],!1,null,null,null);_.default=s.exports}}]);