(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{431:function(t,r,s){"use strict";s.r(r);var e=s(45),n=Object(e.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"bff架构设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bff架构设计"}},[t._v("#")]),t._v(" BFF架构设计")]),t._v(" "),s("p",[t._v("BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。")]),t._v(" "),s("p",[t._v("最近在公司的微服务架构中遇到了一些多终端访问接口的问题，不同的终端拥有不同的接口服务，有不同的操作数据的能力，针对这种业务场景做出了调研，我们是否可以在不同的访问层进行业务逻辑处理，获取不同的数据内容呢？")]),t._v(" "),s("p",[t._v("早在微服务出现的初期就已经存在类似的业务需求出现，而且衍生出了一套成熟的解决方案，那就是BFF，可以针对不用业务场景来提供对应的服务接口，每一种业务场景之间完全独立。")]),t._v(" "),s("h2",{attrs:{id:"演进过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#演进过程"}},[t._v("#")]),t._v(" 演进过程")]),t._v(" "),s("p",[t._v("在传统的应用程序中，我们一般只将接口提供给一种类型的终端使用。")]),t._v(" "),s("p",[s("font",{attrs:{size:"4px",color:"#f00"}},[t._v("单端调用基础服务")])],1),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sY7HS0",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sY7HS0.png",alt:"sY7HS0.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("传统的应用程序内提供的接口是有业务针对性的，这种类型的接口如果独立出来再提供给别的系统再次使用是一件比较麻烦的事情，设计初期的高耦合就决定了这一点。")]),t._v(" "),s("p",[s("font",{attrs:{size:"4px",color:"#f00"}},[t._v("多端直接调用基础服务")])],1),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sYHKpt",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sYHKpt.png",alt:"sYHKpt.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("如果我们的接口同时提供给web、移动端使用，移动端仅用来采集数据以及数据的展示，而web端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。")]),t._v(" "),s("p",[s("font",{attrs:{size:"4px",color:"#f00"}},[t._v("多端共用一个BFF")])],1),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sYHtts",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sYHtts.png",alt:"sYHtts.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("针对多端共用服务接口的场景，我们将基础的数据服务与BFF进行了"),s("font",{attrs:{size:"7px",color:"#f00"}},[t._v("分离")]),t._v("，数据服务仅提供数据的增删改查，并不过多涉及业务的判断处理，所有业务判断处理都交给BFF来把控，遇到的一些业务逻辑异常也同样由BFF格式化处理后展示给访问端点。")],1),t._v(" "),s("p",[t._v("这种设计方式同样存在一定的问题，虽然基础服务与BFF进行了分离，我们只需要在BFF层面进行业务判断处理，但是多个端共用一个BFF，也会导致代码编写复杂度增高、代码可阅读性降低、多端业务耦合。")]),t._v(" "),s("p",[s("font",{attrs:{size:"4px",color:"#f00"}},[t._v("每个端提供一个BFF")])],1),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sYH5nO",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sYH5nO.png",alt:"sYH5nO.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("如果我们为每一个端点都提供一个BFF，每个端点的BFF处理自身的业务逻辑，需要数据时从基础服务内获取，然后在接口返回之前进行组装数据用于实例化返回对象。")]),t._v(" "),s("p",[t._v("这样基础服务如果有新功能添加，BFF几乎不会受到影响，而我们如果后期把App端点进行拆分成Android、IOS时我们只需要将app-bff进行拆分为android-bff、ios-bff，基础服务同样也不会受到影响")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sYb8v6",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sYb8v6.png",alt:"sYb8v6.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("这样每当新增一个访问端点时，我们需要修改的地方也只有网关的转发以及添加一个BFF即可，基础服务内提供的服务接口我们完全可以复用，因为基础服务提供的接口都是没有业务针对性的！！！")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("在微服务架构设计中，BFF起到了一个业务聚合的关键作用，可以 通过openfeign、restTemplate调用基础服务来获取数据，将获取到的数据进行组装返回结果对象，BFF解决了业务场景问题，也同样带来了一些问题，如下所示：")]),t._v(" "),s("p",[t._v("响应时间延迟（服务如果是内网之间访问，延迟时间较低）\n编写起来较为浪费时间（因为在基础服务上添加的一层转发，所以会多写一部分代码）\n业务异常处理（统一格式化业务异常的返回内容）\n分布式事务（微服务的通病）")]),t._v(" "),s("p",[s("font",{attrs:{size:"8px",color:"#f00"}},[t._v("提问：")])],1),t._v(" "),s("p",[s("font",{attrs:{size:"5px",color:"#f00"}},[t._v("采用BFF架构与多端公用、单一的API有什么优点了？")])],1),t._v(" "),s("p",[t._v("它能够满足因不同客户端特殊的交互引起的对新接口的要求，所以一开始就会针对相应的设备设计好对应的接口。如果使用单一、通用的API，我们一开始并没有考虑到特殊需求，那么有新的请求需要出现时，可能会出现以下问题：\n(1)如果添加新的接口，这样容易造成接口的不稳定；\n(2)如果考虑在原有的接口上进行修改，可能需要会产生一些的耦合，破坏单一职责。")]),t._v(" "),s("p",[t._v("考虑这样一个简单例子，因为移动APP的屏幕限制，在某一个列表页我们只需要展示一些关键的信息，但是由于调用的是服务端提供统一的API，服务端在设计的时候只考虑到了web端，返回所有的字段信息，但这些对于移动端而言都是无用的。在优化性能时处理这样的问题时，服务器端就需要新增接口或者通过引入相关耦合来解决这样的问题。而使用BFF在很大程度能避免这样的问题。\n使用BFF的另一个优点就是当由于某一客户端需要调用调用多个不同的服务端接口来实现某一功能时，可以直接在对应的BFF层编写相应的API，而不会影响到基层的公共服务，且客户端不用直接向多个后台发起调用，可以优化性能。")]),t._v(" "),s("p",[s("font",{attrs:{size:"5px",color:"#f00"}},[t._v("贴一张用来总结的大图：")])],1),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sYOCUe",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sYOCUe.png",alt:"sYOCUe.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgchr.com/i/sYqKL8",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s3.ax1x.com/2021/01/12/sYqKL8.png",alt:"sYqKL8.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("从这个技术体系图中看到，作为应用服务层的API服务就是BFF，他们会从基础业务服务如客户服务、订单服务、产品服务等微服务中获取数据，进行一定的聚合和裁剪返回个某个具体业务线的前端应用，前端应用可能是SPA也可能是H5应用。BFF层的API服务，我们在实践中大部分都使用了ASP.NET Core进行开发，同时也在尝试使用Go进行开发，也让前端有兴趣的同事引入进来用Go进行BFF的开发。但是，在基础服务层面即前面所说的业务中台层，还是由后端同事使用ASP.NET Core开发，确保质量。")])])}),[],!1,null,null,null);r.default=n.exports}}]);