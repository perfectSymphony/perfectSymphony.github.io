<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>perfectSymphony の 博客</title>
  
  
  <link href="https://perfectsymphony.github.io/atom.xml" rel="self"/>
  
  <link href="https://perfectsymphony.github.io/"/>
  <updated>2021-01-24T12:51:48.353Z</updated>
  <id>https://perfectsymphony.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFF架构设计</title>
    <link href="https://perfectsymphony.github.io/2021/01/14/BFF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://perfectsymphony.github.io/2021/01/14/BFF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-14T04:01:06.000Z</published>
    <updated>2021-01-24T12:51:48.353Z</updated>
    
    <content type="html"><![CDATA[<p>BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。</p><p>最近在公司的微服务架构中遇到了一些多终端访问接口的问题，不同的终端拥有不同的接口服务，有不同的操作数据的能力，针对这种业务场景做出了调研，我们是否可以在不同的访问层进行业务逻辑处理，获取不同的数据内容呢？</p><p>早在微服务出现的初期就已经存在类似的业务需求出现，而且衍生出了一套成熟的解决方案，那就是BFF，可以针对不用业务场景来提供对应的服务接口，每一种业务场景之间完全独立。</p><h4 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h4><p>在传统的应用程序中，我们一般只将接口提供给一种类型的终端使用。</p><p><font size="4px" color="#f00">单端调用基础服务</font></p><p><a href="https://imgchr.com/i/sY7HS0"><img src="https://s3.ax1x.com/2021/01/12/sY7HS0.png" alt="sY7HS0.png"></a></p><p>传统的应用程序内提供的接口是有业务针对性的，这种类型的接口如果独立出来再提供给别的系统再次使用是一件比较麻烦的事情，设计初期的高耦合就决定了这一点。</p><p><font size="4px" color="#f00">多端直接调用基础服务</font></p><p><a href="https://imgchr.com/i/sYHKpt"><img src="https://s3.ax1x.com/2021/01/12/sYHKpt.png" alt="sYHKpt.png"></a></p><p>如果我们的接口同时提供给web、移动端使用，移动端仅用来采集数据以及数据的展示，而web端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。</p><p><font size="4px" color="#f00">多端共用一个BFF</font></p><p><a href="https://imgchr.com/i/sYHtts"><img src="https://s3.ax1x.com/2021/01/12/sYHtts.png" alt="sYHtts.png"></a></p><p>针对多端共用服务接口的场景，我们将基础的数据服务与BFF进行了<font size="7px" color="#f00">分离</font>，数据服务仅提供数据的增删改查，并不过多涉及业务的判断处理，所有业务判断处理都交给BFF来把控，遇到的一些业务逻辑异常也同样由BFF格式化处理后展示给访问端点。</p><p>这种设计方式同样存在一定的问题，虽然基础服务与BFF进行了分离，我们只需要在BFF层面进行业务判断处理，但是多个端共用一个BFF，也会导致代码编写复杂度增高、代码可阅读性降低、多端业务耦合。</p><p><font size="4px" color="#f00">每个端提供一个BFF</font></p><p><a href="https://imgchr.com/i/sYH5nO"><img src="https://s3.ax1x.com/2021/01/12/sYH5nO.png" alt="sYH5nO.png"></a></p><p>如果我们为每一个端点都提供一个BFF，每个端点的BFF处理自身的业务逻辑，需要数据时从基础服务内获取，然后在接口返回之前进行组装数据用于实例化返回对象。</p><p>这样基础服务如果有新功能添加，BFF几乎不会受到影响，而我们如果后期把App端点进行拆分成Android、IOS时我们只需要将app-bff进行拆分为android-bff、ios-bff，基础服务同样也不会受到影响</p><p><a href="https://imgchr.com/i/sYb8v6"><img src="https://s3.ax1x.com/2021/01/12/sYb8v6.png" alt="sYb8v6.png"></a></p><p>这样每当新增一个访问端点时，我们需要修改的地方也只有网关的转发以及添加一个BFF即可，基础服务内提供的服务接口我们完全可以复用，因为基础服务提供的接口都是没有业务针对性的！！！</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在微服务架构设计中，BFF起到了一个业务聚合的关键作用，可以 通过openfeign、restTemplate调用基础服务来获取数据，将获取到的数据进行组装返回结果对象，BFF解决了业务场景问题，也同样带来了一些问题，如下所示：</p><p>响应时间延迟（服务如果是内网之间访问，延迟时间较低）<br>编写起来较为浪费时间（因为在基础服务上添加的一层转发，所以会多写一部分代码）<br>业务异常处理（统一格式化业务异常的返回内容）<br>分布式事务（微服务的通病）</p><p><font size="8px" color="#f00">提问：</font></p><p><font size="5px" color="#f00">采用BFF架构与多端公用、单一的API有什么优点了？</font></p><p>它能够满足因不同客户端特殊的交互引起的对新接口的要求，所以一开始就会针对相应的设备设计好对应的接口。如果使用单一、通用的API，我们一开始并没有考虑到特殊需求，那么有新的请求需要出现时，可能会出现以下问题：<br>(1)如果添加新的接口，这样容易造成接口的不稳定；<br>(2)如果考虑在原有的接口上进行修改，可能需要会产生一些的耦合，破坏单一职责。</p><p>考虑这样一个简单例子，因为移动APP的屏幕限制，在某一个列表页我们只需要展示一些关键的信息，但是由于调用的是服务端提供统一的API，服务端在设计的时候只考虑到了web端，返回所有的字段信息，但这些对于移动端而言都是无用的。在优化性能时处理这样的问题时，服务器端就需要新增接口或者通过引入相关耦合来解决这样的问题。而使用BFF在很大程度能避免这样的问题。<br>使用BFF的另一个优点就是当由于某一客户端需要调用调用多个不同的服务端接口来实现某一功能时，可以直接在对应的BFF层编写相应的API，而不会影响到基层的公共服务，且客户端不用直接向多个后台发起调用，可以优化性能。</p><p><font size="5px" color="#f00">贴一张用来总结的大图：</font></p><p><a href="https://imgchr.com/i/sYOCUe"><img src="https://s3.ax1x.com/2021/01/12/sYOCUe.png" alt="sYOCUe.png"></a></p><p><a href="https://imgchr.com/i/sYqKL8"><img src="https://s3.ax1x.com/2021/01/12/sYqKL8.png" alt="sYqKL8.png"></a></p><p>从这个技术体系图中看到，作为应用服务层的API服务就是BFF，他们会从基础业务服务如客户服务、订单服务、产品服务等微服务中获取数据，进行一定的聚合和裁剪返回个某个具体业务线的前端应用，前端应用可能是SPA也可能是H5应用。BFF层的API服务，我们在实践中大部分都使用了ASP.NET Core进行开发，同时也在尝试使用Go进行开发，也让前端有兴趣的同事引入进来用Go进行BFF的开发。但是，在基础服务层面即前面所说的业务中台层，还是由后端同事使用ASP.NET Core开发，确保质量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。&lt;/p&gt;
&lt;p&gt;最近在公司的微服务架构中遇到了一些多终端访问接口的问题，不同的终端拥有不同的接口服务，有不同的操作数据的能力，针对这种业务场景</summary>
      
    
    
    
    
    <category term="架构" scheme="https://perfectsymphony.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Uncaught TypeError: Cannot assign to read only property exports of object</title>
    <link href="https://perfectsymphony.github.io/2021/01/12/Uncaught-TypeError-Cannot-assign-to-read-only-property-exports-of-object/"/>
    <id>https://perfectsymphony.github.io/2021/01/12/Uncaught-TypeError-Cannot-assign-to-read-only-property-exports-of-object/</id>
    <published>2021-01-12T03:03:06.000Z</published>
    <updated>2021-01-12T03:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vue项目打包后生成的dist文件部署到GitHub page上之后，访问时，报<code>Uncaught TypeError: Cannot assign to read only property &#39;exports&#39; of object &#39;#&lt;Object&gt;&#39;</code></p></blockquote><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>webpack 2中不允许混用import和module.exports </p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>一、每个页面模块目录通过一个 index.js 主入口来导出（<code>module.exports</code>）对应的vue文件，然后 <code>router.js</code> 中通过 <code>require</code> 方法去引入资源。</p><p>这一做法是没毛病的，因为这是组织（webpack 2）允许的。</p><p>二、如果好好的<code>require</code>不用，非要用 <code>import</code> 那么请不要和 <code>module.exports</code> 混合服用，因为这是组织不允许的，此时便会报标题的错。（Uncaught TypeError: Cannot assign to read only property ‘exports’ of object ‘#<Object>‘）</p><p>三、如果你还是要用 import 方法来引入资源的话，你可以放弃 module.exports ，直接引入vue文件路径，因为 import 和 export default 是组织运行的。</p><p>四、使用<code>babel</code> 的 <a class="link"   href="https://github.com/airbnb/babel-plugin-dynamic-import-node" >plugins babel-plugin-dynamic-import-node<i class="fas fa-external-link-alt"></i></a>。它只做一件事就是将所有的<code>import()</code>转化为<code>require()</code>，这样就可以用这个插件将所有异步组件都用同步的方式引入，并结合 <a class="link"   href="https://babeljs.io/docs/en/config-files/#env-option" >BABEL_ENV<i class="fas fa-external-link-alt"></i></a> 这个<code>babel</code>环境变量，让它只作用于开发环境下，在开发环境中将所有<code>import()</code>转化为<code>require()</code>，这种方案解决了之前重复打包的问题，同时对代码的侵入性也很小，你平时写路由的时候只需要按照官方<a class="link"   href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" >文档<i class="fas fa-external-link-alt"></i></a>路由懒加载的方式就可以了，其它的都交给<code>babel</code>来处理，当你不想用这个方案的时候，也只要将它从<code>babel</code>的 <code>plugins</code>中移除就可以了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&#x27;env&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;development&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;plugins&#x27;</span>: [<span class="string">&#x27;dynamic-import-node&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>1、<code>exports</code> 导出的东西需要 <code>require</code> 引入！</p><p>2、<code>export</code> 导出的东西需要 <code>import</code> 引入！</p><p>3、在webpack 2中<code>不允许混用 import</code> 和 <code>module.exports</code></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>其实正确地去理解这个报错的话，就一定要去整明白 require 和 import 的区别！</p><blockquote><p>node编程中最重要的思想就是模块化，import和require都是被模块化所使用。<br>1、遵循规范<br><code>require</code> / <code>exports</code> 是<code>CommonJS</code>的一部分<br><code>import</code> / <code>export</code> 是ES6的新规范，如果要兼容浏览器的话必须转化成es5的语法<br>2、调用时间<br><code>require</code> 是运行时调用，所以<code>require</code>理论上可以运用在代码的任何地方<br>import 是编译时调用，所以必须放在文件开头<br>3、本质<br><code>require</code> 是赋值过程，其实<code>require</code>的结果就是对象、数字、字符串、函数等，再把<code>require</code>的结果赋值给某个变量<br><code>import</code> 是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，<code>import</code>语法会被转码为<code>require</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;vue项目打包后生成的dist文件部署到GitHub page上之后，访问时，报&lt;code&gt;Uncaught TypeError: Cannot assign to read only property &amp;#39;exports&amp;#39; of o</summary>
      
    
    
    
    
    <category term="问题记录" scheme="https://perfectsymphony.github.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>算法总结</title>
    <link href="https://perfectsymphony.github.io/2021/01/04/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://perfectsymphony.github.io/2021/01/04/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-04T09:46:27.000Z</published>
    <updated>2021-01-04T09:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 用任意一种语言实现一个函数，判断一个给定整数数组中是否存在某两个元素之和恰好等于一个给定值 k，</span><br><span class="line"> 存在则返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。该函数的输入参数有两个，第一个参数为整数数组 nums，第二个参数为整数 k，返回值为布尔值。</span><br><span class="line"> 可以参考以下签名，写出实现。【请不要使用排序！要求时间复杂度为 O(n)，n 为数组长度】</span><br><span class="line"></span><br><span class="line">// JavaScript</span><br><span class="line">var checkTwoSum = <span class="keyword">function</span>(nums, k) &#123;</span><br><span class="line">    var temp = [];</span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">      var dif = k-nums[i];</span><br><span class="line">      <span class="keyword">if</span>(temp[dif] != undefined)&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-手动实现一种时间复杂度为-O-n-log-n-的排序算法，可用任意语言实现，也可以只写出伪代码。"><a href="#2-手动实现一种时间复杂度为-O-n-log-n-的排序算法，可用任意语言实现，也可以只写出伪代码。" class="headerlink" title="2. 手动实现一种时间复杂度为 O(n log n) 的排序算法，可用任意语言实现，也可以只写出伪代码。"></a>2. 手动实现一种时间复杂度为 O(n log n) 的排序算法，可用任意语言实现，也可以只写出伪代码。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二分法</span><br><span class="line"> * @param &#123;number[]&#125; nums1</span><br><span class="line"> * @param &#123;number[]&#125; nums2</span><br><span class="line"> * @<span class="built_in">return</span> &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line"> var intersection = <span class="keyword">function</span>(nums1, nums2) &#123;</span><br><span class="line">    <span class="built_in">let</span> res = new Set();</span><br><span class="line">    nums2 = nums2.sort((a,b) =&gt; a - b);</span><br><span class="line">    <span class="built_in">let</span> binarySearch = (arr,val) =&gt; &#123;</span><br><span class="line">        <span class="built_in">let</span> left = 0;</span><br><span class="line">        <span class="built_in">let</span> right = arr.length - 1;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="built_in">let</span> mid = (left + right) &gt;&gt; 1;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] === val)&#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; val)&#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i = 0;i &lt; nums1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(binarySearch(nums2,nums1[i]))&#123;</span><br><span class="line">            res.add(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> [...res];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://perfectsymphony.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于面向对象</title>
    <link href="https://perfectsymphony.github.io/2021/01/04/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://perfectsymphony.github.io/2021/01/04/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-01-04T09:08:28.000Z</published>
    <updated>2021-01-04T09:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ES5实现面向对象"><a href="#ES5实现面向对象" class="headerlink" title="ES5实现面向对象"></a>ES5实现面向对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 面向对象继承  组合使用原型链和构造函数</span></span><br><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, friends</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.friends = friends;</span><br><span class="line">    <span class="comment">// this.say = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log(this.name+&#x27;的朋友&#x27;+this.friends+&#x27;今年&#x27;+this.age+&#x27;岁了&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&#x27;的朋友&#x27;</span>+<span class="built_in">this</span>.friends+<span class="string">&#x27;今年&#x27;</span>+<span class="built_in">this</span>.age+<span class="string">&#x27;岁了&#x27;</span>, <span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, friends, school</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承父类所有实例属性(获得父类构造函数中的属性)</span></span><br><span class="line">    Person.call(<span class="built_in">this</span>, name, age, friends)</span><br><span class="line">    <span class="built_in">this</span>.school = school <span class="comment">// 添加新的子类属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类的原型方法 (获得父类原型链上的属性和方法)</span></span><br><span class="line"><span class="comment">// ES3 </span></span><br><span class="line"><span class="comment">// Student.prototype = new Person()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 Object.create()</span></span><br><span class="line"><span class="comment">// 从本质上讲，createObject()对传入其中的对象执行了一次浅复制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function createObject(proto) &#123;</span></span><br><span class="line"><span class="comment">//     function F() &#123; &#125;</span></span><br><span class="line"><span class="comment">//     F.prototype = proto;</span></span><br><span class="line"><span class="comment">//     return new F();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student.prototype = Object.create(Person.prototype)</span></span><br><span class="line"><span class="comment">// // 设置 constructor 属性指向 Student</span></span><br><span class="line"><span class="comment">// Student.prototype.constructor = Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类方法</span></span><br><span class="line">Student.prototype.saySchool = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&#x27;的朋友&#x27;</span>+<span class="built_in">this</span>.friends+<span class="string">&#x27;今年&#x27;</span>+<span class="built_in">this</span>.age+<span class="string">&#x27;岁了&#x27;</span>, <span class="string">&#x27;在&#x27;</span>+<span class="built_in">this</span>.school+<span class="string">&#x27;读一年级&#x27;</span>, <span class="string">&#x27;student&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;小黑&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">&#x27;小黄&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;小华&#x27;</span>, <span class="string">&#x27;清华小学&#x27;</span>)</span><br><span class="line">person.say();</span><br><span class="line">student.saySchool();</span><br></pre></td></tr></table></figure><h4 id="ES6实现面向对象"><a href="#ES6实现面向对象" class="headerlink" title="ES6实现面向对象"></a>ES6实现面向对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 实现方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, friends</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&#x27;的朋友&#x27;</span>+<span class="built_in">this</span>.friends+<span class="string">&#x27;今年&#x27;</span>+<span class="built_in">this</span>.age+<span class="string">&#x27;岁了&#x27;</span>, <span class="string">&#x27;person ES6&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">extends</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, friends, school</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, friends, <span class="string">&#x27;Student&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.school = school</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">saySchool</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&#x27;的朋友&#x27;</span>+<span class="built_in">this</span>.friends+<span class="string">&#x27;今年&#x27;</span>+<span class="built_in">this</span>.age+<span class="string">&#x27;岁了&#x27;</span>, <span class="string">&#x27;在&#x27;</span>+<span class="built_in">this</span>.school+<span class="string">&#x27;读一年级&#x27;</span>, <span class="string">&#x27;student ES6&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person1(<span class="string">&#x27;小明&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;小黑&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> student1 = <span class="keyword">new</span> Student1(<span class="string">&#x27;小黄&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;小华&#x27;</span>, <span class="string">&#x27;清华小学&#x27;</span>)</span><br><span class="line">person1.say();</span><br><span class="line">student1.saySchool();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ES5实现面向对象&quot;&gt;&lt;a href=&quot;#ES5实现面向对象&quot; class=&quot;headerlink&quot; title=&quot;ES5实现面向对象&quot;&gt;&lt;/a&gt;ES5实现面向对象&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://perfectsymphony.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>flex之flex为1的含义</title>
    <link href="https://perfectsymphony.github.io/2020/12/30/flex%E4%B9%8Bflex%E4%B8%BA1%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://perfectsymphony.github.io/2020/12/30/flex%E4%B9%8Bflex%E4%B8%BA1%E7%9A%84%E5%90%AB%E4%B9%89/</id>
    <published>2020-12-30T14:06:30.000Z</published>
    <updated>2020-12-30T14:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-flex是由三个属性组成"><a href="#一-flex是由三个属性组成" class="headerlink" title="一. flex是由三个属性组成:"></a>一. flex是由三个属性组成:</h4><h5 id="1-flex-grow-存在剩余空间-为正-分配"><a href="#1-flex-grow-存在剩余空间-为正-分配" class="headerlink" title="1. flex-grow: 存在剩余空间, 为正, 分配"></a>1. flex-grow: 存在剩余空间, 为正, 分配</h5><p>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。在「flex」属性中该值如果被省略则默认为1.</p><h5 id="取值："><a href="#取值：" class="headerlink" title="取值："></a>取值：</h5><p>number：用数值来定义扩展比率。不允许负值</p><p>适用于：flex子项</p><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>设置或检索弹性盒的扩展比率。<br>根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间。</p><p>eg:<br><a href="https://imgchr.com/i/rOzZeU"><img src="https://s3.ax1x.com/2020/12/30/rOzZeU.jpg" alt="rOzZeU.jpg"></a></p><p><a href="https://imgchr.com/i/rOztTe"><img src="https://s3.ax1x.com/2020/12/30/rOztTe.jpg" alt="rOztTe.jpg"></a></p><h4 id="2-flex-shrink-不存在剩余空间-为负-计算收缩比例"><a href="#2-flex-shrink-不存在剩余空间-为负-计算收缩比例" class="headerlink" title="2. flex-shrink: 不存在剩余空间, 为负, 计算收缩比例"></a>2. flex-shrink: 不存在剩余空间, 为负, 计算收缩比例</h4><p>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><h4 id="取值：-1"><a href="#取值：-1" class="headerlink" title="取值："></a>取值：</h4><p>number：用数值来定义收缩比率。不允许负值</p><p>适用于：flex子项</p><h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><p>设置或检索弹性盒的收缩比率。<br>根据弹性盒子元素所设置的收缩因子作为比率来收缩空间。</p><p><a href="https://imgchr.com/i/rOzcTg"><img src="https://s3.ax1x.com/2020/12/30/rOzcTg.jpg" alt="rOzcTg.jpg"></a></p><p><a href="https://imgchr.com/i/rOz70U"><img src="https://s3.ax1x.com/2020/12/30/rOz70U.jpg" alt="rOz70U.jpg"></a></p><h4 id="3-flex-basis-分配剩余空间前-定义宽度"><a href="#3-flex-basis-分配剩余空间前-定义宽度" class="headerlink" title="3. flex-basis: 分配剩余空间前, 定义宽度"></a>3. flex-basis: 分配剩余空间前, 定义宽度</h4><p>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<br>在「flex」属性中该值如果被省略则默认为「0%」<br>在「flex」属性中该值如果被指定为「auto」，则伸缩基准值的计算值是自身的 &lt;’ width ‘&gt; 设置，如果自身的宽度没有定义，则长度取决于内容。</p><h5 id="取值：-2"><a href="#取值：-2" class="headerlink" title="取值："></a>取值：</h5><p>length：用长度值来定义宽度。不允许负值<br>percent：用百分比来定义宽度。不允许负值<br>auto：无特定宽度值，取决于其它属性值<br>content：基于内容自动计算宽度</p><p>适用于：flex子项</p><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5><p>设置或检索弹性盒伸缩基准值。<br>如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间<br>对应的脚本特性为flexBasis。</p><h4 id="二-flex"><a href="#二-flex" class="headerlink" title="二. flex:"></a>二. flex:</h4><h4 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h4><p>复合属性。设置或检索弹性盒模型对象的子元素如何分配空间。<br>如果缩写「flex: 1」, 则其计算值为「1 1 0%」<br>如果缩写「flex: auto」, 则其计算值为「1 1 auto」<br>如果「flex: none」, 则其计算值为「0 0 auto」<br>如果「flex: 0 auto」或者「flex: initial」, 则其计算值为「0 1 auto」，即「flex」初始值 </p><p>flex属性默认是0 1 auto<br>flex-grow为0，则存在剩余空间也不放大<br>flex-shrink为1，则空间不足该项目缩小<br>flex-basis为auto，则该项目本来的大小</p><p>eg1:</p><p>页面设计中用到了flex:1, 具体什么意思呢, 说说我自己的理解.</p><p><a href="https://imgchr.com/i/rXS1hj"><img src="https://s3.ax1x.com/2020/12/30/rXS1hj.jpg" alt="rXS1hj.jpg"></a></p><p>解析:</p><p>flex-grow:1; 有剩余空间, 分配</p><p>flex-shrink:1; 没有剩余空间, 收缩</p><p>flex-basis:0%; 没有基础宽度</p><p><a href="https://imgchr.com/i/rXS7vt"><img src="https://s3.ax1x.com/2020/12/30/rXS7vt.jpg" alt="rXS7vt.jpg"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一-flex是由三个属性组成&quot;&gt;&lt;a href=&quot;#一-flex是由三个属性组成&quot; class=&quot;headerlink&quot; title=&quot;一. flex是由三个属性组成:&quot;&gt;&lt;/a&gt;一. flex是由三个属性组成:&lt;/h4&gt;&lt;h5 id=&quot;1-flex-grow-存</summary>
      
    
    
    
    
    <category term="flex" scheme="https://perfectsymphony.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>Vue子组件调用父组件的三种方法</title>
    <link href="https://perfectsymphony.github.io/2020/12/30/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://perfectsymphony.github.io/2020/12/30/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-30T07:09:00.000Z</published>
    <updated>2020-12-30T07:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一种方法是直接在子组件中通过this-parent-event来调用父组件的方法"><a href="#第一种方法是直接在子组件中通过this-parent-event来调用父组件的方法" class="headerlink" title="第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法"></a>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法</h4><p>父组件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import child from <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">fatherMethod</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">childMethod</span></span>() &#123;</span><br><span class="line">        this.<span class="variable">$parent</span>.fatherMethod();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="第二种方法是在子组件里用-emit向父组件触发一个事件，父组件监听这个事件就行了"><a href="#第二种方法是在子组件里用-emit向父组件触发一个事件，父组件监听这个事件就行了" class="headerlink" title="第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了"></a>第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了</h4><p>父组件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child @fatherMethod=<span class="string">&quot;fatherMethod&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import child from <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">fatherMethod</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">childMethod</span></span>() &#123;</span><br><span class="line">        this.<span class="variable">$emit</span>(<span class="string">&#x27;fatherMethod&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法"><a href="#第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法" class="headerlink" title="第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法"></a>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</h4><p>父组件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child :fatherMethod=<span class="string">&quot;fatherMethod&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import child from <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">fatherMethod</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      fatherMethod: &#123;</span><br><span class="line">        <span class="built_in">type</span>: Function,</span><br><span class="line">        default: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">childMethod</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (this.fatherMethod) &#123;</span><br><span class="line">          this.fatherMethod();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;第一种方法是直接在子组件中通过this-parent-event来调用父组件的方法&quot;&gt;&lt;a href=&quot;#第一种方法是直接在子组件中通过this-parent-event来调用父组件的方法&quot; class=&quot;headerlink&quot; title=&quot;第一种方法是直接在子</summary>
      
    
    
    
    
    <category term="vue" scheme="https://perfectsymphony.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS命名规范——BEM思想</title>
    <link href="https://perfectsymphony.github.io/2020/12/29/CSS%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E2%80%94%E2%80%94BEM%E6%80%9D%E6%83%B3/"/>
    <id>https://perfectsymphony.github.io/2020/12/29/CSS%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E2%80%94%E2%80%94BEM%E6%80%9D%E6%83%B3/</id>
    <published>2020-12-29T08:39:09.000Z</published>
    <updated>2020-12-29T08:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>人们问我最多的问题之一是在CSS类名中“–”和“__”是什么意思？它们的出现是源于<a class="link"   href="https://en.bem.info/" >BEM<i class="fas fa-external-link-alt"></i></a>和Nicolas Gallagher…</p><p>BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。</p><p>重要的是要注意，我使用的基于BEM的命名方式是经过<a class="link"   href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/" >Nicolas Gallagher修改过的<i class="fas fa-external-link-alt"></i></a>。这篇文章中介绍的这种命名技术并不是原始的BEM，但却是一个我更喜欢的改进版。无论实际使用了什么样的符号，它们其实都是基于同样的BEM原则。</p><p>命名约定的模式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.block&#123;&#125;</span><br><span class="line">.block__element&#123;&#125;</span><br><span class="line">.block--modifier&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>block 代表了更高级别的抽象或组件。</li><li>block__element 代表.block的后代，用于形成一个完整的.block的整体。</li><li>block–modifier代表.block的不同状态或不同版本。</li></ul><p>之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.site-search&#123;&#125; /* 块 */</span><br><span class="line">.site-search__field&#123;&#125; /* 元素 */</span><br><span class="line">.site-search--full&#123;&#125; /* 修饰符 */</span><br></pre></td></tr></table></figure><p>BEM的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素,还有一些是组件的其他形态或者是修饰符。我们用一个类比/模型来思考一下下面的这些元素是怎么关联的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.person&#123;&#125;</span><br><span class="line">.person__hand&#123;&#125;</span><br><span class="line">.person--female&#123;&#125;</span><br><span class="line">.person--female__hand&#123;&#125;</span><br><span class="line">.person__hand--left&#123;&#125;</span><br></pre></td></tr></table></figure><p>顶级块是‘person’，它拥有一些元素，如‘hand’。一个人也会有其他形态，比如女性，这种形态进而也会拥有它自己的元素。下面我们把他们写成‘常规’CSS:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.person&#123;&#125;</span><br><span class="line">.hand&#123;&#125;</span><br><span class="line">.female&#123;&#125;</span><br><span class="line">.female-hand&#123;&#125;</span><br><span class="line">.left-hand&#123;&#125;</span><br></pre></td></tr></table></figure><p>这些‘常规’CSS都是有意义的，但是它们之间却有些脱节。就拿.female来说，是指女性人类还是某种雌性的动物？还有.hand，是在说一只钟表的指针（译注：英文中hand有指针的意思）？还是一只正在玩纸牌的手？使用BEM我们可以获得更多的描述和更加清晰的结构，单单通过我们代码中的命名就能知道元素之间的关联。BEM真是强大。</p><p>再来看一个之前用‘常规’方式命名的.site-search的例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;form class=<span class="string">&quot;site-search  full&quot;</span>&gt;</span><br><span class="line">  &lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;field&quot;</span>&gt;</span><br><span class="line">  &lt;input <span class="built_in">type</span>=<span class="string">&quot;Submit&quot;</span> value =<span class="string">&quot;Search&quot;</span> class=<span class="string">&quot;button&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>这些CSS类名真是太不精确了，并不能告诉我们足够的信息。尽管我们可以用它们来完成工作，但它们确实非常含糊不清。用BEM记号法就会是下面这个样子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;form class=<span class="string">&quot;site-search  site-search--full&quot;</span>&gt;</span><br><span class="line">  &lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;site-search__field&quot;</span>&gt;</span><br><span class="line">  &lt;input <span class="built_in">type</span>=<span class="string">&quot;Submit&quot;</span> value =<span class="string">&quot;Search&quot;</span> class=<span class="string">&quot;site-search__button&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>我们能清晰地看到有个叫.site-search的块，他内部是一个叫.site-search__field的元素。并且.site-search还有另外一种形态叫.site-search–full。</p><p>我们再来举个例子……</p><p>如果你熟悉OOCSS（面向对象CSS），那么你对<a class="link"   href="http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/" >media对象<i class="fas fa-external-link-alt"></i></a>一定也不陌生。用BEM的方式，media对象就会是下面这个样子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.media&#123;&#125;</span><br><span class="line">.media__img&#123;&#125;</span><br><span class="line">.media__img--rev&#123;&#125;</span><br><span class="line">.media__body&#123;&#125;</span><br></pre></td></tr></table></figure><p>从这种CSS的写法上我们就已经知道.media__img 和.media__body一定是位于.media内部的，而且.media__img–rev是.media__img的另一种形态。仅仅通过CSS选择器的名字我们就能获取到以上全部信息。</p><p>BEM的另外一个好处是针对下面这种情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;media&quot;</span>&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;logo.png&quot;</span> alt=<span class="string">&quot;Foo Corp logo&quot;</span> class=<span class="string">&quot;img-rev&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">    &lt;h3 class=<span class="string">&quot;alpha&quot;</span>&gt;Welcome to Foo Corp&lt;/h3&gt;</span><br><span class="line">    &lt;p class=<span class="string">&quot;lede&quot;</span>&gt;Foo Corp is the best, seriously!&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>光从上面的代码来看，我们根本不明白.media和.alpha两个class彼此之间是如何相互关联的？同样我们也无从知晓.body和.lede之间，或者.img-rev 和.media之间各是什么关系？从这段HTML（除非你对那个media对象非常了解）中我们也不知道这个组件是由什么组成的和它还有什么其他的形态。如果我们用BEM方式重写这段代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;media&quot;</span>&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;logo.png&quot;</span> alt=<span class="string">&quot;Foo Corp logo&quot;</span> class=<span class="string">&quot;media__img--rev&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;media__body&quot;</span>&gt;</span><br><span class="line">    &lt;h3 class=<span class="string">&quot;alpha&quot;</span>&gt;Welcome to Foo Corp&lt;/h3&gt;</span><br><span class="line">    &lt;p class=<span class="string">&quot;lede&quot;</span>&gt;Foo Corp is the best, seriously!&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们立马就能明白.media是一个块，.media__img–rev是一个加了修饰符的.media__img的变体，它是属于.media的元素。而.media__body是一个尚未被改变过的也是属于.media的元素。所有以上这些信息都通过它们的class名称就能明白，由此看来BEM确实非常实用。</p><h3 id="丑极了！"><a href="#丑极了！" class="headerlink" title="丑极了！"></a>丑极了！</h3><p>通常人们会认为BEM这种写法难看。我敢说，如果你仅仅是因为这种代码看上去不怎么好看而羞于使用它，那么你将错失最重要的东西。除非使用BEM让代码增加了不必要的维护困难，或者这么做确实让代码更难读了，那么你在使用它之前就要三思而行了。但是，如果只是“看起来有点怪”而事实上是一种有效的手段，那么我们在开发之前当然应该充分考虑它。</p><p>是，BEM看上去确实怪怪的，但是它的好处远远超过它外观上的那点瑕疵。</p><p>BEM可能看上去有点滑稽，而且有可能导致我们输入更长的文本（大部分编辑器都有自动补全功能，而且gzip压缩将会让我们消除对文件体积的担忧），但是它依旧强大。</p><h3 id="用还是不用BEM"><a href="#用还是不用BEM" class="headerlink" title="用还是不用BEM?"></a>用还是不用BEM?</h3><p>我在我的所有项目中都使用了BEM记号法，因为它的有效性已经被它自己一次又一次地证明。我也极力地建议别人使用BEM，因为它让所有东西之间的联系变得更加紧密，让团队甚至是你个人都能够更加容易地维护代码。</p><p>然而，当你真正使用BEM的时候，重要的是，请记住你没必要真的在每个地方都用上它。比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.caps&#123; text-transform:uppercase; &#125;</span><br></pre></td></tr></table></figure><p>这条CSS不属于任何一个BEM范畴，它仅仅只是一条单独的样式。</p><p>另一个没有使用BEM的例子是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.site-logo&#123;&#125;</span><br></pre></td></tr></table></figure><p>这是一个logo，我们可以把它写成BEM格式，像下面这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.header&#123;&#125;</span><br><span class="line">.header__logo&#123;&#125;</span><br></pre></td></tr></table></figure><p>但我们没必要这么做。使用BEM的诀窍是，你要知道什么时候哪些东西是应该写成BEM格式的。因为某些东西确实是位于一个块的内部，但这并不意味它就是BEM中所说的元素。这个例子中，网站logo完全是恰巧在.header的内部，它也有可能在侧边栏或是页脚里面。一个元素的范围可能开始于任何上下文，因此你要确定只在你需要用到BEM的地方你才使用它。再看一个例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">  &lt;h1 class=<span class="string">&quot;content__headline&quot;</span>&gt;Lorem ipsum dolor...&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在这个例子里，我们也许仅仅只需要另一个class，可以叫它.headline；它的样式取决于它是如何被层叠的，因为它在.content的内部；或者它只是恰巧在.content的内部。如果它是后者（即恰巧在.content的内部，而不总是在）我们就不需要使用BEM。</p><p>然而，一切都有可能潜在地用到BEM。我们再来看一下.site-logo的例子，想象一下我们想要给网站增加一点圣诞节的气氛，所以我们想有一个圣诞版的logo。于是我们有了下面的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.site-logo&#123;&#125;</span><br><span class="line">.site-logo--xmas&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过使用–修饰符来快速地为我们的代码构建另一个版本。</p><p>BEM最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。随着接触的多了，有了经验积累，你慢慢就会知道怎么用，这些问题也不再是问题。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>所以，BEM（或BEM的变体）是一个非常有用，强大，简单的命名约定，以至于让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确而且更加严密。</p><p>尽管BEM看上去多少有点奇怪，但是无论什么项目，它对前端开发者都是一个巨有价值的工具。</p><p>如需转载烦请注明出处：</p><p>英文原文：<a class="link"   href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/" >http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/<i class="fas fa-external-link-alt"></i></a></p><p>中文译文：<a class="link"   href="http://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html" >http://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人们问我最多的问题之一是在CSS类名中“–”和“__”是什么意思？它们的出现是源于&lt;a class=&quot;link&quot;   href=&quot;https://en.bem.info/&quot; &gt;BEM&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;和N</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://perfectsymphony.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深入理解css之line-height</title>
    <link href="https://perfectsymphony.github.io/2020/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css%E4%B9%8Bline-height/"/>
    <id>https://perfectsymphony.github.io/2020/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css%E4%B9%8Bline-height/</id>
    <published>2020-12-29T07:46:18.000Z</published>
    <updated>2020-12-29T13:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>行高，顾名思义是一行文字的高度，而从规范上来说则是两行文字基线之间的距离。行高是作用在每一个行框盒子(line-box)上的，而行框盒子则是由内联盒子组成，因此，行高与内联元素可以说是非常紧密，行高直接决定了内联元素的高度（注意：这里的内联元素不包括替换元素）；对于块级元素和替换元素，行高是无法决定最终高度的，只能决定行框盒子的最小高度。</p><h3 id="x、x-height以及ex"><a href="#x、x-height以及ex" class="headerlink" title="x、x-height以及ex"></a>x、x-height以及ex</h3><p>字母x在css里面扮演着一个很重要的角色，因为字母x的下边缘就是基线所在的位置。而x-height指的就是字母x的高度，ex是一个尺寸单位，其大小是相对字母x的来计算的，即1ex就表示1个字母x的高度。如下图所示：</p><p><a href="https://imgchr.com/i/rbXOpT"><img src="https://s3.ax1x.com/2020/12/29/rbXOpT.png" alt="rbXOpT.png"></a></p><p>我们在平时的开发中很少用到ex，因为ex是个相对单位。对于相对的东西，我们总是感觉很难控制，但这并不表明ex就一点用处都没有。我们可以利用ex就是一个x-height的特性来实现图标与文字的垂直居中，这样如论字体大小如何变化，都不会影响垂直居中的效果。代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.icon-arrow &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 1ex;</span><br><span class="line">    background: url(down.png) no-repeat center;</span><br><span class="line">    background-size: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span&gt;我是一段文本&lt;/span&gt;</span><br><span class="line">    &lt;i class=<span class="string">&quot;icon-arrow&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://imgchr.com/i/rbjOUI"><img src="https://s3.ax1x.com/2020/12/29/rbjOUI.png" alt="rbjOUI.png"></a></p><h4 id="line-height的属性值"><a href="#line-height的属性值" class="headerlink" title="line-height的属性值"></a>line-height的属性值</h4><ul><li>normal</li><li>数字</li><li>长度</li><li>百分比<h4 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h4>normal为line-height的默认值，但并不是一个固定的值，而是会受font-family的影响，对于“微软雅黑”，其值为1.32；而对于“宋体”，其值为1.141。由于不同操作系统，不同浏览器所使用的字体不一样，所以最终line-height的具体值会不一样，因此这个属性作用不大。</li></ul><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>我们可以设置line-height: 1.5。其意思是说line-height的最终大小为 1.5* font-size，一般建议使用该值来设置line-height。</p><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>长度用的最多的就是px与em，em跟数字一样，都是相对于font-size来计算的。</p><h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h4><p>百分比也是相对于font-size来计算的。</p><p>相信细心的小伙伴已经发现了，数字，em以及百分比都是相对于font-size来计算的，既然这样，为什么还要多此一举设置另外两个属性呢。原因就在于它们的继承方式是不一样的。对于数字，父元素设置了1.5，则子元素也是会继承1.5。但如果父元素设置的是1.5em，假设父元素font-size是20px，则父元素line-height是30px，同时子元素的line-height也是30px，也就是说子元素继承的是父元素计算后的line-height值。因此，这也是为什么上面推荐使用数字而不是em或百分比的原因了。</p><h4 id="行距与半行距"><a href="#行距与半行距" class="headerlink" title="行距与半行距"></a>行距与半行距</h4><p>很多开发人员开还原设计图的时候，往往没有考虑到行距的影响，因此开发出来的页面很多时候都与设计图不符合，总会差那么几个像素。那么什么是行距呢，我们可以想象一下在文字排版的时候，如果行与行之间的间距为0，则文字是会紧紧贴在一起的，因此，行距就是用来协助排版的。行距的计算为：line-height - em-box，em-box指的是1em的大小，因此行距可以表示为：line-height - font-size，假设line-height为1.5，font-size为20，则行距为：<br>1.5*20 - 20 = 10，则最终行距为10，而这个行距会平均作用于文字的上边和下边。但em-box我们是无法感知这个盒子在哪的，而内容区域我们则可以理解为我们选中文字后的背景色所在区域，而当字体是宋体的时候，内容区域和em-box是等高的，因此我们可以利用此揪出ex-box的藏身之处。如下图所示：<br><a href="https://imgchr.com/i/rbvhZj"><img src="https://s3.ax1x.com/2020/12/29/rbvhZj.png" alt="rbvhZj.png"></a></p><p>正是因为行距的存在，我们给元素设置margin值时，要减去相应的半行距值，这样才能比较精确地还原设计图。</p><h4 id="line-height的应用"><a href="#line-height的应用" class="headerlink" title="line-height的应用"></a>line-height的应用</h4><p>大部分时候，我们设置line-height，都是为了垂直居中对齐。但这里的居中，只能说是近似居中，从上面的图可以看出：行距是上下均分的，但是内容区域不是，一般来说，文字都是偏下的。我们平时设置字体一般都是12-20像素，这么小的像素值，给出line-height值后，由于上下相差不大，因此感觉上是垂直居中的。line-height除了可以作为单行文本的居中对齐外，多行文本也是可以的，代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    line-height: 400px;</span><br><span class="line">    padding: 0 10px;</span><br><span class="line">    border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    line-height: 1.3;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;text&quot;</span>&gt;这是一段很长很长的文字，这是一段很长很长的文字，这是一段很长很长的文字，这是一段很长很长的文字，这是一段很长很长的文字&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://imgchr.com/i/rbxkOe"><img src="https://s3.ax1x.com/2020/12/29/rbxkOe.png" alt="rbxkOe.png"></a></p><p>前面的文章有说过，每一个行框盒子前面都有一个看不见的，规范称之为“strut”的东西。我们给.box设置了line-height为400px，则这个“strut”的line-height也会继承为400px。然后我们给.text设置inline-block，这样我们就可以重置.box设置的line-height，又因为ineline-block保持了内联特性，因此我们可以设置vertical-align以及产生“strut”，从而实现近似垂直居中对齐。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>介绍了字母x在css中的地位以及ex的应用</li><li>line-height各种不同的属性值以及数字、em和百分比的不同之处</li><li>行距在line-height的作用</li><li>line-height实现单行垂直居中和多行垂直居中</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;行高，顾名思义是一行文字的高度，而从规范上来说则是两行文字基线之间的距离。行高是作用在每一个行框盒子(line-box)上的，而行框盒子则是</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://perfectsymphony.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深入理解css之vertical-align</title>
    <link href="https://perfectsymphony.github.io/2020/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css%E4%B9%8Bvertical-align/"/>
    <id>https://perfectsymphony.github.io/2020/12/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css%E4%B9%8Bvertical-align/</id>
    <published>2020-12-29T07:24:28.000Z</published>
    <updated>2020-12-29T08:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vertical-align用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。也就是说，对于块级元素，vertical-align是不起作用的。</p><h3 id="vertical-align的各类属性值"><a href="#vertical-align的各类属性值" class="headerlink" title="vertical-align的各类属性值"></a>vertical-align的各类属性值</h3><p>vertical-align的属性值可以归为以下4类：</p><ul><li>线类，如 baseline、top、middle、bottom；</li><li>文本类，如 text-top、text-bottom；</li><li>上标下标类，如 sub、super；</li><li>数值百分比类，如 10px、1em、5%；</li></ul><h4 id="线类"><a href="#线类" class="headerlink" title="线类"></a>线类</h4><p>baseline，baseline为vertical-align的默认值，其意思是指基线对齐，所谓基线，指的是字母x的下边缘，具体可看<a href="">深入理解css之line-height</a>有讲解到，不懂的小伙伴建议先看看这篇文章。我们来看个例子，代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;text&quot;</span>&gt;文本&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下： </p><p><a href="https://imgchr.com/i/rHxDKg"><img src="https://s3.ax1x.com/2020/12/29/rHxDKg.png" alt="rHxDKg.png"></a></p><p>由于baseline是默认值，所以可以不用写。.box的line-height为100px，这其实是给“strut”设置的（不懂strut概念的可以看看<a href="">深入理解css盒子模型</a>，简单点说就是每一个行框盒子都有一个看不见的节点，该节点继承了line-height），因此.text对齐于该节点的基线（可以想象成这个看不见的节点有一个字母x，而.text就是跟这个字母x的下边缘对齐）</p><p>关于baseline，有一个需要注意的地方就是inline-block元素，如果一个inline-block元素，里面没有内联元素，或者overflow不是visible，则该元素的基线是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。例子如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;text&quot;</span>&gt;文本&lt;/span&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;text&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://imgchr.com/i/rHz1J0"><img src="https://s3.ax1x.com/2020/12/29/rHz1J0.png" alt="rHz1J0.png"></a></p><p>top，对于内联元素，指的是元素的顶部和当前行框盒子的顶部对齐；对于table-cell元素，指的是元素的顶padding边缘和表格行的顶部对齐。例子如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">&#125;</span><br><span class="line">.top &#123;</span><br><span class="line">    line-height: normal;</span><br><span class="line">    vertical-align: top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;top&quot;</span>&gt;文本&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://imgchr.com/i/rbSl0H"><img src="https://s3.ax1x.com/2020/12/29/rbSl0H.png" alt="rbSl0H.png"></a></p><p>bottom，跟top类似，将顶部换成底部即可。</p><p>middle，这个属性值用得比较多。对于内联元素指的是元素的垂直中心点与行框盒子基线往上1/2x-height处对齐，简单点说就是字母x的中心位置对齐；对于table-cell元素，指的是单元格填充盒子相对于外面的表格行居中对齐。基本上所有字体中，字母x的位置都是偏下一点的，font-size越大偏移越明显，因此，字母x中心的位置不是行框盒子的中心，也就是说vertical-align只能实现近似垂直居中对齐。</p><h4 id="文本类"><a href="#文本类" class="headerlink" title="文本类"></a>文本类</h4><p>text-top，指的是盒子的顶部和父级内容区域的顶部对齐。</p><p>text-bottom，指的是盒子的底部和父级内容区域的底部对齐。</p><p>例子如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.f12 &#123;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line">.f16 &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.f20 &#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.text-top &#123;</span><br><span class="line">    line-height: normal;</span><br><span class="line">    vertical-align: text-top;</span><br><span class="line">    width: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;f12&quot;</span>&gt;12px&lt;/span&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;f16&quot;</span>&gt;16px&lt;/span&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;f20&quot;</span>&gt;20px&lt;/span&gt;</span><br><span class="line">    &lt;img class=<span class="string">&quot;text-top&quot;</span> src=<span class="string">&quot;./card.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://imgchr.com/i/rbCF0g"><img src="https://s3.ax1x.com/2020/12/29/rbCF0g.png" alt="rbCF0g.png"></a></p><p>所谓内容区域，可以看成是鼠标选中文字后高亮的背景色区域，上面的例子中，由于父元素设置的是20px，所以图片的vertical-align设置text-top的时候，就可以看成是跟子元素为20px元素的内容区域顶部对齐。</p><h4 id="上标下标类"><a href="#上标下标类" class="headerlink" title="上标下标类"></a>上标下标类</h4><p>上标和下标对应着两个标签super和sub，super在上面，sub在下面，这两个属性值在数学公式和化学表达式中用得比较多，平时我们开发几乎用不到，也没啥好讲的。</p><h4 id="数值百分比类"><a href="#数值百分比类" class="headerlink" title="数值百分比类"></a>数值百分比类</h4><p>vertical-align是支持数值的，并且兼容性也非常好，但大部分开发人员却不知道vertical-align支持数值。对于数值，正值表示由基线往上偏移，负值表示由基线往下偏移。而百分比则是基于line-height来计算的，百分比用得比较少，因为line-height一般都是开发人员给出的，这时候数值就可以精确定位元素，不需要再使用百分比再去计算一遍。使用数值的代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.num &#123;</span><br><span class="line">    line-height: normal;</span><br><span class="line">    vertical-align: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;num&quot;</span>&gt;文本&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://imgchr.com/i/rbPEDO"><img src="https://s3.ax1x.com/2020/12/29/rbPEDO.png" alt="rbPEDO.png"></a></p><h4 id="vertical-align起作用的前提"><a href="#vertical-align起作用的前提" class="headerlink" title="vertical-align起作用的前提"></a>vertical-align起作用的前提</h4><p>vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。在css中，有些css属性是会改变元素的display值的，例如float和position: absolute，一旦设置了这两个属性之一，元素的display值就是变为block，因此，vertical-align也就失去了作用。下面这段代码这样写就是错的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">span &#123;</span><br><span class="line">     <span class="built_in">float</span>: left;</span><br><span class="line">     vertical-align: middle; /* 错误，该行代码无效 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，更多人遇到的是以下这种无效的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;img  src=<span class="string">&quot;1.jpg&quot;</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>其实，不是vertical-align无效，而是前面所说的“strut”的影响，由于.box没有设置line-height，所以“strut”的line-height就非常小，比图片的高度小很多，vertical-align: middle没法发挥作用。这时给.box一个比较高的line-height，就会看到vertical-align起作用了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vertical-align与line-height的关系"><a href="#vertical-align与line-height的关系" class="headerlink" title="vertical-align与line-height的关系"></a>vertical-align与line-height的关系</h4><p>前面讲了，vertical-align的百分比值是根据line-height来计算的。但实质上，只要是内联元素，这两个元素都会同时在起作用。如下例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    line-height: 32px;</span><br><span class="line">&#125;</span><br><span class="line">.box &gt; span &#123;</span><br><span class="line">    font-size: 24px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;span&gt;文本&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/rbkp5Q"><img src="https://s3.ax1x.com/2020/12/29/rbkp5Q.png" alt="rbkp5Q.png"></a></p><p>从代码上看，好像.box的高度会是32px，但实质上.box的高度会比32px还要高。原因是”strut”继承了line-height: 32px，span也继承了line-height: 32px，但两者的font-size不一样，这就导致了”strut”的font-size比较小，而span的font-size比较大，也就是说它们的基线不在同一位置上，”strut”偏上一点，而span默认又是基线对齐，为此，span总体会往上移以便跟”strut”基线对齐，.box元素就是这样被撑高了。而解决方案可以有以下几种：</p><ul><li>span元素不使用基线对齐，可以改为top对齐</li><li>span元素块状化</li><li>line-height设置为0</li><li>font-size设置为0</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>讲解了vertical-align的各类属性值及其效果</li><li>vertical-align起作用的前提是内联元素</li><li>vertical-align与line-height都是同时作用在内联元素上的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vertical-align用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。也就是说，对于块级元素，</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://perfectsymphony.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>jsonp原理</title>
    <link href="https://perfectsymphony.github.io/2020/12/16/jsonp%E5%8E%9F%E7%90%86/"/>
    <id>https://perfectsymphony.github.io/2020/12/16/jsonp%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-16T12:50:25.000Z</published>
    <updated>2020-12-23T07:48:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习jsonp之前首先要明白以下几点：<br>首先确定为什么要用jsonp，因为要跨域请求数据，那为什么会发生跨域呢，</p><p>因为浏览器的同源策略，那什么是同源策略呢浏览器从A网站向B网站请求资源，必须同时满足三点才可以，协议，域名，端口相同，任何一点不同都会产生跨域，产生跨域后，浏览器就会阻止数据返回。</p><p>人们为了满足在不同的域名间传递数据，发明了jsonp技术：</p><p>在学习jsonp之前，大家可以思考一下，一张网页中哪些标签是可以跨域请求资源的，我们知道，在页面上有三种资源是可以与页面本身不同源的。它们是：js脚本，css样式文件，图片：</p><p>1）<script type="text/javascript" src="某个cdn地址" ></script></p><p>2）<link type="text/css" rel="stylesheet" href="某个cdn地址" /></p><p>3）<img src="某个cdn地址" alt=""/></p><p>以上三种资源是可以发生跨域后，而资源可以返回的；</p><p>而jsonp就是利用了<code>&lt;script&gt;</code>标签可以链接到不同源的js脚本来到达跨域目的。当链接的资源到达浏览器时，浏览器会根据他们的类型来采取不同的处理方式，比如，如果是css文件，则会进行对页面 repaint，如果是img 则会将图片渲染出来，如果是script 脚本，则会进行执行，比如我们在页面引入了jquery库，为什么就可以使用 $ 了呢？就是因为 jquery 库被浏览器执行之后，会给全局对象window增加一个属性： $ ，所以我们才能使用 $ 来进行各种处理。</p><p>重点：浏览器会根据他们的类型采用不同的处理方式，js文件则会执行。</p><p>通常一般我们利用ajax请求某些接口返回的数据，基本都是json格式，而jsonp请求返回的数据，是什么呢，咱们来看一条完整的jsop请求和其返回的数据：</p><p><a href="https://imgchr.com/i/r6ZT39"><img src="https://s3.ax1x.com/2020/12/23/r6ZT39.png" alt="r6ZT39.png"></a></p><p>前端工程师通过callback向后端传递了一个abc字符串，后端呢将数据包裹在 abc（）中返回，</p><p>签名提到过了，浏览器会根据不同的文件类型进行不同的处理，咱们利用的是javascript，所以返回的数据会被解析为，js文件，而上面的数据如果被解析为js文件，就会被执行；</p><p>这就是 jsonp 的基本原理，利用script标签的特性，将数据使用json格式用一个函数包裹起来，然后在进行访问的页面中定义一个相同函数名的函数，因为 script 标签src引用的js脚本到达浏览器时会执行，而我们已经定义了一个同名的函数，所以json格式的数据，就作为参数传递给了我们定义的同名函数了。这样就完成了跨域数据交换。jsonp的含义是：json with padding，而在json数据外包裹它的那个函数。<br>附上封装的jsop的代码：</p><p><a href="https://imgchr.com/i/r6eEE8"><img src="https://s3.ax1x.com/2020/12/23/r6eEE8.jpg" alt="r6eEE8.jpg"></a></p><p>以上便是利用jquery的风格封装得到jsonp函数，</p><p>在和第三方接口调用或者和后端工程师交互式，一定要实现沟通好，向后端传递参数名时，用的什么参数，jquery默认用的是callback，</p><p>举个例子：</p><p>百度的jsonp用的是</p><p><a href="https://imgchr.com/i/r6eavR"><img src="https://s3.ax1x.com/2020/12/23/r6eavR.png" alt="r6eavR.png"></a></p><p>百度用的是cb传递的；</p><p>现在咱们看一看上面封装的代码：</p><p>有一句非常关键，就是在window上通过变量挂载了一个Cname的属性，而这个属性是个变量，</p><p>变量值为一个很长的字符串，而cname这个属性是一个函数，这个函数就是，jsonp返回函数调用后，调用的函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习jsonp之前首先要明白以下几点：&lt;br&gt;首先确定为什么要用jsonp，因为要跨域请求数据，那为什么会发生跨域呢，&lt;/p&gt;
&lt;p&gt;因为浏览器的同源策略，那什么是同源策略呢浏览器从A网站向B网站请求资源，必须同时满足三点才可以，协议，域名，端口相同，任何一点不同都会产生</summary>
      
    
    
    
    
    <category term="跨域" scheme="https://perfectsymphony.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>揭秘简单请求和复杂请求</title>
    <link href="https://perfectsymphony.github.io/2020/12/15/%E6%8F%AD%E7%A7%98%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/"/>
    <id>https://perfectsymphony.github.io/2020/12/15/%E6%8F%AD%E7%A7%98%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82/</id>
    <published>2020-12-15T06:41:00.000Z</published>
    <updated>2020-12-15T09:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发网站时经常会用到跨域资源共享（简称cors，后面使用简称）来解决跨域问题，但是在使用cors的时候，http请求会被划分为两类，简单请求和复杂请求，而这两种请求的区别主要在于是否会触发cors预检请求。</p><p>首先我们要明白cors的原理（引自MDN）：</p><blockquote><p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 <code>GET</code> 以外的 HTTP 请求，或者搭配某些 MIME 类型的 <code>POST</code> 请求），浏览器必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）</p></blockquote><p>从上面的文字中我们得到如下信息：</p><p>1、跨域资源共享标准新增了一组 HTTP 首部字段，服务器通过这些字段来控制浏览器有权访问哪些资源。</p><p>2、为了安全起见请求方式分为两类，一类不会预先发送options请求，一些会预先发送options请求。</p><p>3、 <code>GET</code> 以外的 HTTP 请求，或者搭配某些 MIME 类型的 <code>POST</code> 请求会触发options请求。</p><p>4、服务器验证OPTIONS完成后才会允许发送实际的http请求。</p><p>不会触发http预检请求的便是简单请求，能够触发http预检请求的便是复杂请求。</p><p>那么有哪些简单请求呢？以下是来自MDN官方引用：</p><p>1、使用下列方法之一：</p><p>GET、</p><p>POST、</p><p>HEAD。</p><p>2、不得人为设置该集合之外的其他首部字段。该集合为：</p><p>Accept</p><p>Accept-Language</p><p>Content-Language</p><p>Content-Type </p><p>3、Content-Type 的值仅限于下列三者之一：</p><p>text/plain</p><p>multipart/form-data</p><p>application/x-www-form-urlencoded</p><p>4、请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问</p><p>5、请求中没有使用 ReadableStream 对象</p><p>那什么是复杂请求呢，除了简单请求都是复杂请求。</p><p>简单请求的发送从代码上来看和普通的XHR没太大区别，但是HTTP头当中要求总是包含一个域（Origin）的信息。该域包含协议名、地址以及一个可选的端口。不过这一项实际上由浏览器代为发送，并不是开发者代码可以触及到的。</p><p>简单请求的部分响应头及解释如下：</p><blockquote><p>Access-Control-Allow-Origin（必含）- 不可省略，否则请求按失败处理。该项控制数据的可见范围，如果希望数据对任何人都可见，可以填写”*”。<br>Access-Control-Allow-Credentials（可选） – 该项标志着请求当中是否包含cookies信息，只有一个可选值：true（必为小写）。如果不包含cookies，请略去该项，而不是填写false。这一项与XmlHttpRequest2对象当中的withCredentials属性应保持一致，即withCredentials为true时该项也为true；withCredentials为false时，省略该项不写。反之则导致请求失败。<br>Access-Control-Expose-Headers（可选） – 该项确定XmlHttpRequest2对象当中getResponseHeader()方法所能获得的额外信息。通常情况下，getResponseHeader()方法只能获得如下的信息：<br>Cache-Control<br>Content-Language<br>Content-Type<br>Expires<br>Last-Modified<br>Pragma<br>当你需要访问额外的信息时，就需要在这一项当中填写并以逗号进行分隔</p></blockquote><p>如果仅仅是简单请求，那么即便不用CORS也没有什么大不了，但CORS的复杂请求就令CORS显得更加有用了。简单来说，任何不满足上述简单请求要求的请求，都属于复杂请求。比如说你需要发送PUT、DELETE等HTTP动作，或者发送Content-Type: application/json的内容。</p><p>复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种”预请求”，此时作为服务端，也需要返回”预回应”作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。</p><p>预请求以OPTIONS形式发送，当中同样包含域，并且还包含了两项CORS特有的内容</p><blockquote><p>Access-Control-Request-Method – 该项内容是实际请求的种类，可以是GET、POST之类的简单请求，也可以是PUT、DELETE等等。<br>Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。</p></blockquote><p>显而易见，这个预请求实际上就是在为之后的实际请求发送一个权限请求，在预回应返回的内容当中，服务端应当对这两项进行回复，以让浏览器确定请求是否能够成功完成。</p><p>复杂请求的部分响应头及解释如下：</p><blockquote><p>Access-Control-Allow-Origin（必含） – 和简单请求一样的，必须包含一个域。<br>Access-Control-Allow-Methods（必含） – 这是对预请求当中Access-Control-Request-Method的回复，这一回复将是一个以逗号分隔的列表。尽管客户端或许只请求某一方法，但服务端仍然可以返回所有允许的方法，以便客户端将其缓存。<br>Access-Control-Allow-Headers（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。这里在实际使用中有遇到，所有支持的头部一时可能不能完全写出来，而又不想在这一层做过多的判断，没关系，事实上通过request的header可以直接取到Access-Control-Request-Headers，直接把对应的value设置到Access-Control-Allow-Headers即可。<br>Access-Control-Allow-Credentials（可选） – 和简单请求当中作用相同<br>Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。</p></blockquote><p>理论聊完之后，咱们来看一下实践，首先启动两个服务，一个端口为3000,的静态资源服务器，用于请求接口，另一台端口为5000的接口服务器，如图所示：</p><p><a href="https://imgchr.com/i/rMNRdP"><img src="https://s3.ax1x.com/2020/12/15/rMNRdP.png" alt="rMNRdP.png"></a></p><p>后端接口服务器代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const  express = require(<span class="string">&quot;express&quot;</span>);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:<span class="literal">false</span>&#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">// 实现CORS</span><br><span class="line">app.use(<span class="keyword">function</span>(req, res, next) &#123;</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;OPTIONS,GET,POST,PUT,DELETE&#x27;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Origin,X-Requested-With,Content-Type,Accept,Authorization&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;cache-control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;ETag&quot;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">&quot;/p&quot;</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(5000,()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>前端请求资源脚本代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;http://localhost:5000/p&quot;</span>,&#123;name:<span class="string">&quot;zs&quot;</span>,age:<span class="string">&quot;18&quot;</span>&#125;).<span class="keyword">then</span>((data)=&gt;&#123;</span><br><span class="line">    console.log(data.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们用axios这个http请求库发送了一个post请求，axios发送post请求默认会把数据转化为json格式，并且会默认设置请求头：Content-Type：application/json，很显然这是一个复杂请求，这样的话，会触发options请求。</p><p>我们分别启动两个服务，并打开浏览器，访问页面，加载请求接口脚本，观察network如图：</p><p><a href="https://imgchr.com/i/rMN7ss"><img src="https://s3.ax1x.com/2020/12/15/rMN7ss.jpg" alt="rMN7ss.jpg"></a></p><p>我们看到，代码中命名只发送了一次异步请求为什么显示两次呢？详细截图如下：</p><p><a href="https://imgchr.com/i/rMUpQJ"><img src="https://s3.ax1x.com/2020/12/15/rMUpQJ.jpg" alt="rMUpQJ.jpg"></a><br><a href="https://imgchr.com/i/rMUEFK"><img src="https://s3.ax1x.com/2020/12/15/rMUEFK.jpg" alt="rMUEFK.jpg"></a></p><p>我们看到确实发送了两次请求一次为OPTIONS一次为POST，而我们代码中并没有处理对OPTIONS请求的响应处理，所以上面服务端代码是不合理的，综合考虑，OPTIONS请求并会对实际http请求差生影响，所以我们统一的对OPTIONS请求返回204，服务端负责支持CORS的中间件修正代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">function</span>(req, res, next) &#123;</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;OPTIONS,GET,POST,PUT,DELETE&#x27;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Origin,X-Requested-With,Content-Type,Accept,Authorization&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;cache-control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">    res.header(<span class="string">&quot;ETag&quot;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    //header头信息设置结束后，结束程序往下执行，返回</span><br><span class="line">    <span class="keyword">if</span>(req.method.toLocaleLowerCase() === <span class="string">&#x27;options&#x27;</span>)&#123;</span><br><span class="line">        res.status(204);</span><br><span class="line">        <span class="built_in">return</span> res.json(&#123;&#125;);   //直接返回空数据，结束此次请求</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在中间件中判断请求方式，如果请求方式为OPTIONS返回状态码204,并返回空信息。</p><p>限于篇幅文章到此就该结束了，当然了还有好多文档没有测试希望大家看完文章亲手测试一下。</p><p>如果我们将请求脚本改成如下代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;http://localhost:5000/p&quot;</span>,<span class="string">&quot;name=zs&amp;age=18&quot;</span>,&#123;headers:&#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">&#125;&#125;).<span class="keyword">then</span>((data)=&gt;&#123;</span><br><span class="line">    console.log(data.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者又改成如下代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;http://localhost:5000/p&quot;</span>,<span class="string">&quot;name=zs&amp;age=18&quot;</span>,&#123;headers:&#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clm&quot;</span>:<span class="string">&quot;234&quot;</span></span><br><span class="line">&#125;&#125;).<span class="keyword">then</span>((data)=&gt;&#123;</span><br><span class="line">    console.log(data.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上两次请求的netmork会是什么样的呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开发网站时经常会用到跨域资源共享（简称cors，后面使用简称）来解决跨域问题，但是在使用cors的时候，http请求会被划分为两类，简单请求和复杂请求，而这两种请求的区别主要在于是否会触发cors预检请求。&lt;/p&gt;
&lt;p&gt;首先我们要明白cors的原理（引自MDN）：&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="http" scheme="https://perfectsymphony.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>git stash的用法总结</title>
    <link href="https://perfectsymphony.github.io/2020/12/14/stash%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://perfectsymphony.github.io/2020/12/14/stash%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-13T16:46:08.000Z</published>
    <updated>2020-12-18T03:55:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="储藏（Stashing）"><a href="#储藏（Stashing）" class="headerlink" title="储藏（Stashing）"></a>储藏（Stashing）</h4><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。</p><p>“‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p><h4 id="储藏你的工作"><a href="#储藏你的工作" class="headerlink" title="储藏你的工作"></a>储藏你的工作</h4><p>假如你正在一个分支上做开发任务，现在你想切换到另外一个分支上去做一些工作，比如修改bug、继续之前的工作等等。但是，你现在还不想提交你正在进行的工作，所以你可以储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 <code>git stash</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state \</span><br><span class="line">  <span class="string">&quot;WIP on master: 049d078 added the index file&quot;</span></span><br><span class="line">HEAD is now at 049d078 added the index file</span><br><span class="line">(To restore them <span class="built_in">type</span> <span class="string">&quot;git stash apply&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样你的工作目录就干净了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 <code>git stash list</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class="string">&quot;added file_size&quot;</span></span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。你可以重新应用你刚刚实施的储藏，所采用的命令就是之前在原始的 stash 命令的帮助输出里提示的：<code>git stash apply</code>。如果你想应用更早的储藏，你可以通过名字指定它，像这样：<code>git stash apply stash@&#123;2&#125;</code>。如果你不指明，Git 默认使用最近的储藏并尝试应用它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git stash apply</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br></pre></td></tr></table></figure><p>你可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p><p>对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。想那样的话，你必须在运行 <code>git stash apply</code> 命令时带上一个 <code>--index</code> 的选项来告诉命令重新应用被暂存的变更。如果你是这么做的，你应该已经回到你原来的位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git stash apply --index</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br></pre></td></tr></table></figure><p>apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 <code>git stash drop</code>，加上你希望移除的储藏的名字：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert <span class="string">&quot;added file_size&quot;</span></span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to <span class="built_in">log</span></span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure><p>你也可以运行<code>git stash pop</code>来重新应用储藏，同时立刻将其从堆栈中移走。</p><h4 id="取消储藏-Un-applying-a-Stash"><a href="#取消储藏-Un-applying-a-Stash" class="headerlink" title="取消储藏(Un-applying a Stash)"></a>取消储藏(Un-applying a Stash)</h4><p>在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><p>同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show -p | git apply -R</span><br></pre></td></tr></table></figure><p>你可能会想要新建一个別名，在你的 Git 里增加一个 <code>stash-unapply</code> 命令，这样更有效率。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.stash-unapply <span class="string">&#x27;!git stash show -p | git apply -R&#x27;</span></span><br><span class="line">$ git stash apply</span><br><span class="line">$ <span class="comment">#... work work work</span></span><br><span class="line">$ git stash-unapply</span><br></pre></td></tr></table></figure><h4 id="从储藏中创建分支"><a href="#从储藏中创建分支" class="headerlink" title="从储藏中创建分支"></a>从储藏中创建分支</h4><p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash branch testchanges</span><br><span class="line">Switched to a new branch <span class="string">&quot;testchanges&quot;</span></span><br><span class="line"><span class="comment"># On branch testchanges</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</span><br></pre></td></tr></table></figure><p>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p><h4 id="git-stash-暂存部分文件"><a href="#git-stash-暂存部分文件" class="headerlink" title="git stash 暂存部分文件"></a>git stash 暂存部分文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>什么参数不加，会分别对暂存区(没有add的)和工作区(add之后的)的状态进行保存。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>save可以添加保存时的备注。示例:git stash save “完成user接口”</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>-k 或–keep-index只备份没有add的文件。示例<code>git stash save --keep-index &quot;部分文件&quot;</code></p><h4 id="git-stash使用技巧"><a href="#git-stash使用技巧" class="headerlink" title="git stash使用技巧"></a>git stash使用技巧</h4><p>常规 git stash 的一个限制是它会一下暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来备份部分文件：</p><ul><li>add 那些你不想备份的文件（例如： git add file1.js, file2.js）</li><li>调用 git stash –keep-index。只会备份那些没有被add的文件。</li><li>调用 git reset 取消已经add的文件的备份，继续自己的工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;储藏（Stashing）&quot;&gt;&lt;a href=&quot;#储藏（Stashing）&quot; class=&quot;headerlink&quot; title=&quot;储藏（Stashing）&quot;&gt;&lt;/a&gt;储藏（Stashing）&lt;/h4&gt;&lt;p&gt;经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面</summary>
      
    
    
    
    
    <category term="Git" scheme="https://perfectsymphony.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的深拷贝与浅拷贝</title>
    <link href="https://perfectsymphony.github.io/2020/12/07/JavaScript%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://perfectsymphony.github.io/2020/12/07/JavaScript%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-12-06T16:54:12.000Z</published>
    <updated>2020-12-06T17:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h3><h4 id="1-1、JS数据类型"><a href="#1-1、JS数据类型" class="headerlink" title="1.1、JS数据类型"></a>1.1、JS数据类型</h4><p>基本数据类型：Boolean、String、Number、null、undefined<br>引用数据类型：Object、Array、Function、RegExp、Date等</p><h4 id="1-2、数据类型的复制"><a href="#1-2、数据类型的复制" class="headerlink" title="1.2、数据类型的复制"></a>1.2、数据类型的复制</h4><p>基本数据类型的复制，是按值传递的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = a;</span><br><span class="line">b = 2;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.lob(b); // 2</span><br></pre></td></tr></table></figure><p>引用数据类型的复制，是按引用传值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line"> a: 1;</span><br><span class="line"> b: 2;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.a=3;</span><br><span class="line">console.log(obj1.a); //3</span><br><span class="line">console.log(obj2.a); // 3</span><br></pre></td></tr></table></figure><h4 id="1-3、深拷贝与浅拷贝"><a href="#1-3、深拷贝与浅拷贝" class="headerlink" title="1.3、深拷贝与浅拷贝"></a>1.3、深拷贝与浅拷贝</h4><p>深拷贝和浅拷贝都只针对引用数据类型，浅拷贝会对对象逐个成员依次拷贝，但只复制内存地址，而不复制对象本身，新旧对象成员还是共享同一内存；深拷贝会另外创建一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>区别：浅拷贝只复制对象的第一层属性，而深拷贝会对对象的属性进行递归复制。</p><h3 id="二、JS浅拷贝"><a href="#二、JS浅拷贝" class="headerlink" title="二、JS浅拷贝"></a>二、JS浅拷贝</h3><h4 id="2-1、赋值与浅拷贝"><a href="#2-1、赋值与浅拷贝" class="headerlink" title="2.1、赋值与浅拷贝"></a>2.1、赋值与浅拷贝</h4><p>当把一个对象赋值给一个新的变量时，赋的对象是该对象在栈中的地址，而不是堆中的数据。也就是新旧两个对象指的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，两个对象联动的会一起改变。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;language&#x27;</span> : [1,[2,3],[4,5]],</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj2.language[1] = [<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>];</span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>,obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>,obj2)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/DvCoJx"><img src="https://s3.ax1x.com/2020/12/07/DvCoJx.png" alt="DvCoJx.png"></a></p><p>浅拷贝是按位拷贝对象，它会创建一个新对象，对原有对象的成员进行依次拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。因此如果新对象中的某个对象成员改变了地址，就会影响到原有的对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//手写浅拷贝</span><br><span class="line"><span class="keyword">function</span> shallowCopy(obj1) &#123;</span><br><span class="line"> <span class="built_in">let</span> obj2 = Array.isArray(obj1) ? [] : &#123;&#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">  obj2[i] = obj1[i]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> obj2</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;language&#x27;</span> : [1,[2,3],[4,5]],</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = shallowCopy(obj1);</span><br><span class="line">obj2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj2.language[1] = [<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>];</span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>,obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>,obj2)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/DvCTW6"><img src="https://s3.ax1x.com/2020/12/07/DvCTW6.png" alt="DvCTW6.png"></a></p><h4 id="2-2、浅拷贝的实现"><a href="#2-2、浅拷贝的实现" class="headerlink" title="2.2、浅拷贝的实现"></a>2.2、浅拷贝的实现</h4><p>（1）Object.assign()</p><p>Object.assign()方法可以把源对象自身的任意多个的可枚举属性拷贝给目标对象，然后返回目标对象，但是Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。此方法对于Array和Object均可适用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;language&#x27;</span> : [1,[2,3],[4,5]],</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj2.language[1] = [<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>];</span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>,obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>,obj2)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/DvCjwd"><img src="https://s3.ax1x.com/2020/12/07/DvCjwd.png" alt="DvCjwd.png"></a></p><p>（2）Array.prototype.concat()和Array.prototype.slice()</p><p>Array.prototype.concat()和Array.prototype.slice()均为Array原型上的方法，只适用于Array。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1,3,&#123;</span><br><span class="line"> user: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;]</span><br><span class="line">var arr2 = arr1.concat();</span><br><span class="line">arr2[0] = <span class="string">&#x27;一&#x27;</span>;</span><br><span class="line">arr2[2].user = <span class="string">&#x27;AAA&#x27;</span>;</span><br><span class="line">console.log(<span class="string">&#x27;arr1&#x27;</span>,arr1)</span><br><span class="line">console.log(<span class="string">&#x27;arr2&#x27;</span>,arr2)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">var arr1 = [1,3,&#123;</span><br><span class="line"> user: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;]</span><br><span class="line">var arr2 = arr1.slice();</span><br><span class="line">arr2[0] = <span class="string">&#x27;一&#x27;</span>;</span><br><span class="line">arr2[2].user = <span class="string">&#x27;AAA&#x27;</span>;</span><br><span class="line">console.log(<span class="string">&#x27;arr1&#x27;</span>,arr1)</span><br><span class="line">console.log(<span class="string">&#x27;arr2&#x27;</span>,arr2)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/DvCzFI"><img src="https://s3.ax1x.com/2020/12/07/DvCzFI.png" alt="DvCzFI.png"></a><br>补充说明：Array的slice和contact方法都不会修改原数组，而是会返回一个对原数组进行浅拷贝的新数组。这两种方法同Object.assign()一样，都是对第一层属性依次拷贝，如果第一层的属性是基本数据类型，就拷贝值；如果是引用数据类型，就拷贝内存地址。</p><h3 id="三、JS深拷贝"><a href="#三、JS深拷贝" class="headerlink" title="三、JS深拷贝"></a>三、JS深拷贝</h3><p>对对象的属性中所有引用类型的值，遍历到是基本类型的值为止。</p><h4 id="3-1、深拷贝实现方式"><a href="#3-1、深拷贝实现方式" class="headerlink" title="3.1、深拷贝实现方式"></a>3.1、深拷贝实现方式</h4><p>(1)JSON.parse(JSON.stringify())<br>原理：用JSON.stringify()将对象转成字符串，再用JSON.parse()把字符串解析成对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;language&#x27;</span> : [1,[2,3],[4,5]],</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj2.language[1] = [<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>];</span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>,obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>,obj2)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/DvPlXF"><img src="https://s3.ax1x.com/2020/12/07/DvPlXF.png" alt="DvPlXF.png"></a></p><p>缺点：这种方法可以实现数组和对象和基本数据类型的深拷贝，但不能处理函数。因为JSON.stringify()方法是将一个javascript值转换我一个JSON字符串，不能接受函数。其他影响如下：</p><ul><li>如果对象中有时间对象，那么用该方法拷贝之后的对象中，时间是字符串形式而不是时间对象</li><li>如果对象中有RegExp、Error对象，那么序列化的结果是空</li><li>如果对象中有函数或者undefined，那么序列化的结果会把函数或undefined丢失</li><li>如果对象中有NAN、infinity、-infinity，那么序列化的结果会变成null</li><li>JSON.stringfy（）只能序列化对象的可枚举自有属性，如果对象中有是构造函数生成的，那么拷贝后会丢弃对象的constructor</li><li>如果对象中存在循环引用也无法正确实现深拷贝</li></ul><p>（2）手写深拷贝函数</p><p>通过递归实现深拷贝</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> deepCopy(obj)&#123;</span><br><span class="line"> var result= Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line"> <span class="keyword">if</span> (obj &amp;&amp; typeof(obj) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="keyword">if</span> (obj.hasOwnProperty(i))&#123; // 思考：这句是否有必要？</span><br><span class="line">    <span class="keyword">if</span> (obj[i] &amp;&amp; typeof(obj[i]) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">     result[i] = deepCopy(obj[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     result[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line"> a: 1,</span><br><span class="line"> b: &#123;</span><br><span class="line">  c: 2</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = deepCopy(obj1);</span><br><span class="line">obj2.a = <span class="string">&#x27;一&#x27;</span>;</span><br><span class="line">obj2.b.c = <span class="string">&#x27;二&#x27;</span></span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>, obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>, obj2)</span><br></pre></td></tr></table></figure><blockquote><p>obj.hasOwnProperty(prop)用来判断obj这个对象中是否含有prop这个属性，返回布尔值，有则true，没有则false</p></blockquote><p>以上有个缺陷：当遇到两个互相引用的对象时，会出现死循环的情况，从而导致爆栈。为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否互相引用。</p><p>深拷贝函数改进（防止循环递归爆栈）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> deepCopy(obj, parent = null) &#123;</span><br><span class="line"> <span class="built_in">let</span> result = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line"> <span class="built_in">let</span> _parent = parent</span><br><span class="line"> // 该字段有父级则需要追溯该字段的父级</span><br><span class="line"> <span class="keyword">while</span>(_parent) &#123;</span><br><span class="line">  // 如果该字段引用了它的父级，则为循环引用</span><br><span class="line">  <span class="keyword">if</span> (_parent.originalParent === obj) &#123;</span><br><span class="line">   // 循环引用返回同级的新对象</span><br><span class="line">   <span class="built_in">return</span> _parent.currentParent </span><br><span class="line">  &#125;</span><br><span class="line">  _parent = _parent.parent</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (obj &amp;&amp; typeof(obj) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   // 如果字段的值也是一个对象</span><br><span class="line">   <span class="keyword">if</span> (obj[i] &amp;&amp; typeof(obj[i]) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    // 递归执行深拷，将同级的待拷贝对象传递给parent，方便追溯循环引用</span><br><span class="line">    result[i] = deepCopy(obj[i], &#123;</span><br><span class="line">     originalParent: obj,</span><br><span class="line">     currentParent: result,</span><br><span class="line">     parent: parent</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result[i] = obj[i]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line"> x: 1,</span><br><span class="line"> y: 2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.z = obj1</span><br><span class="line">var obj2 = deepCopy(obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>, obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>, obj2)</span><br></pre></td></tr></table></figure><p>以上代码可以复制到浏览器去试试吧</p><p>深拷贝函数最终版（支持基本数据类型、Array、Object、原型链、RegExp、Date类型）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> deepCopy(obj, parent = null) &#123;</span><br><span class="line"> <span class="built_in">let</span> result</span><br><span class="line"> <span class="built_in">let</span> _parent = parent</span><br><span class="line"> <span class="keyword">while</span>(_parent) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_parent.originalParent === obj) &#123;</span><br><span class="line">   <span class="built_in">return</span> _parent.currentParent</span><br><span class="line">  &#125;</span><br><span class="line">  _parent = _parent.parent</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (obj &amp;&amp; typeof(obj) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj instanceof RegExp) &#123;</span><br><span class="line">   result = new RegExp(obj.source, obj.flags)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj instanceof Date) &#123;</span><br><span class="line">   result = new Date(obj.getTime())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (obj instanceof Array) &#123;</span><br><span class="line">    result = []</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">let</span> proto = Object.getPrototypeOf(obj)</span><br><span class="line">    result = Object.create(proto)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj[i] &amp;&amp; typeof(obj[i]) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">     result[i] = deepCopy(obj[i], &#123;</span><br><span class="line">      originalParent: obj,</span><br><span class="line">      currentParent: result,</span><br><span class="line">      parent: parent</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     result[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">return</span> obj</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line"> x: 1 </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//试调用</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">construct</span></span>()&#123;</span><br><span class="line">  this.a = 1,</span><br><span class="line">  this.b = &#123;</span><br><span class="line">    x:2,</span><br><span class="line">    y:3,</span><br><span class="line">    z:[4,5,[6]]</span><br><span class="line">  &#125;,</span><br><span class="line">  this.c = [7,8,[9,10]],</span><br><span class="line">  this.d = new Date(),</span><br><span class="line">  this.e = /abc/ig,</span><br><span class="line">  this.f = <span class="keyword">function</span>(a,b)&#123;</span><br><span class="line">    <span class="built_in">return</span> a+b</span><br><span class="line">  &#125;,</span><br><span class="line">  this.g = null,</span><br><span class="line">  this.h = undefined,</span><br><span class="line">  this.i = <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  this.j = Symbol(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">construct.prototype.str = <span class="string">&quot;I&#x27;m prototype&quot;</span></span><br><span class="line">var obj1 = new construct()</span><br><span class="line">obj1.k = obj1</span><br><span class="line">obj2 = deepCopy(obj1)</span><br><span class="line"> </span><br><span class="line">obj2.b.x = 999</span><br><span class="line">obj2.c[0] = 666</span><br><span class="line"> </span><br><span class="line">console.log(<span class="string">&#x27;obj1&#x27;</span>, obj1)</span><br><span class="line">console.log(<span class="string">&#x27;obj2&#x27;</span>, obj2)</span><br></pre></td></tr></table></figure><p>（3）函数库<br>也可以使用一些函数库，比如函数库lodash，也有提供_.cloneDeep用来做深拷贝；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">  c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、预备知识&quot;&gt;&lt;a href=&quot;#一、预备知识&quot; class=&quot;headerlink&quot; title=&quot;一、预备知识&quot;&gt;&lt;/a&gt;一、预备知识&lt;/h3&gt;&lt;h4 id=&quot;1-1、JS数据类型&quot;&gt;&lt;a href=&quot;#1-1、JS数据类型&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://perfectsymphony.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端样式导入的方式有哪些？</title>
    <link href="https://perfectsymphony.github.io/2020/12/07/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://perfectsymphony.github.io/2020/12/07/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2020-12-06T16:36:09.000Z</published>
    <updated>2020-12-06T16:44:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="样式导入方式"><a href="#样式导入方式" class="headerlink" title="样式导入方式"></a>样式导入方式</h4><ul><li>link</li><li>import</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>link的使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">&quot;index.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>import的使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line"> @<span class="keyword">import</span> <span class="string">&quot;index.css&quot;</span>;</span><br><span class="line"> &lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4></li><li><p>link除了引用样式文件，还可以引用图片等资源文件，而import只引用样式文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;shortcut icon&quot;</span> href=<span class="string">&quot;/favicon.ico&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;image/x-icon&quot;</span> /&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;icon&quot;</span> sizes=<span class="string">&quot;any&quot;</span> mask href=<span class="string">&quot;//www.baidu.com/img/baidu.svg&quot;</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;search&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;application/opensearchdescription+xml&quot;</span> href=<span class="string">&quot;/content-search.xml&quot;</span> title=<span class="string">&quot;百度搜索&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>兼容性不同，link不存在兼容性的问题，import在IE5以上支持，是css2.1新增的</p></li><li><p>在样式表文件可以使用import导入其它的样式表文件，而link不可以</p></li><li><p>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p></li><li><p>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p></li></ul><h4 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h4><p>  import的写法比较多<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;style.css&#x27;</span> <span class="comment">//Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;style.css&quot;</span> <span class="comment">//Windows IE4/ NS4, Macintosh IE4/NS4不识别</span></span><br><span class="line">@<span class="keyword">import</span> url(style.css) <span class="comment">//Windows NS4, Macintosh NS4不识别</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">&#x27;style.css&#x27;</span>) <span class="comment">//Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">&quot;style.css&quot;</span>) <span class="comment">//Windows NS4, Macintosh NS4不识别</span></span><br></pre></td></tr></table></figure><br>  推荐使用 @import url(index.css);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;样式导入方式&quot;&gt;&lt;a href=&quot;#样式导入方式&quot; class=&quot;headerlink&quot; title=&quot;样式导入方式&quot;&gt;&lt;/a&gt;样式导入方式&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;link&lt;/li&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;使用方式&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://perfectsymphony.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>判断一个对象是否为空对象</title>
    <link href="https://perfectsymphony.github.io/2020/12/07/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>https://perfectsymphony.github.io/2020/12/07/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-12-06T16:23:07.000Z</published>
    <updated>2020-12-06T16:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&quot;jack&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>)]: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  value: <span class="string">&quot;john&quot;</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span> <span class="comment">// 不可枚举</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="方法一：-利用-for…in-循环"><a href="#方法一：-利用-for…in-循环" class="headerlink" title="方法一： 利用 for…in 循环"></a>方法一： 利用 for…in 循环</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isEmpty(obj) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> Object.keys(obj)) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span> // 进入循环即不为空</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(isEmpty(obj)) // <span class="literal">true</span></span><br><span class="line">console.log(isEmpty(obj1)) // <span class="literal">false</span></span><br><span class="line">console.log(isEmpty(obj2)) // <span class="literal">true</span></span><br><span class="line">console.log(isEmpty(obj3)) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="方法二：利用JSON-stringify-转化为字符串"><a href="#方法二：利用JSON-stringify-转化为字符串" class="headerlink" title="方法二：利用JSON.stringify()转化为字符串"></a>方法二：利用JSON.stringify()转化为字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEmpty = <span class="function">(<span class="params">obj</span>) =&gt;</span> (<span class="built_in">JSON</span>.stringify(obj) === <span class="string">&#x27;&#123;&#125;&#x27;</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj1)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj2)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj3)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="方法三-使用Object-keys-将取出对象中的键名，再判断长度"><a href="#方法三-使用Object-keys-将取出对象中的键名，再判断长度" class="headerlink" title="方法三: 使用Object.keys()将取出对象中的键名，再判断长度"></a>方法三: 使用Object.keys()将取出对象中的键名，再判断长度</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEmpty = <span class="function">(<span class="params">obj</span>) =&gt;</span> (<span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj1)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj2)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty(obj3)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由此可见，以上三种方法不能判断对象中的不可枚举属性。</p><p>如果对象中含有不可枚举属性，我们又需要找出这些属性，就可以使用 <code>Object.getOwnPropertyNames()</code> 和 <code>Object.getOwnPropertySymbols() </code> 这两个API。</p><p><code>Object.getOwnPropertyNames()</code>  返回对象中的所有属性（不包括symbol）</p><p><code>Object.getOwnPropertySymbols() </code> 只返回对象中的symbol属性</p><p>所以我们可以结合它们：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isEmpty(obj) &#123;</span><br><span class="line">  <span class="built_in">return</span>  !Object.getOwnPropertyNames(obj).length &amp;&amp;  !Object.getOwnPropertySymbols(obj).length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isEmpty(obj)) // <span class="literal">true</span></span><br><span class="line">console.log(isEmpty(obj1)) // <span class="literal">false</span></span><br><span class="line">console.log(isEmpty(obj2)) // <span class="literal">false</span></span><br><span class="line">console.log(isEmpty(obj3)) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://perfectsymphony.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js判断变量是不是数组的方法</title>
    <link href="https://perfectsymphony.github.io/2020/11/24/js%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://perfectsymphony.github.io/2020/11/24/js%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-11-23T16:17:31.000Z</published>
    <updated>2020-11-23T16:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="方案一：-instanceof"><a href="#方案一：-instanceof" class="headerlink" title="方案一： instanceof"></a>方案一： instanceof</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量 instanceof 类型  返回的是布尔值  <span class="literal">true</span> <span class="literal">false</span>&lt;br&gt;例: var a = []   a instanceof Array</span><br></pre></td></tr></table></figure><h4 id="方案二：-原型prototype-toString-call"><a href="#方案二：-原型prototype-toString-call" class="headerlink" title="方案二： 原型prototype + toString +  call()"></a>方案二： 原型prototype + toString +  call()</h4><p><a href="https://imgchr.com/i/DYq1xS"><img src="https://s3.ax1x.com/2020/11/24/DYq1xS.png" alt="DYq1xS.png"></a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先: Object.prototype.toString.call(variable)来判断，返回值是字符串</span><br><span class="line">其次: Object.prototype.toString.call(variable).indexOf(<span class="string">&#x27;Array&#x27;</span>) 如果变量对象是纯数组，返回的数字不是-1</span><br><span class="line">最后: Object.prototype.toString.call(variable).indexOf(<span class="string">&#x27;Array&#x27;</span>) !== -1 比对数值是否等于-1就能判断是否是数组类型 是为<span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="方案三：原型prototype-isPrototypeOf"><a href="#方案三：原型prototype-isPrototypeOf" class="headerlink" title="方案三：原型prototype + isPrototypeOf()"></a>方案三：原型prototype + isPrototypeOf()</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.isPrototypeOf(variable) </span><br></pre></td></tr></table></figure><h5 id="isPrototypeOf-函数-用于指示对象是否存在于一个对象的原型链中。如果存在返回true，反之返回false。该方法属Object对象，由于所有的对象都继承了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。如果variable的原型链中存在Array对象，就会返回true，也就说明variable是数组类型。"><a href="#isPrototypeOf-函数-用于指示对象是否存在于一个对象的原型链中。如果存在返回true，反之返回false。该方法属Object对象，由于所有的对象都继承了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。如果variable的原型链中存在Array对象，就会返回true，也就说明variable是数组类型。" class="headerlink" title="isPrototypeOf() 函数 : 用于指示对象是否存在于一个对象的原型链中。如果存在返回true，反之返回false。该方法属Object对象，由于所有的对象都继承了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。如果variable的原型链中存在Array对象，就会返回true，也就说明variable是数组类型。"></a>isPrototypeOf() 函数 : 用于指示对象是否存在于一个对象的原型链中。如果存在返回true，反之返回false。该方法属Object对象，由于所有的对象都继承了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。如果variable的原型链中存在Array对象，就会返回true，也就说明variable是数组类型。</h5><h4 id="方案四：构造函数-constructor"><a href="#方案四：构造函数-constructor" class="headerlink" title="方案四：构造函数 constructor"></a>方案四：构造函数 constructor</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable.constructor</span><br><span class="line">variable.constructor.toString()</span><br><span class="line">variable.constructor.toString().indexOf(<span class="string">&quot;Array&quot;</span>) ！== -1</span><br></pre></td></tr></table></figure><p>一个数组类型的实例，其原型<strong>proto</strong>.constructor右边是Array关键字，再拿到字符串，最后查找字符串中Array关键字的位置是否等于-1</p><h4 id="方案五：数组方法-isArray"><a href="#方案五：数组方法-isArray" class="headerlink" title="方案五：数组方法 isArray()"></a>方案五：数组方法 isArray()</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(variable)</span><br></pre></td></tr></table></figure><h2 id="javascript如何判断是否为对象？"><a href="#javascript如何判断是否为对象？" class="headerlink" title="javascript如何判断是否为对象？"></a>javascript如何判断是否为对象？</h2><p><strong>先声明一个对象</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;；</span><br></pre></td></tr></table></figure><p><strong>判断是否为对象的方法：</strong></p><p>1、toString（推荐）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(obj) === <span class="string">&#x27;[Object Object]&#x27;</span></span><br></pre></td></tr></table></figure><p>2、constructor属性</p><p>constructor 属性返回对创建此对象的 Boolean 函数的引用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor === Object</span><br></pre></td></tr></table></figure><p>3、instanceof运算符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj instanceof Object</span><br></pre></td></tr></table></figure><p>注：需要注意的是由于数组也是对象，因此用 arr instanceof Object 也为true。</p><p>4、typeof运算符</p><p>typeof运算符返回一个字符串，表示未经计算的操作数的类型。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof obj === Object</span><br><span class="line"></span><br><span class="line">// 根据typeof判断对象也不太准确</span><br><span class="line">表达式                     返回值</span><br><span class="line">typeof undefined       <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">typeof null               <span class="string">&#x27;object&#x27;</span></span><br><span class="line">typeof <span class="literal">true</span>               <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">typeof 123               <span class="string">&#x27;number&#x27;</span></span><br><span class="line">typeof <span class="string">&quot;abc&quot;</span>           <span class="string">&#x27;string&#x27;</span></span><br><span class="line">typeof <span class="function"><span class="title">function</span></span>() &#123;&#125;   <span class="string">&#x27;function&#x27;</span></span><br><span class="line">typeof &#123;&#125;               <span class="string">&#x27;object&#x27;</span></span><br><span class="line">typeof []               <span class="string">&#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>5、$.isPlainObject()</p><p>该方法判断指定参数是否是一个纯粹的对象（所谓”纯粹的对象”，就是该对象是通过”{}”或”new Object”创建的。）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.isPlainObject(obj)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;方案一：-instanceof&quot;&gt;&lt;a href=&quot;#方案一：-instanceof&quot; class=&quot;headerlink&quot; title=&quot;方案一： instanceof&quot;&gt;&lt;/a&gt;方案一： instanceof&lt;/h4&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://perfectsymphony.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>localStorage和sessionStorage区别</title>
    <link href="https://perfectsymphony.github.io/2020/11/18/localStorage%E5%92%8CsessionStorage%E5%8C%BA%E5%88%AB/"/>
    <id>https://perfectsymphony.github.io/2020/11/18/localStorage%E5%92%8CsessionStorage%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-18T03:05:46.000Z</published>
    <updated>2020-11-18T04:29:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>localStorage 和 sessionStorage一样都是用来存储客户端临时信息的对象。</p><p>他们均只能存储字符串类型的对象(虽然规范中可以存储其他类型的对象，但是目前位置没有浏览器对其进行实现)。<br>localStorage生命周期是永久的，这意味着用户除非在浏览器上清除localStorage信息，否则，这些信息将永远存在。<br>sessionStorage生命周期为当前窗口或者当前标签页，一旦窗口或者标签页被永久关闭，那么所有通过sessionStorage存储的数据也就被清空了。</p><p>不同的浏览器无法共享localStorage或者sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的localStorage(页面属于相同域名和端口)，但是不同页面或者标签页间无法共享sessionStorage的信息。这里需要注意，页面及标签仅指顶级窗口，如果标签页包含多个iframe标签且他们属于同源页面，那么他们之间可以共享sessionStorage的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;localStorage 和 sessionStorage一样都是用来存储客户端临时信息的对象。&lt;/p&gt;
&lt;p&gt;他们均只能存储字符串类型的对象(虽然规范中可以存储其他类型的对象，但是目前位置没有浏览器对其进行实现)。&lt;br&gt;localStorage生命周期是永久的，这意味着</summary>
      
    
    
    
    
    <category term="HTML" scheme="https://perfectsymphony.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>table使用总结</title>
    <link href="https://perfectsymphony.github.io/2020/11/13/table%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://perfectsymphony.github.io/2020/11/13/table%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-11-13T11:11:30.000Z</published>
    <updated>2020-11-13T11:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、(IE浏览器)使用 table-layout:fixed;强制table的宽度,内层td,th采用word-break : break-all;或者word-wrap : break-word ;换行</p><h3 id="2、解决设置table中td宽度不生效"><a href="#2、解决设置table中td宽度不生效" class="headerlink" title="2、解决设置table中td宽度不生效"></a>2、解决设置table中td宽度不生效</h3><ul><li><p>特性：table是一个整体，每一列td的宽度是由一个其中一个最长td的宽度决定的。</p></li><li><p>解决：一定要在table标签上加word-wrap: break-word; word-break: break-all;之后再设置百分比宽度就可以生效了(获取你用的bootstrap，可以添加col-md-1)</p><p><a href="https://imgchr.com/i/DpvwdS"><img src="https://s3.ax1x.com/2020/11/13/DpvwdS.png" alt="DpvwdS.png"></a><br><a href="https://imgchr.com/i/DpvWZT"><img src="https://s3.ax1x.com/2020/11/13/DpvWZT.png" alt="DpvWZT.png"></a></p><h1 id="让一个元素相对于父元素固定定位"><a href="#让一个元素相对于父元素固定定位" class="headerlink" title="让一个元素相对于父元素固定定位"></a>让一个元素相对于父元素固定定位</h1><p>遇到了一个场景，需要实现相对于父元素的fixed定位：在父元素内拖动滚动条时，”fixed”定位的元素不能滑动，在外层拖动滚动条时，父元素及父元素内的所有元素跟着一起滑动。但是position: fixed是相对于窗口进行的定位，不能直接实现我们需要的效果。</p></li></ul><p>  让特定子元素相对于父元素”fixed”定位，也就是说，剩余的子元素不定位。那我们可以分开来想，如果添加一个祖先元素assistor，有两个祖先元素，一个用于辅助定位，一个用于包裹不定位的内容，这个问题就解决了。</p><p>  实质上是child相对于assistorabsolute定位，parent内的内容自己负责展示。只要assistor和parent一样大，看起来就像是子元素child相对于父元素parent固定定位了。具体原理是position: absolute;的元素会相对于第一个设置了position: relative;的祖先元素进行定位，我们将assistor设置为position: reletive;，滚动条是在parent中的，这样”fixed”定位和parent内的内容滚动就都实现了。</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;<span class="built_in">test</span>&lt;/td&gt;&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.assistor &#123;</span><br><span class="line">  position: relative; /*关键点*/</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 300px;</span><br><span class="line">  margin: 100px auto 0 auto;</span><br><span class="line">  background-color: <span class="comment">#ddd;</span></span><br><span class="line">&#125;</span><br><span class="line">.parent &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 300px;</span><br><span class="line">  background-color: <span class="comment">#888;</span></span><br><span class="line">  overflow: auto; /*关键点*/</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  position: absolute; /*关键点*/</span><br><span class="line">  width: 120px;</span><br><span class="line">  height: 120px;</span><br><span class="line">  margin: 100px 50px;</span><br><span class="line">  background-color: <span class="comment">#eee;</span></span><br><span class="line">&#125;</span><br><span class="line">.placeholder &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 1000px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;assistor&quot;</span>&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;child&quot;</span>&gt;111&lt;/div&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;placeholder&quot;</span>&gt;</span><br><span class="line">  1114561611&lt;br/&gt;11134111&lt;br/&gt;1111116761111&lt;br/&gt;1111111111111111111111</span><br><span class="line">  11111111111111111111111111111111111111111111111111111111111</span><br><span class="line">  1111111111111111111111111111111111111122222222222222222222</span><br><span class="line">  22222222222222222222222222222222222222222222222222222222222</span><br><span class="line">  222222222222222222222222&lt;br/&gt; 2222222222222222222222222222222</span><br><span class="line">  22222222222222222222222222&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、(IE浏览器)使用 table-layout:fixed;强制table的宽度,内层td,th采用word-break : break-all;或者word-wrap : break-word ;换行&lt;/p&gt;
&lt;h3 id=&quot;2、解决设置table中td宽度不生效&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="HTML" scheme="https://perfectsymphony.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>什么是函数柯里化</title>
    <link href="https://perfectsymphony.github.io/2020/11/10/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://perfectsymphony.github.io/2020/11/10/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2020-11-10T05:51:26.000Z</published>
    <updated>2020-11-10T07:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、初步认识"><a href="#1、初步认识" class="headerlink" title="1、初步认识"></a>1、初步认识</h4><p>柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add1 = add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = add(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">1</span>)); <span class="comment">// 输出11</span></span><br></pre></td></tr></table></figure><p>代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。</p><p>在实际项目中，柯里化通常有以下三大作用</p><ul><li>参数复用</li><li>提前确认</li><li>延迟运行</li></ul><h5 id="作用一、参数复用"><a href="#作用一、参数复用" class="headerlink" title="作用一、参数复用"></a>作用一、参数复用</h5><p>所谓参数复用，就是利用闭包的原理，让我们前面传输过来的参数不要被释放掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常封装check函数进行字符串正则匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)        <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)     <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 使用柯里化函数进行字符串正则匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="作用二、提前确认"><a href="#作用二、提前确认" class="headerlink" title="作用二、提前确认"></a>作用二、提前确认</h5><p>这一特性经常是用来对浏览器的兼容性做出一些判断并初始化api，比如说我们目前用来监听事件大部分情况是使用addEventListener来实现的，但是一些较久的浏览器并不支持该方法，所以在使用之前，我们可以先做一次判断，之后便可以省略这个步骤了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> on = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="作用三、-延迟运行"><a href="#作用三、-延迟运行" class="headerlink" title="作用三、 延迟运行"></a>作用三、 延迟运行</h5><p>js中的bind这个方法，用到的就是柯里化的这个特征。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、初步认识&quot;&gt;&lt;a href=&quot;#1、初步认识&quot; class=&quot;headerlink&quot; title=&quot;1、初步认识&quot;&gt;&lt;/a&gt;1、初步认识&lt;/h4&gt;&lt;p&gt;柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://perfectsymphony.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是纯函数</title>
    <link href="https://perfectsymphony.github.io/2020/11/09/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>https://perfectsymphony.github.io/2020/11/09/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0/</id>
    <published>2020-11-09T08:22:58.000Z</published>
    <updated>2020-11-09T08:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。"><a href="#纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。" class="headerlink" title="纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。"></a>纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。</h3><p>下面我们来分别说明一下概念中的两个条件：</p><blockquote><h4 id="返回结果只依赖其参数"><a href="#返回结果只依赖其参数" class="headerlink" title="返回结果只依赖其参数"></a>返回结果只依赖其参数</h4></blockquote><p>返回值只和函数参数有关，与外部无关。无论外部发生什么样的变化，函数的返回值都不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  非纯函数 返回值与a相关，无法预料</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line">foo(<span class="number">2</span>)                    <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数 返回结果只依赖于它的参数 x 和 b，foo(1, 2) 永远是 3。今天是 3，明天也是 3，在服务器跑是 3，在客户端跑也 3，不管你外部发生了什么变化，foo(1, 2) 永远是 3。只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的。</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">x, b</span>) =&gt;</span> x + b</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="函数执行过程中没有副作用"><a href="#函数执行过程中没有副作用" class="headerlink" title="函数执行过程中没有副作用"></a>函数执行过程中没有副作用</h3></blockquote><p>函数执行的过程中对外部产生了可观察的变化，我们就说函数产生了副作用。<br>例如修改外部的变量、调用DOM API修改页面，发送Ajax请求、调用window.reload刷新浏览器甚至是console.log打印数据，都是副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无副作用</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">obj, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo(counter, <span class="number">2</span>)                       <span class="comment">// =&gt; 3</span></span><br><span class="line">counter.x                             <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改一下 ，再观察(修改了外部变量，产生了副作用。)</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">obj, b</span>) =&gt;</span> &#123;</span><br><span class="line">  obj.x = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo(counter, <span class="number">2</span>)                       <span class="comment">// =&gt; 4</span></span><br><span class="line">counter.x                             <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。&quot;&gt;&lt;a href=&quot;#纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。&quot; class=&quot;headerlink&quot; title=&quot;纯函数的概念：一个函数的返回结果只依赖其</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://perfectsymphony.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
